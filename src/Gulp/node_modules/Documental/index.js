var acorn = require( 'acorn' );
var walk = require( 'walk-ast' );
var modify = require( 'gulp-modify' );
var doctrine = require( "doctrine" );
var fs = require( 'fs' );
var gulp = require( 'gulp' );
var shell = require('gulp-shell');
var browserSync = require('browser-sync').create();
var open = require( 'gulp-open' );
var config;

//attempt to include the config
try {
	config = require( process.cwd() + '/' + 'documental.config.json' );
}catch( e ) {
	console.log( 'INFO: no config supplied' );
}


var DocAppBuilder = ( function( g, shell, bs, opn ) {

	var builder = {};

	var built = false;


	builder.build = function( serverRoot, projectName, port ) {

		g.task( 'bower-install', shell.task( 'bower install', { cwd: "./node_modules/documental/app" } ));

		g.task( 'make-browser', function() {
			bs.init({ server: {
				baseDir: serverRoot,
				open: false
			} });
		} );

		g.task("open-site", function(){
			var options = {
				url: "http://localhost:" + port + '/#/docs/plw',
				app: "chrome"
			};

			gulp.src("./conf.json")
				.pipe(opn("", options));
		});


		g.task( 'build-site', [ 'bower-install', 'open-site', 'make-browser' ] );

		g.start( 'build-site' );
		built = true;
	};

	builder.isBuilt = function() {
		return built;
	};

	return builder;

} )( gulp, shell, browserSync, open );

var Documental = ( function ( appBuilder ) {

	var Utils = {}, sourceMap = {}, commentsHash = {}, namespaceHash = {}, autocomplete = [];

	var total = 0, totalCommented = 0, totalAppendedChars = 0, nestedFunctionBoundaries = 0, currentFunctionBoundaries = 0;

	var tagConfig = {
		"augments": false, "author": false, "argument": false, "borrows": false, "class": false,
		"constant": false, "constructor": true, "constructs": false, "default": false, "deprecated": true,
		"description": false, "event": false, "example": false, "extends": false, "field": false,
		"fileOverview": false, "function": false, "ignore": false, "inner": false, "lends": false,
		"link": false, "memberOf": false, "name": false, "namespace": false, "param": true, "private": true,
		"property": false, "public": true, "requires": false, "returns": true, "return": true, "see": false,
		"since": false, "static": false, "throws": false, "type": false, "version": false
	};

	var par, project = "root", tags = Object.keys( tagConfig );
	var docAppPath = "./node_modules/documental/app/dist/data/";


	Utils.ingest = function() {

		project = config && config.projectName ? config.projectName : "project";
		process.on('beforeExit', function(){
			if( !appBuilder.isBuilt() ) {
				Utils.exportDataToJSON();
			}
		});

		return modify( {
			fileModifier: function ( file, contents ) {
				return Utils.determineFunctions(file,  contents, acorn, walk );
			}
		} );
	};


	Utils.commentFunction = function ( block, text, start, end, startloc, endloc ) {
		if ( block ) {
			text = "/*" + text + "*/";

			//console.log( text );

			if( text.indexOf( "@namespace" ) === -1 ) {
				Utils.addToCommentsHash( startloc.line, endloc.line, text );
			} else {

					var ns = doctrine.parse( text, { unwrap: true } )
					var desc = Utils.checkNamespace( ns );

					if( desc ) {
						Utils.addToCommentsHash( startloc.line, endloc.line, text, true, desc, start, end  );

					}

				//console.log( ns );



			}
		}

	};


	Utils.checkNamespace = function( docs ) {

		if( docs && docs.tags ) {

			for( var x = 0; x< docs.tags.length; x++ ) {

				if( docs.tags[ x ].title === "namespace" ) {
					return docs.tags[ x ].name ;

				}

			}

		}

		return false;
	};



	Utils.addToCommentsHash = function ( start, end, txt, namespace, namespaceID, schar, echar ) {
		if( !namespace ) {
			commentsHash[ start.toString() ] = {};
			commentsHash[ start.toString() ] = txt;
		} else {

			//create a new namespace reference and give it a
			//scope that is identified by its start and end location

			var nspaces = Object.keys( namespaceHash );

			if( nspaces.length > 0 ) {

				namespaceHash[ nspaces[ nspaces.length - 1 ] ].end = schar;

			}

			namespaceHash[ start.toString() ] = {
				name: namespaceID,
				start: schar,
				end: -1
			}




		}

	};

	Utils.findCommentsBetween = function ( startNewFunction, endOldFunction ) {
		var res = -1;

		Object.keys( commentsHash ).forEach( function ( commentLine, indexInHash ) {

				if ( parseInt( commentLine ) > endOldFunction && parseInt( commentLine ) < startNewFunction ) {
					var doctext = commentsHash[ commentLine ];
					var rexptest = /^[\s]*\/\*\*/.test( doctext );
					if ( rexptest ) {
						var docAST = doctrine.parse( doctext, { unwrap: true } );
						var issues = [];
						if ( docAST.description !== "" ) {
							for ( var i = 0; i < docAST.tags.length; i++ ) {
								if ( tagConfig[ docAST.tags[ i ].title ] == undefined ) {
									issues.push( { type: "BAD TAG", info: docAST.tags[ i ].title } );
								}
							}
						} else {
							issues.push( { type: "MISSING", info: "Description" } );
						}
						if ( issues.length > 0 ) {
							res = docAST;
						} else {
							totalCommented++;
							res = docAST;
						}
					}
				}
			}
		);
		return res;
	};

	Utils.exportDataToJSON = function () {

		//var outPath = config && config.jsonOutput && !config.useApp ? process.cwd() + '/' + config.jsonOutput  : process.cwd() + '/';
		var outPath = config && config.jsonOutput && !config.useApp ? process.cwd() + '/' + config.jsonOutput  : docAppPath;

		if( config.useApp ) {
			appBuilder.build( "./node_modules/documental/app/dist", Utils.getProjectName(), 8009 );
		}

		fs.writeFileSync( outPath + Utils.getProjectName() + '-menuTree.json', Utils.makeMenuTree() );
		fs.writeFileSync( outPath + Utils.getProjectName() + '-sourcemap.json', Utils.getSourceMap() );
		fs.writeFileSync( outPath + Utils.getProjectName() + '-autocomplete.json', Utils.getAutocomplete() );
	};

	Utils.hasConstructor = function ( source ) {
		return /@constructor|@Constructor/.test( source );
	};


	Utils.postOrderTraverse = function ( node ) {

		if ( node.name ) {
			return node.name;
		} else {
			if ( node.type == 'ThisExpression' ) {
				return "this";
			} else if ( node.type == "Literal" ) {
				return "[ LITERAL ]";
			} else {
				return Utils.postOrderTraverse( node.object ) + "." + Utils.postOrderTraverse( node.property );
			}

		}
	};

	Utils.autoGenerateDocStub = function ( source, functionNode, functionname ) {

		var augmentedStart = functionNode.start + totalAppendedChars;
		var before = source.slice( 0, augmentedStart );
		var after = source.slice( augmentedStart, source.length + 1 );
		var comment = "This Function Needs Documentation \n ";
		var parameter_names = [];
		parameter_names = Utils.getSimpleParameters( functionNode );

		if ( totalAppendedChars == 0 && !Utils.hasConstructor( source ) ) {
			comment = "This Function Needs Documentation  \n * @constructor " + functionname + "\n \n ";
		}

		if ( parameter_names.length > 0 ) {
			for ( var x = 0; x < parameter_names.length; x++ ) {
				comment += " * @param " + parameter_names[ x ] + "\n";
			}
		}
		totalAppendedChars += comment.length;

		return comment;
	};

	Utils.cleanName = function ( name ) {
		if ( name.charAt( 0 ) === "." ) {
			return name.substring( 1 );
		}
	};

	Utils.recurseUpTree = function ( node ) {

		if ( node.parentNode.type == "AssignmentExpression" ) {
			return Utils.recurseUpTree( node.parentNode ) + "." + Utils.postOrderTraverse( node.parentNode.left );
		}
		if ( node.parentNode.type == "VariableDeclaration" ) {
			return Utils.recurseUpTree( node.parentNode ) + "." + node.parentNode.declarations[ 0 ].id.name;
		}
		if ( node.parentNode ) {
			return Utils.recurseUpTree( node.parentNode );
		} else {
			return "";
		}
	};

	Utils.determineFunctions = function ( file,  sourceString, acornInstance, walk ) {

		var methodCount = 0, nested = "", newdocstring,
							rightside, body, name, prefix, terminal, doc;

		var sourceStart, sourceStop, ast;

		currentFunctionBoundaries = 0;


		try {
			ast = acornInstance.parse( sourceString, {
				locations: true,
				ranges: true,
				directSourceFile: true,
				onComment: Utils.commentFunction
			} );

			walk( ast, function ( node ) {

				///console.log( namespaceHash );

				var foundApplicableFunction = false;

				if ( node.type == 'FunctionDeclaration' ) {
					rightside = node;
					sourceStart = node.start;
					sourceStop = node.end;
					terminal = node.id.name;
					name = node.id.name;
					foundApplicableFunction = true;
				}

				// detect functions declared as variables
				if ( node.type == 'VariableDeclaration' ) {
					node.declarations.forEach( function ( declaration, declIndex ) {
						if ( declaration.init && declaration.init.type == 'FunctionExpression' ) {

							rightside = declaration.init;
							sourceStart = node.start;
							sourceStop = declaration.init.end;
							name = Utils.cleanName( Utils.recurseUpTree( node ) );

							if ( !name ) {
								name = declaration.id.name;
							} else {
								name += "." + declaration.id.name
							}

							terminal = name.split( '.' )[ name.split( '.' ).length - 1 ];

							foundApplicableFunction = true;
						}
					} )
				}

				if ( node.type == 'ExpressionStatement' ) {

					if ( node.expression && node.expression.left && node.expression.right && node.expression.left.type == 'MemberExpression'
						&& (node.expression.right.type == 'FunctionExpression' || node.expression.right.type == "CallExpression" ) ) {

						rightside = node.expression.right;
						if ( node.expression.right.type == "CallExpression" ) {
							rightside = node.expression.right.callee
						}
						sourceStart = node.expression.left.start;
						sourceStop = rightside.end;
						if ( rightside.type == "FunctionExpression" ) {
							name = Utils.postOrderTraverse( node.expression.left );
							prefix = Utils.cleanName( Utils.recurseUpTree( node ) );
							if ( prefix ) {
								name = Utils.cleanName( Utils.recurseUpTree( node ) ) + "." + name;
							}
							terminal = name.split( '.' )[ name.split( '.' ).length - 1 ];
							foundApplicableFunction = true;
						}

					}
				}

				if( foundApplicableFunction ) {
					body = sourceString.substring( sourceStart, sourceStop );
					par = Utils.paramsToStringRepresentation( Utils.getSimpleParameters( rightside ) );
					methodCount++;
					doc = Utils.findComments( rightside.loc );
					if ( doc == -1 ) {
						//console.log( 'method : ', name, ' not documented'  );
						newdocstring = Utils.autoGenerateDocStub( sourceString, rightside, name );
						doc = doctrine.parse( newdocstring, { unwrap: true } );
					}

					name = Utils.useRulesDetermineNamespace( name, doc, sourceStart, sourceStop );
					console.log( name );

					Utils.addMemberToSourceMap( sourceMap, name, doc, body );
					autocomplete.push( { n: name, t: terminal } );
				}
			} );

		}catch( e ) {
			console.log( 'cant parse ', file, e )
		}

		total += methodCount;
		Utils.clearCommentCache();
		return sourceString;
	};

	Utils.useRulesDetermineNamespace = function( name, docs, start, stop  ) {

		//check if there is a namespace that can be used
		var ns = "";
		var spaces = Object.keys( namespaceHash );
		if( spaces.length ) {
			for( var l = 0; l < spaces.length; l++ ) {
				if( namespaceHash[ spaces[ l ] ].end !== -1 && namespaceHash[ spaces[ l ] ].start < start && namespaceHash[ spaces[ l ] ].end > stop ) {
					ns = namespaceHash[ spaces[ l ] ].name;
					break;
				} else if( namespaceHash[ spaces[ l ] ].end === -1 ) {
					ns = namespaceHash[ spaces[ l ] ].name;
					break;
				}
			}
		}

		//console.log( 'func bound is : ', start, ' ', stop, ' chosen ns is  ', ns  );

		//chack if the calculated name uses the namespace already
		if( ns && ns !== "" && name.indexOf( ns ) === -1 ) {

			//does not fully contain, check divergence
			var divergenceIndex = Utils.findIndexOfDifference( name.split( '.' ), ns.split( '.' ) );
			console.log( divergenceIndex );
			if( divergenceIndex === -1 ) {
				//console.log( 'created namespace : ',  ns + "." + name);
				return ns + "." + name;
			}

			//combine the namepace and the derived name into one
			return Utils.combineNamespacesAtIndex( ns, name, divergenceIndex ).join( '.' );
		}

		return name;
	};

	Utils.combineNamespacesAtIndex = function( a, b, idx ) {


		a = a.split( '.' );
		b = b.split( '.' );



		var comb = Array.prototype.concat( a.splice( 0, idx ), b.splice( idx, b.length ) )
		console.log( a, b, idx );
		console.log( comb.join( "." ) );

		return comb;

	};

	Utils.findIndexOfDifference = function( a, b ) {

		//given two arrays check at which index do they
		//diverge into non-directly matching arrays

		var index = -1;
		//only iterate as fara as the smallest array
		var smallestLength = a.length <= b.length ? a.length : b.length;

		for( var c = 0; c < smallestLength; c++  ) {
			if( a[ c ] === b[ c ] ) {
				index ++;
			} else {
				return index;
			}
		}

		return index;

	};

	Utils.checkMemberOf = function( name, docs ) {

		if( docs && docs.tags ) {

			for( var x = 0; x< docs.tags.length; x++ ) {

				if( docs.tags[ x ].title === "memberof" ) {

					//console.log( name, docs );

					var candidate_name = name.split( '.' );
					if( candidate_name.length ) {
						return docs.tags[ x ].description + "." + name;
					}

				}

			}

		}

		return name;
	};


	Utils.getProjectName = function () {
		return project;
	};

	Utils.addMemberToSourceMap = function ( updatemap, name, docu, src ) {
		var memberpath = name.split( "." );
		var islast = false;

		for ( i = 0; i < memberpath.length; i++ ) {
			if ( updatemap[ memberpath[ i ] ] == undefined ) {
				updatemap[ memberpath[ i ] ] = {}
			}
			updatemap = updatemap[ memberpath[ i ] ];
		}
		updatemap[ "Documentation" ] = docu;
		if ( src ) {
			updatemap[ "Source" ] = src;
		}

	};

	Utils.clearCommentCache = function () {
		commentsHash = {};
		namespaceHash = {};
		totalAppendedChars = 0;
	};

	Utils.getSourceMap = function () {
		return JSON.stringify( sourceMap );
	};

	var Tree = {};

	Utils.recurseMenuTree = function ( sourceObject, tree, nodename, menu, workingpath ) {

		var noden = nodename || project;
		tree = tree || " ";

		console.log( tree + noden );
		menu.text = noden;

		if ( menu.text === project ) {
			menu.isExpanded = "true";
		}

		if ( menu.children ) {

		} else {
			menu.children = [];
		}

		if ( typeof sourceObject === "object" && sourceObject !== null && !sourceObject[ "description" ] ) {
			//console.log(sourceObject);
			var keys = Object.keys( sourceObject );
			tree = tree + " ";
			var ct = 0;


			if ( noden === project ) {
				workingpath = "";
			} else {
				if ( workingpath === "" ) {
					workingpath = noden;
				} else {
					workingpath = workingpath + "." + noden;
				}

			}

			for ( var x = 0; x < keys.length; x++ ) {
				if ( keys[ x ] === 'Documentation' || keys[ x ] === 'Source' ) {

					ct++;
					continue;
				}
				if ( noden !== "Documentation" && keys[ x ] !== 'Documentation' ) {

					var augpath;
					if ( workingpath === "" ) {
						augpath = keys[ x ];
					} else {
						augpath = workingpath + "." + keys[ x ];
					}
					menu.children[ x - ct ] = {
						text: noden,
						children: [],
						path: augpath
					};

					Utils.recurseMenuTree( sourceObject[ keys[ x ] ], tree, keys[ x ], menu.children[ x - ct ], workingpath );
				}

			}
		}

	};

	Utils.makeMenuTree = function () {
		Utils.recurseMenuTree( sourceMap, "", "", Tree, "" );
		return JSON.stringify( [ Tree ] );
	};

	Utils.getAutocomplete = function () {
		return JSON.stringify( autocomplete );
	};

	Utils.findComments = function ( location ) {

		var isdoc;

		if ( currentFunctionBoundaries ) {
			if ( location.start.line > currentFunctionBoundaries.end.line ) {
				isdoc = Utils.findCommentsBetween( location.start.line, currentFunctionBoundaries.end.line );
				currentFunctionBoundaries = location;
			} else if ( location.start.line < currentFunctionBoundaries.end.line ) {
				if ( nestedFunctionBoundaries ) {
					isdoc = Utils.findCommentsBetween( location.start.line, nestedFunctionBoundaries.end.line );
				} else {
					isdoc = Utils.findCommentsBetween( location.start.line, currentFunctionBoundaries.start.line );
				}

				nestedFunctionBoundaries = location;
			}

		} else {
			isdoc = Utils.findCommentsBetween( location.start.line, 0 );
			currentFunctionBoundaries = location;
		}

		return isdoc;
	};

	Utils.getPercentDocumented = function () {
		return (totalCommented / total) * 100;
	};


	Utils.getTotal = function () {
		return total;
	};

	Utils.getSimpleParameters = function ( functionStructure ) {
		var params = [];
		functionStructure.params.forEach( function ( p ) {
			params.push( p.name );
		} );
		return params;

	};

	Utils.paramsToStringRepresentation = function ( p ) {
		if ( p.length > 0 ) {
			return " <-- " + p.join( " | " );
		} else {
			return "";
		}
	};

	return Utils.ingest;


})( DocAppBuilder );


module.exports = Documental;