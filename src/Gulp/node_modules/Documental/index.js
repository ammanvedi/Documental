var acorn = require( 'acorn' );
var walk = require( 'walk-ast' );
var modify = require( 'gulp-modify' );
var doctrine = require( "doctrine" );
var fs = require( 'fs' );

var Documental = (function () {

	var tagConfig = {
		"augments": false, "author": false, "argument": false, "borrows": false, "class": false,
		"constant": false, "constructor": true, "constructs": false, "default": false, "deprecated": true,
		"description": false, "event": false, "example": false, "extends": false, "field": false,
		"fileOverview": false, "function": false, "ignore": false, "inner": false, "lends": false,
		"link": false, "memberOf": false, "name": false, "namespace": false, "param": true, "private": true,
		"property": false, "public": true, "requires": false, "returns": true, "return": true, "see": false,
		"since": false, "static": false, "throws": false, "type": false, "version": false
	};
	var Utils = {};
	var project = "root";
	var total = 0;
	var totalCommented = 0;
	var currentFunctionBoundaries = 0;
	var nestedFunctionBoundaries = 0;
	var autocomplete = [];
	var par;
	var totalAppendedChars = 0;
	var tags = Object.keys( tagConfig );
	var commentsHash = {};
	var sourceMap = {};

	Utils.commentFunction = function ( block, text, start, end, startloc, endloc ) {
		if ( block ) {
			text = "/*" + text + "*/";
			Utils.addToCommentsHash( startloc.line, endloc.line, text );
		}

	};

	Utils.addToCommentsHash = function ( start, end, txt ) {
		commentsHash[ start.toString() ] = {};
		commentsHash[ start.toString() ] = txt;
	};

	Utils.findCommentsBetween = function ( startNewFunction, endOldFunction ) {
		var res = -1;
		console.log( startNewFunction, endOldFunction  );

		Object.keys( commentsHash ).forEach( function ( commentLine, indexInHash ) {

				if ( parseInt( commentLine ) > endOldFunction && parseInt( commentLine ) < startNewFunction ) {
					console.log( 'found text' );
					var doctext = commentsHash[ commentLine ];
					var rexptest = /^[\s]*\/\*\*/.test( doctext );
					if ( rexptest ) {
						console.log( 'parsing' );
						var docAST = doctrine.parse( doctext, { unwrap: true } );
						var issues = [];
						if ( docAST.description !== "" ) {
							for ( var i = 0; i < docAST.tags.length; i++ ) {
								if ( tagConfig[ docAST.tags[ i ].title ] == undefined ) {
									issues.push( { type: "BAD TAG", info: docAST.tags[ i ].title } );
								}
							}
						} else {
							issues.push( { type: "MISSING", info: "Description" } );
						}
						if ( issues.length > 0 ) {
							res = docAST;
						} else {
							totalCommented++;
							res = docAST;
						}
					}
				}
			}
		);

		return res;
	};


	Utils.exportDataToJSON = function () {
		fs.writeFileSync( Utils.getProjectName() + '-menuTree.json', Utils.makeMenuTree() );
		fs.writeFileSync( Utils.getProjectName() + '-sourcemap.json', Utils.getSourceMap() );
		fs.writeFileSync( Utils.getProjectName() + '-autocomplete.json', Utils.getAutocomplete() );
	};

	Utils.ingest = function ( projectname ) {

		project = projectname;
		return modify( {
			fileModifier: function ( file, contents ) {
				return Utils.determineFunctions( contents, acorn, walk );
			}
		} );

	};


	Utils.hasConstructor = function ( source ) {
		return /@constructor|@Constructor/.test( source );
	};


	Utils.postOrderTraverse = function ( node ) {

		if ( node.name ) {
			return node.name;
		} else {
			if ( node.type == 'ThisExpression' ) {
				return "this";
			} else if ( node.type == "Literal" ) {
				return "[ LITERAL ]";
			} else {
				return Utils.postOrderTraverse( node.object ) + "." + Utils.postOrderTraverse( node.property );
			}

		}
	};

	Utils.autoGenerateDocStub = function ( source, functionNode, functionname ) {

		var augmentedStart = functionNode.start + totalAppendedChars;
		var before = source.slice( 0, augmentedStart );
		var after = source.slice( augmentedStart, source.length + 1 );
		var comment = "This Function Needs Documentation \n ";
		var parameter_names = [];
		parameter_names = Utils.getSimpleParameters( functionNode );

		if ( totalAppendedChars == 0 && !Utils.hasConstructor( source ) ) {
			comment = "This Function Needs Documentation  \n * @constructor " + functionname + "\n \n ";
		}

		if ( parameter_names.length > 0 ) {
			for ( var x = 0; x < parameter_names.length; x++ ) {
				comment += " * @param " + parameter_names[ x ] + "\n";
			}
		}
		totalAppendedChars += comment.length;

		return comment;
	};

	Utils.cleanName = function ( name ) {
		if ( name.charAt( 0 ) === "." ) {
			return name.substring( 1 );
		}
	};

	Utils.recurseUpTree = function ( node ) {

		if ( node.parentNode.type == "AssignmentExpression" ) {
			return Utils.recurseUpTree( node.parentNode ) + "." + Utils.postOrderTraverse( node.parentNode.left );
		}
		if ( node.parentNode.type == "VariableDeclaration" ) {
			return Utils.recurseUpTree( node.parentNode ) + "." + node.parentNode.declarations[ 0 ].id.name;
		}
		if ( node.parentNode ) {
			return Utils.recurseUpTree( node.parentNode );
		} else {
			return "";
		}
	};

	Utils.determineFunctions = function ( sourceString, acornInstance, walk ) {

		var methodCount = 0, currentFunctionBoundaries = 0, nested = "", newdocstring,
							rightside, body, name, prefix, terminal, doc;

		var sourceStart, sourceStop;


		var ast = acornInstance.parse( sourceString, {
			locations: true,
			ranges: true,
			directSourceFile: true,
			onComment: Utils.commentFunction
		} );

		walk( ast, function ( node ) {

			var foundApplicableFunction = false;

			if ( node.type == 'FunctionDeclaration' ) {
				rightside = node;
				sourceStart = node.start;
				sourceStop = node.end;
				terminal = node.id.name;
				name = node.id.name;
				foundApplicableFunction = true;
			}

			// detect functions declared as variables
			if ( node.type == 'VariableDeclaration' ) {
				node.declarations.forEach( function ( declaration, declIndex ) {
					if ( declaration.init && declaration.init.type == 'FunctionExpression' ) {

						rightside = declaration.init;
						sourceStart = node.start;
						sourceStop = declaration.init.end;
						name = Utils.cleanName( Utils.recurseUpTree( node ) );

						if ( !name ) {
							name = declaration.id.name;
						} else {
							name += "." + declaration.id.name
						}

						terminal = name.split( '.' )[ name.split( '.' ).length - 1 ];

						foundApplicableFunction = true;
					}
				} )
			}

			if ( node.type == 'ExpressionStatement' ) {

				if ( node.expression && node.expression.left && node.expression.right && node.expression.left.type == 'MemberExpression'
					&& (node.expression.right.type == 'FunctionExpression' || node.expression.right.type == "CallExpression" ) ) {

					rightside = node.expression.right;
					if ( node.expression.right.type == "CallExpression" ) {
						rightside = node.expression.right.callee
					}
					sourceStart = node.expression.left.start;
					sourceStop = rightside.end;
					if ( rightside.type == "FunctionExpression" ) {
						name = Utils.postOrderTraverse( node.expression.left );
						prefix = Utils.cleanName( Utils.recurseUpTree( node ) );
						if ( prefix ) {
							name = Utils.cleanName( Utils.recurseUpTree( node ) ) + "." + name;
						}
						terminal = name.split( '.' )[ name.split( '.' ).length - 1 ];
						foundApplicableFunction = true;
					}

				}
			}

			if( foundApplicableFunction ) {
				body = sourceString.substring( sourceStart, sourceStop );
				par = Utils.paramsToStringRepresentation( Utils.getSimpleParameters( rightside ) );
				methodCount++;
				doc = Utils.findComments( rightside.loc );
				if ( doc == -1 ) {
					console.log( 'method : ', name, ' not documented'  );
					newdocstring = Utils.autoGenerateDocStub( sourceString, rightside, name );
					doc = doctrine.parse( newdocstring, { unwrap: true } );
				} else {
					console.log( 'method : ', name, ' documented'  );
				}
				Utils.addMemberToSourceMap( sourceMap, name, doc, body );
				autocomplete.push( { n: name, t: terminal } );
			}


		} );

		console.log( "\n\nDetected " + methodCount + " functions in total...\n\n" );
		total += methodCount;
		Utils.clearCommentCache();
		return sourceString;

	};

	Utils.getProjectName = function () {
		return project;
	};

	Utils.addMemberToSourceMap = function ( updatemap, name, docu, src ) {
		var memberpath = name.split( "." );
		var islast = false;

		for ( i = 0; i < memberpath.length; i++ ) {
			if ( updatemap[ memberpath[ i ] ] == undefined ) {
				updatemap[ memberpath[ i ] ] = {}
			}
			updatemap = updatemap[ memberpath[ i ] ];
		}
		updatemap[ "Documentation" ] = docu;
		if ( src ) {
			updatemap[ "Source" ] = src;
		}

	};

	Utils.clearCommentCache = function () {
		commentsHash = {};
		totalAppendedChars = 0;
	};

	Utils.getSourceMap = function () {
		return JSON.stringify( sourceMap );
	};

	var Tree = {};

	Utils.recurseMenuTree = function ( sourceObject, tree, nodename, menu, workingpath ) {

		var noden = nodename || project;
		tree = tree || " ";

		console.log( tree + noden );
		menu.text = noden;

		if ( menu.text === project ) {
			menu.isExpanded = "true";
		}

		if ( menu.children ) {

		} else {
			menu.children = [];
		}

		if ( typeof sourceObject === "object" && sourceObject !== null && !sourceObject[ "description" ] ) {
			//console.log(sourceObject);
			var keys = Object.keys( sourceObject );
			tree = tree + " ";
			var ct = 0;


			if ( noden === project ) {
				workingpath = "";
			} else {
				if ( workingpath === "" ) {
					workingpath = noden;
				} else {
					workingpath = workingpath + "." + noden;
				}

			}

			for ( var x = 0; x < keys.length; x++ ) {
				if ( keys[ x ] === 'Documentation' || keys[ x ] === 'Source' ) {

					ct++;
					continue;
				}
				if ( noden !== "Documentation" && keys[ x ] !== 'Documentation' ) {

					var augpath;
					if ( workingpath === "" ) {
						augpath = keys[ x ];
					} else {
						augpath = workingpath + "." + keys[ x ];
					}
					menu.children[ x - ct ] = {
						text: noden,
						children: [],
						path: augpath
					};

					Utils.recurseMenuTree( sourceObject[ keys[ x ] ], tree, keys[ x ], menu.children[ x - ct ], workingpath );
				}

			}
		}

	};

	Utils.makeMenuTree = function () {
		Utils.recurseMenuTree( sourceMap, "", "", Tree, "" );
		return JSON.stringify( [ Tree ] );
	};

	Utils.getAutocomplete = function () {
		return JSON.stringify( autocomplete );
	};

	Utils.findComments = function ( location ) {

		var isdoc;

		if ( currentFunctionBoundaries ) {
			if ( location.start.line > currentFunctionBoundaries.end.line ) {
				isdoc = Utils.findCommentsBetween( location.start.line, currentFunctionBoundaries.end.line );
				currentFunctionBoundaries = location;
			} else if ( location.start.line < currentFunctionBoundaries.end.line ) {
				if ( nestedFunctionBoundaries ) {
					isdoc = Utils.findCommentsBetween( location.start.line, nestedFunctionBoundaries.end.line );
				} else {
					isdoc = Utils.findCommentsBetween( location.start.line, currentFunctionBoundaries.start.line );
				}

				nestedFunctionBoundaries = location;
			}

		} else {
			isdoc = Utils.findCommentsBetween( location.start.line, 0 );
			currentFunctionBoundaries = location;
		}

		return isdoc;
	}

	Utils.getPercentDocumented = function () {
		return (totalCommented / total) * 100;
	}


	Utils.getTotal = function () {
		return total;
	}

	Utils.getSimpleParameters = function ( functionStructure ) {
		var params = [];
		functionStructure.params.forEach( function ( p ) {
			params.push( p.name );
		} );
		return params;

	}

	Utils.paramsToStringRepresentation = function ( p ) {
		if ( p.length > 0 ) {
			return " <-- " + p.join( " | " );
		} else {
			return "";
		}
	}

	return {
		UTIL: Utils
	}


})
();


module.exports = Documental;