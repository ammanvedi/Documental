var acorn = require('acorn');
var walk = require('walk-ast');
var modify = require('gulp-modify');
var doctrine = require("doctrine");

var Documental = (function(){

    var Utils = {};
    var total = 0;
    var totalCommented = 0;
    var currentFunctionBoundaries = 0;
    var par;

    var commentsHash =  new Object();

    var commentfunction = function(block, text, start, end, startloc, endloc)
    {
        if(block)
        {

            //text is "CONTENT" need full comment syntax
            text = "/*" + text + "*/"
            addToCommentsHash(startloc.line, endloc.line, text);
        }

    }

    var addToCommentsHash = function(start, end, txt)
    {
        commentsHash[start.toString()] = new Object();
        commentsHash[start.toString()] = txt;
    }

    var findCommentsBetween = function(startNewFunction, endOldFunction)
    {
        var res = ""

        Object.keys(commentsHash).forEach(function(commentLine, indexInHash){
            if(parseInt(commentLine) > endOldFunction && parseInt(commentLine) < startNewFunction)
            {
                totalCommented++;
                var doctext = commentsHash[commentLine];
                var rexptest = /^[\s]*\/\*\*/.test(doctext);
                if(rexptest)
                {
                    var docAST = doctrine.parse(doctext, {unwrap:true});
                    console.log("AST");
                    console.log(docAST);
                }


                res =  " (Documented) "
            }
        });

        return res;
    }

    Utils.ingest = function()
    {

        return modify({
        fileModifier: function(file, contents) {
            Utils.determineFunctions(contents, acorn, walk);
            return contents;
        }
    });

    }



    Utils.postOrderTraverse = function(node)
    {

        if(node.name)
        {
            return node.name;
        }else{
            if(node.type == 'ThisExpression')
            {
                return "this";
            }else if(node.type == "Literal"){
                return "[ LITERAL ]";
            }else
            {
                return Utils.postOrderTraverse(node.object) + "."  + Utils.postOrderTraverse(node.property);
            }

        }
    }

    Utils.determineFunctions = function(sourceString, acornInstance, walk)
    {
        var methodCount = 0;
        currentFunctionBoundaries = 0;
        var nested = "";


        var ast = acornInstance.parse(sourceString, {
            locations: true,
            ranges: true,
            directSourceFile: true,
            onComment: commentfunction
        });

        walk(ast, function(node){

            // detect functions declared at runtime
            if(node.type == 'FunctionDeclaration')
            {

                nested = Utils.determineNesting(node.loc);
                par = Utils.paramsToStringRepresentation(Utils.getSimpleParameters(node));
                methodCount++;

                console.log("Method Declared : ", nested,node.id.name, par);
            }
            // detect functions declared as variables
            if(node.type == 'VariableDeclaration')
            {
                node.declarations.forEach(function(declaration, declIndex){
                    if( declaration.init && declaration.init.type == 'FunctionExpression')
                    {
                        nested = Utils.determineNesting(declaration.loc);
                        par = Utils.paramsToStringRepresentation(Utils.getSimpleParameters(declaration.init));
                        methodCount++;

                        console.log("Method Declared : ", nested,declaration.id.name, par);
                    }
                })
            }

            //detect functions created on prototypes and
            if(node.type == 'ExpressionStatement')
            {
                if(node.expression && node.expression.left && node.expression.right && node.expression.left.type == 'MemberExpression'
                    &&  node.expression.right.type == 'FunctionExpression')
                {

                    nested = Utils.determineNesting(node.expression.right.loc);
                    par = Utils.paramsToStringRepresentation(Utils.getSimpleParameters(node.expression.right));
                    methodCount++;

                    console.log("Method Declared : ", nested ,Utils.postOrderTraverse(node.expression.left), par );
                }
            }

        });

        console.log("\n\nDetected "  + methodCount + " methods in total...\n\n");
        total += methodCount;

        Utils.clearCommentCache();

    }

    Utils.clearCommentCache = function()
    {
        commentsHash = new Object();
    }

    Utils.determineNesting = function(location)
    {
        if(currentFunctionBoundaries)
        {
            if(location.start.line > currentFunctionBoundaries.end.line)
            {
                var isdoc =  findCommentsBetween(location.start.line, currentFunctionBoundaries.end.line);
                currentFunctionBoundaries = location;
                return isdoc;
            }else if (location.start.line < currentFunctionBoundaries.end.line)
            {
                return "      ";
            }

        }else{
            var isdoc =  findCommentsBetween(location.start.line, 0);
            currentFunctionBoundaries = location;
            return isdoc;
        }
    }

    Utils.getPercentDocumented = function()
    {
        return (totalCommented/total)*100;
    }


    Utils.getTotal = function()
    {
        return total;
    }

    Utils.getSimpleParameters = function(functionStructure)
    {
        var params = [];
        functionStructure.params.forEach(function(p){
            params.push(p.name);
        });
        return params;

    }

    Utils.paramsToStringRepresentation = function(p)
    {
        if(p.length > 0)
        {
            return " <-- " + p.join(" | ");
        }else{
            return "";
        }
    }

    return {
        UTIL : Utils
    }


})();


module.exports = Documental;