/**
 * Created by ammanvedi on 25/01/2016.
 */

var acorn = require( 'acorn' );
var walk = require( 'walk-ast' );
var modify = require( 'gulp-modify' );
var doctrine = require( "doctrine" );
var fs = require( 'fs' );
var gulp = require( 'gulp' );
var shell = require('gulp-shell');
var browserSync = require('browser-sync').create();
var open = require("openurl");
var runSequence = require('run-sequence');
var marked = require('marked');
var clc = require('cli-color');
var nodeUtil = require('util');
var vftp = require('vinyl-ftp');
var vfs = require('vinyl-fs');
var map = require('map-stream');
var file = require('gulp-file');

marked.setOptions({
	renderer: new marked.Renderer(),
	gfm: true,
	tables: true,
	breaks: false,
	pedantic: false,
	sanitize: true,
	smartLists: true,
	smartypants: false
});

var config;

//attempt to include the config



try {
	config = require( process.cwd() + '/' + 'documental.config.json' );

}catch( e ) {

	console.log( 'ERROR: config could not be loaded' );

}


	var documentalCore = {
		constants: {
			doctrineConfig: {
				unwrap:true,
				recoverable: true,
				sloppy: true
			}
		},
		plugins: {},
		utils: {},
		state: {
			sourceMap: {},
			commentsHash: {},
			typeDefs: {},
			namespaceHash: {},
			autocomplete: [],
			total: 0,
			totalCommented: 0,
			totalAppendedChars: 0,
			nestedFunctionBoundaries: 0,
			currentFunctionBoundaries: 0,
			par: "root",
			docAppPath: "./node_modules/documental/app/dist/data/",
			Tree: {},
			tagConfig: {
				"augments": false, "author": false, "argument": false, "borrows": false, "class": false,
				"constant": false, "constructor": true, "constructs": false, "default": false, "deprecated": true,
				"description": false, "event": false, "example": false, "extends": false, "field": false,
				"fileOverview": false, "function": false, "ignore": false, "inner": false, "lends": false,
				"link": false, "memberOf": false, "name": false, "namespace": false, "param": true, "private": true,
				"property": false, "public": true, "requires": false, "returns": true, "return": true, "see": false,
				"since": false, "static": false, "throws": false, "type": false, "version": false
			}
		}
	};

	var documental = {};

/**
 * Created by ammanvedi on 25/01/2016.
 */

( function( Utils, State, config, acn, wlk ) {

	Utils.ingest = function() {

		if( process.argv.indexOf( "--ftp" ) > -1 ) {
			config.ftpCLI = true;
		}

		State.project = config && config.projectName ? config.projectName : "project";
		process.on('beforeExit', function(){
			if( !Utils.appBuilder.isBuilt() ) {
				Utils.exportDataToJSON();
			}
		});

		Utils.getReadme();

		return modify( {
			fileModifier: function ( file, contents ) {
				return Utils.determineFunctions(file,  contents, acn, wlk );
			}
		} );
	};

} )( documentalCore.utils, documentalCore.state, config, acorn, walk );
/**
 * Created by ammanvedi on 25/01/2016.
 */

( function( Utils, State ) {

	Utils.getSimpleParameters = function ( functionStructure ) {
		var params = [];
		functionStructure.params.forEach( function ( p ) {
			params.push( p.name );
		} );
		return params;

	};

} )( documentalCore.utils, documentalCore.state );

( function( Utils, State ) {

	Utils.paramsToStringRepresentation = function ( p ) {
		if ( p.length > 0 ) {
			return " <-- " + p.join( " | " );
		} else {
			return "";
		}
	}

} )( documentalCore.utils, documentalCore.state );

( function( Utils, State ) {

	Utils.checkMemberOf = function( name, docs ) {

		if( docs && docs.tags ) {

			for( var x = 0; x< docs.tags.length; x++ ) {

				if( docs.tags[ x ].title === "memberof" ) {

					//console.log( name, docs );

					var candidate_name = name.split( '.' );
					if( candidate_name.length ) {
						return docs.tags[ x ].description + "." + name;
					}

				}

			}

		}

		return name;
	};

} )( documentalCore.utils, documentalCore.state );

( function( Utils, State ) {

	Utils.useRulesDetermineNamespace = function( name, docs, start, stop  ) {

		//check if there is a namespace that can be used
		var ns = "";
		var spaces = Object.keys( State.namespaceHash );
		if( spaces.length ) {
			for( var l = 0; l < spaces.length; l++ ) {
				if( State.namespaceHash[ spaces[ l ] ].end !== -1 && State.namespaceHash[ spaces[ l ] ].start < start && State.namespaceHash[ spaces[ l ] ].end > stop ) {
					ns = State.namespaceHash[ spaces[ l ] ].name;
					break;
				} else if( State.namespaceHash[ spaces[ l ] ].end === -1 ) {
					ns = State.namespaceHash[ spaces[ l ] ].name;
					break;
				}
			}
		}

		//console.log( 'func bound is : ', start, ' ', stop, ' chosen ns is  ', ns  );

		//chack if the calculated name uses the namespace already
		if( ns && ns !== "" && name.indexOf( ns ) === -1 ) {

			//does not fully contain, check divergence
			var divergenceIndex = Utils.findIndexOfDifference( name.split( '.' ), ns.split( '.' ) );
			//console.log( divergenceIndex );
			if( divergenceIndex === -1 ) {
				//console.log( 'created namespace : ',  ns + "." + name);
				return ns + "." + name;
			}

			//combine the namepace and the derived name into one
			return Utils.combineNamespacesAtIndex( ns, name, divergenceIndex ).join( '.' );
		}

		return name;
	};

} )( documentalCore.utils, documentalCore.state );

( function( Utils, State ) {

	Utils.autoGenerateDocStub = function ( source, functionNode, functionname ) {

		var augmentedStart = functionNode.start + State.totalAppendedChars;
		var before = source.slice( 0, augmentedStart );
		var after = source.slice( augmentedStart, source.length + 1 );
		var comment = "This Function Needs Documentation \n ";
		var parameter_names = [];
		parameter_names = Utils.getSimpleParameters( functionNode );

		if ( State.totalAppendedChars == 0 && !Utils.hasConstructor( source ) ) {
			comment = "This Function Needs Documentation  \n * @constructor " + functionname + "\n \n ";
		}

		if ( parameter_names.length > 0 ) {
			for ( var x = 0; x < parameter_names.length; x++ ) {
				comment += " * @param " + parameter_names[ x ] + "\n";
			}
		}
		State.totalAppendedChars += comment.length;

		return comment;
	};

} )( documentalCore.utils, documentalCore.state );


( function( Utils, State ) {

	Utils.hasConstructor = function ( source ) {
		return /@constructor|@Constructor/.test( source );
	};

} )( documentalCore.utils, documentalCore.state );

( function( Utils, State ) {

	Utils.findCommentsBetween = function ( startNewFunction, endOldFunction ) {
		var res = -1;

		Object.keys( State.commentsHash ).forEach( function ( commentLine, indexInHash ) {

				if ( parseInt( commentLine ) > endOldFunction && parseInt( commentLine ) < startNewFunction ) {
					var doctext = State.commentsHash[ commentLine ];
					var rexptest = /^[\s]*\/\*\*/.test( doctext );
					if ( rexptest ) {
						var docAST = doctrine.parse( doctext, { unwrap: true } );
						var issues = [];
						if ( docAST.description !== "" ) {
							for ( var i = 0; i < docAST.tags.length; i++ ) {
								if ( State.tagConfig[ docAST.tags[ i ].title ] == undefined ) {
									issues.push( { type: "BAD TAG", info: docAST.tags[ i ].title } );
								}
							}
						} else {
							issues.push( { type: "MISSING", info: "Description" } );
						}
						if ( issues.length > 0 ) {
							res = docAST;
						} else {
							State.totalCommented++;
							res = docAST;
						}
					}
				}
			}
		);
		return res;
	};

} )( documentalCore.utils, documentalCore.state );


( function( Utils, State ) {

	Utils.addToCommentsHash = function ( start, end, txt, namespace, namespaceID, schar, echar ) {
		if( !namespace ) {
			State.commentsHash[ start.toString() ] = {};
			State.commentsHash[ start.toString() ] = txt;
		} else {

			//create a new namespace reference and give it a
			//scope that is identified by its start and end location

			var nspaces = Object.keys( State.namespaceHash );

			if( nspaces.length > 0 ) {

				State.namespaceHash[ nspaces[ nspaces.length - 1 ] ].end = schar;

			}

			State.namespaceHash[ start.toString() ] = {
				name: namespaceID,
				start: schar,
				end: -1
			}
		}

	};

} )( documentalCore.utils, documentalCore.state );

( function( Utils, State ) {

	Utils.checkNamespace = function( docs ) {

		if( docs && docs.tags ) {

			for( var x = 0; x< docs.tags.length; x++ ) {

				if( docs.tags[ x ].title === "namespace" ) {
					return docs.tags[ x ].name ;

				}

			}

		}

		return false;
	};

} )( documentalCore.utils, documentalCore.state );

( function( Utils, State ) {

	Utils.typedefParser = function( text ) {

		var td = doctrine.parse( text, { unwrap: true } );

		if( td ) {
			Utils.addMemberToSourceMap( State.sourceMap, "typedefs." + td.tags[ 0 ].name.replace( " ", "" ), td, text );
			State.autocomplete.push( { n: "typedefs." + td.tags[ 0 ].name.replace( " ", "" ), t: td.tags[ 0 ].name.replace( " ", "" ) } );
		}

	}

} )( documentalCore.utils, documentalCore.state );

( function( Utils, State, Constants ) {

	Utils.commentFunction = function ( block, text, start, end, startloc, endloc ) {
		if ( block ) {
			text = "/*" + text + "*/";

			//namespacing and typedefs should be in their own comments
			//as per standard
			if( text.indexOf( "@namespace" ) >= 0 ) {
				var ns = doctrine.parse( text, Constants.doctrineConfig );
				var desc = Utils.checkNamespace( ns );

				if( desc ) {
					Utils.addToCommentsHash( startloc.line, endloc.line, text, true, desc, start, end  );

				}

				return;
			}

			if( text.indexOf( "@typedef" ) >= 0  ) {

				Utils.typedefParser( text );
				return;
			}

			Utils.addToCommentsHash( startloc.line, endloc.line, text );

		}

	};

} )( documentalCore.utils, documentalCore.state, documentalCore.constants );

( function( Utils, State ) {

	Utils.findComments = function ( location ) {

		var isdoc;

		if ( State.currentFunctionBoundaries ) {
			if ( location.start.line > State.currentFunctionBoundaries.end.line ) {
				isdoc = Utils.findCommentsBetween( location.start.line, State.currentFunctionBoundaries.end.line );
				State.currentFunctionBoundaries = location;
			} else if ( location.start.line < State.currentFunctionBoundaries.end.line ) {
				if ( State.nestedFunctionBoundaries ) {
					isdoc = Utils.findCommentsBetween( location.start.line, State.nestedFunctionBoundaries.end.line );
				} else {
					isdoc = Utils.findCommentsBetween( location.start.line, State.currentFunctionBoundaries.start.line );
				}

				State.nestedFunctionBoundaries = location;
			}

		} else {
			isdoc = Utils.findCommentsBetween( location.start.line, 0 );
			State.currentFunctionBoundaries = location;
		}

		return isdoc;
	};

} )( documentalCore.utils, documentalCore.state );










/**
 * Created by ammanvedi on 25/01/2016.
 */


( function( Utils, State, config ) {

	Utils.exportDataToJSON = function () {

		var outputs = [];

		if( config.jsonOutput ) {
			outputs.push( process.cwd() + '/' + config.jsonOutput  );
		}

		//var outPath = config && config.jsonOutput && !config.useApp ? process.cwd() + '/' + config.jsonOutput  : process.cwd() + '/';
		//var outPath = config && config.jsonOutput && !config.useApp ? process.cwd() + '/' + config.jsonOutput  : State.docAppPath;

		if( config.useApp ) {
			outputs.push( State.docAppPath );
			Utils.appBuilder.build( "./node_modules/documental/app/dist", Utils.getProjectName(), config.port || 3000 );
		}

		var files;

		outputs.map( function( outPath ) {
			files = [
				outPath + Utils.getProjectName() + '-menuTree.json',
				outPath + Utils.getProjectName() + '-sourcemap.json',
				outPath + Utils.getProjectName() + '-autocomplete.json',
				"./node_modules/documental/app/dist/partials/" + config.projectName + "-readmePartial.html"

			];

			fs.writeFileSync( files[ 0 ], Utils.makeMenuTree() );
			fs.writeFileSync( files[ 1 ], Utils.getSourceMap() );
			fs.writeFileSync( files[ 2 ], Utils.getAutocomplete() );
		} );



		Utils.ftp.initiate( files );

	};

} )( documentalCore.utils, documentalCore.state, config );

( function( Utils, State, Config, vftp, fs, map, Gfile ) {


	Utils.ftp = {};

	Utils.ftp.initiate = function( files ) {

		var requiredProps = [ "server", "location", "username", "password" ];

		if( Config.ftp && !Utils.general.checkProperties( Config.ftp, requiredProps ) ) {

			Utils.logStage( "Getting FTP INFO" );

			if( Config.ftpAuto || Config.ftpCLI ) {
				Utils.ftp.upload( files );
			}

		} else {
			Utils.logError( " FTP info specified is invalid" );
		}
	};

	Utils.ftp.upload = function( files, glob ) {

		Utils.logStage( "Uploading to FTP Location.." );

		var conn = new vftp( {
			host: Config.ftp.server,
			user: Config.ftp.username,
			password: Config.ftp.password,
			parallel: 10,
			log: console.log

		} );


		if( files ) {
			fs.src( files.slice( 0, 4 ), { buffer: false } ).pipe( conn.dest( Config.ftp.location ) );
			fs.src( files.slice( 3, 4 ), { buffer: false } ).pipe( conn.dest( Config.ftp.htmlLocation ) );

			Utils.ftp.checkProjectConfig( conn );
		}

		if( glob ) {
			fs.src( glob, { buffer: false } ).pipe( conn.dest( Config.ftp.location ) );
		}


	};

	Utils.ftp.checkProjectConfig = function( connection ) {
		connection.src( Config.ftp.location + "/documental.projects.json" ).pipe( map( function( file, cb ) {

			var projects;

			try {

				projects = JSON.parse( file.contents.toString() );

				Utils.logStage( "Got remote projects config. Updating..." );
				Utils.ftp.updateProjectConfig( connection, projects );


			} catch ( e ) {

				Utils.logError( "Failed parsing remote projects config ! creating fresh config..." );
				Utils.ftp.updateProjectConfig( connection, [] );

			}

			cb( null, file );

		} ) );
	};

	Utils.ftp.updateProjectConfig = function( connection, projects ) {

		var needsUpdate = true;

		try {

			projects.map( function( p ) {
				if( p.projectName === Config.projectName ) {
					Utils.logStage( "Project present in config, no need to update" );
					needsUpdate = false;
				}
			} );

			if( needsUpdate ) {
				projects.push( {
					projectName: Config.projectName
				} );
				Utils.logStage( "Updated Project Config" );

				Gfile('documental.projects.json', JSON.stringify( projects ), { src: true })
					.pipe(gulp.dest('./') )
					.on( "end", function() {
						Utils.ftp.upload( false, [ './documental.projects.json' ] );
					} );

			}



		} catch ( e ) {
			Utils.logError( "Failed updating remote projects config ! creating fresh config..." );
			Utils.ftp.createProjectConfig( connection );
		}


	};

	Utils.ftp.createProjectConfig = function( connection ) {

	}

} )( documentalCore.utils, documentalCore.state, config, vftp, vfs, map, file );


( function( Utils, nodeUtil ) {

	Utils.general = {};

	Utils.general.checkProperties = function( object, properties ) {

		if( object instanceof Object && properties instanceof Array ) {

			var keys = Object.keys( object );

			return properties.filter( function( item ) {

				var contains = keys.indexOf( item );

				return contains === -1;

			} ).length;

		}

		return false;

	};

	Utils.general.getUserYesNo = function( questionString, yesCallback, noCallback ) {

		process.stdin.resume();
		process.stdin.setEncoding('utf8');

		Utils.logInfo( questionString );

		process.stdin.on('data', function (text) {



			text = nodeUtil.inspect(text);
			console.log( text );


			if ( text === '\'y\n\'' || text === '\'yes\n\'' ) {
				console.log( "yescb" );
				if( yesCallback && typeof yesCallback === "function"  ) {
					console.log( "yescb" );
					yesCallback();
				}
			}

			if ( text === 'n\n' || text === 'no\n' ) {
				if( noCallback && typeof noCallback === "function" ) {
					noCallback();
				}
			}
		});

	}


} )( documentalCore.utils, nodeUtil );
/**
 * Created by ammanvedi on 30/01/2016.
 */
( function( Utils, color ) {

	var error = color.red;
	var warn = color.yellow;
	var notice = color.greenBright;
	var stage = color.cyanBright;
	var doctext = color.cyan;


	Utils.logStage = function( string ) {
		console.log( doctext('documental' + stage(" " + string ) ) );
	};


	Utils.logError = function( string ) {
		console.log( doctext('documental' + error(" " + string ) ) );
	};


	Utils.logInfo = function( string ) {
		console.log( doctext('documental' + notice(" " + string ) ) );
	};



} )( documentalCore.utils, clc );


( function( Utils, State, config, fs, mkd ) {



	Utils.getReadme = function() {
		var _self = this;

		Utils.logStage( 'Getting readme' );
		if( config && config.readme ) {
			fs.readFile( config.readme, 'utf8', function( e, d ) {
				if( !e ) {
					Utils.logInfo( 'Got readme' );
					Utils.parseReadme( d );

				} else {
					Utils.logError( "Couldnt get readme " );
					Utils.generateReadme();
				}

			});
		}
	};


	Utils.parseReadme = function( data ) {

		try{

			var md = mkd( data );
			Utils.writeReadme( md );

		}catch ( e ) {
			Utils.logError( "Readme Helper : couldnt parse markdown from " + config.readme );
			Utils.generateReadme();
		}
	};

	Utils.writeReadme = function( html ) {

		Utils.logStage( 'Writing readme' );
		var path = "./node_modules/documental/app/dist/partials/" + config.projectName + "-readmePartial.html";

		fs.writeFile( path, html, "utf8", function( err ) {
			if( err ) {
				Utils.logError( "Readme Helper : couldn't place file " +  path );
				Utils.generateReadme();
			} else {
				Utils.logInfo( "wrote readme as html" );
			}

		});

	};

	Utils.generateReadme = function() {

		Utils.logError( 'Generating placeholder readme ' );

	};


} )( documentalCore.utils, documentalCore.state, config, fs, marked );
/**
 * Created by ammanvedi on 25/01/2016.
 */

( function( Utils, State ) {

	Utils.clearCommentCache = function () {
		State.commentsHash = {};
		State.namespaceHash = {};
		State.totalAppendedChars = 0;
	};

} )( documentalCore.utils, documentalCore.state );


( function( Utils, State ) {

	Utils.addMemberToSourceMap = function ( updatemap, name, docu, src ) {
		var memberpath = name.split( "." );
		var islast = false;

		for ( i = 0; i < memberpath.length; i++ ) {
			if ( updatemap[ memberpath[ i ] ] == undefined ) {
				updatemap[ memberpath[ i ] ] = {}
			}
			updatemap = updatemap[ memberpath[ i ] ];
		}
		updatemap[ "Documentation" ] = docu;
		if ( src ) {
			updatemap[ "Source" ] = src;
		}

	};

} )( documentalCore.utils, documentalCore.state );


( function( Utils, State ) {

	Utils.getSourceMap = function () {
		return JSON.stringify( State.sourceMap );
	};

} )( documentalCore.utils, documentalCore.state );

( function( Utils, State ) {

	Utils.getProjectName = function () {
		return State.project;
	};

} )( documentalCore.utils, documentalCore.state );

( function( Utils, State ) {

	Utils.getAutocomplete = function () {
		return JSON.stringify( State.autocomplete );
	};

} )( documentalCore.utils, documentalCore.state );

( function( Utils, State ) {

	Utils.getPercentDocumented = function () {
		return ( State.totalCommented / State.total) * 100;
	};

} )( documentalCore.utils, documentalCore.state );

( function( Utils, State ) {

	Utils.getTotal = function () {
		return State.total;
	};

} )( documentalCore.utils, documentalCore.state );
















/**
 * Created by ammanvedi on 25/01/2016.
 */

( function( Utils, State ) {

	Utils.cleanName = function ( name ) {
		if ( name.charAt( 0 ) === "." ) {
			return name.substring( 1 );
		}
	};

} )( documentalCore.utils, documentalCore.state );

( function( Utils, State ) {

	Utils.combineNamespacesAtIndex = function( a, b, idx ) {

		a = a.split( '.' );
		b = b.split( '.' );
		var comb = Array.prototype.concat( a.splice( 0, idx ), b.splice( idx, b.length ) );
		//console.log( a, b, idx );
		//console.log( comb.join( "." ) );

		return comb;

	};

} )( documentalCore.utils, documentalCore.state );

( function( Utils, State ) {

	Utils.findIndexOfDifference = function( a, b ) {

		//given two arrays check at which index do they
		//diverge into non-directly matching arrays

		var index = -1;
		//only iterate as fara as the smallest array
		var smallestLength = a.length <= b.length ? a.length : b.length;

		for( var c = 0; c < smallestLength; c++  ) {
			if( a[ c ] === b[ c ] ) {
				index ++;
			} else {
				return index;
			}
		}

		return index;

	};

} )( documentalCore.utils, documentalCore.state );
/**
 * Created by ammanvedi on 25/01/2016.
 */

( function( Utils, State, cfg ) {

	Utils.recurseMenuTree = function ( sourceObject, tree, nodename, menu, workingpath ) {

		var noden = nodename || State.project;
		tree = tree || " ";

		if( cfg.verbose ) {
			console.log( tree + noden );
		}

		menu.text = noden;

		if ( menu.text === State.project ) {
			menu.isExpanded = "true";
		}

		if ( menu.children ) {

		} else {
			menu.children = [];
		}

		if ( typeof sourceObject === "object" && sourceObject !== null && !sourceObject[ "description" ] ) {
			//console.log(sourceObject);
			var keys = Object.keys( sourceObject );
			tree = tree + " ";
			var ct = 0;


			if ( noden === State.project ) {
				workingpath = "";
			} else {
				if ( workingpath === "" ) {
					workingpath = noden;
				} else {
					workingpath = workingpath + "." + noden;
				}

			}

			for ( var x = 0; x < keys.length; x++ ) {
				if ( keys[ x ] === 'Documentation' || keys[ x ] === 'Source' ) {

					ct++;
					continue;
				}
				if ( noden !== "Documentation" && keys[ x ] !== 'Documentation' ) {

					var augpath;
					if ( workingpath === "" ) {
						augpath = keys[ x ];
					} else {
						augpath = workingpath + "." + keys[ x ];
					}
					menu.children[ x - ct ] = {
						text: noden,
						children: [],
						path: augpath
					};

					Utils.recurseMenuTree( sourceObject[ keys[ x ] ], tree, keys[ x ], menu.children[ x - ct ], workingpath );
				}

			}
		}

	};

} )( documentalCore.utils, documentalCore.state, config );

( function( Utils, State ) {

	Utils.makeMenuTree = function () {
		Utils.recurseMenuTree( State.sourceMap, "", "", State.Tree, "" );
		return JSON.stringify( [ State.Tree ] );
	};

} )( documentalCore.utils, documentalCore.state );

( function( Utils, State ) {

	Utils.makeMenuTree = function () {
		Utils.recurseMenuTree( State.sourceMap, "", "", State.Tree, "" );
		return JSON.stringify( [ State.Tree ] );
	};

} )( documentalCore.utils, documentalCore.state );

( function( Utils, State ) {

	Utils.recurseUpTree = function ( node ) {

		if ( node.parentNode.type == "AssignmentExpression" ) {
			return Utils.recurseUpTree( node.parentNode ) + "." + Utils.postOrderTraverse( node.parentNode.left );
		}
		if ( node.parentNode.type == "VariableDeclaration" ) {
			return Utils.recurseUpTree( node.parentNode ) + "." + node.parentNode.declarations[ 0 ].id.name;
		}
		if ( node.parentNode ) {
			return Utils.recurseUpTree( node.parentNode );
		} else {
			return "";
		}
	};
} )( documentalCore.utils, documentalCore.state );

( function( Utils, State ) {

	Utils.postOrderTraverse = function ( node ) {

		if ( node.name ) {
			return node.name || node.property.name;
		} else {

			switch( node.type ) {
				case 'ThisExpression':
					return "this";
					break;
				case "Literal":
					return "[ LITERAL ]";
					break;
				case "CallExpression":
					return Utils.postOrderTraverse( node.callee.object ) + "." + Utils.postOrderTraverse( node.callee.property );
				default:
					return Utils.postOrderTraverse( node.object ) + "." + Utils.postOrderTraverse( node.property );
					break;
			}


		}
	};
} )( documentalCore.utils, documentalCore.state );



























/**
 * Created by ammanvedi on 25/01/2016.
 */


( function( Utils, State, cfg) {

	Utils.appBuilder = ( function( g, shell, bs, opn, rs ) {

		var builder = {};

		var built = false;


		builder.build = function( serverRoot, projectName, port ) {

			g.task( 'bower-install', shell.task( 'bower install', { cwd: "./node_modules/documental/app" } ));

			g.task( 'make-browser', function() {

				bs.init({ server: {
					baseDir: serverRoot
					},
					open : false,
					port: port
				});

			} );

			g.task("open-site", function(){
				var options = {
					url: "http://localhost:" + port + "/#/docs/" + projectName,
					app: "chrome"
				};
				Utils.logStage( "App launched..." );
				Utils.logInfo( 'opening...' );
				opn.open( options.url );
			});


			g.task( 'build-site', function() {

				Utils.logStage( "Running app build tasks" );
				rs('bower-install', 'make-browser', 'open-site' );


			} );

			g.start( 'build-site' );
			built = true;
		};

		builder.isBuilt = function() {
			return built;
		};

		return builder;

	} )( gulp, shell, browserSync, open, runSequence );

} )( documentalCore.utils, documentalCore.state, config );
/**
 * Created by ammanvedi on 25/01/2016.
 */

( function( Plugins, Utils, State ) {

	Plugins.expressionStatement = function( node ) {

		var sourceStart, sourceStop, rightside, terminal, name;
		var foundApplicableFunction = false;

		if ( node.type == 'ExpressionStatement' ) {

			if ( node.expression && node.expression.left && node.expression.right && node.expression.left.type == 'MemberExpression'
				&& (node.expression.right.type == 'FunctionExpression' || node.expression.right.type == "CallExpression" ) ) {

				rightside = node.expression.right;
				if ( node.expression.right.type == "CallExpression" ) {
					rightside = node.expression.right.callee
				}
				sourceStart = node.expression.left.start;
				sourceStop = rightside.end;
				if ( rightside.type == "FunctionExpression" ) {

					try{
						name = Utils.postOrderTraverse( node.expression.left );
					} catch( e ) {
						console.log( node.expression.left );
					}

					prefix = Utils.cleanName( Utils.recurseUpTree( node ) );
					if ( prefix ) {
						name = Utils.cleanName( Utils.recurseUpTree( node ) ) + "." + name;
					}
					terminal = name.split( '.' )[ name.split( '.' ).length - 1 ];
					foundApplicableFunction = true;
				}

			}
		}



		if( foundApplicableFunction ) {
			return {
				"sourceStart": sourceStart,
				"sourceStop" : sourceStop,
				"rightside" : rightside,
				"terminal" : terminal,
				"name" : name
			}
		}

		return false;
	}

} )( documentalCore.plugins, documentalCore.utils, documentalCore.state );
/**
 * Created by ammanvedi on 25/01/2016.
 */


( function( Plugins, Utils, State ) {

	Plugins.functionDeclaration = function( node ) {

		var sourceStart, sourceStop, rightside, terminal, name;
		var foundApplicableFunction = false;

		if ( node.type == 'FunctionDeclaration' ) {
			rightside = node;
			sourceStart = node.start;
			sourceStop = node.end;
			terminal = node.id.name;
			name = node.id.name;
			foundApplicableFunction = true;
		}

		if( foundApplicableFunction ) {
			return {
				"sourceStart": sourceStart,
				"sourceStop" : sourceStop,
				"rightside" : rightside,
				"terminal" : terminal,
				"name" : name
			}
		}

		return false;
	}

} )( documentalCore.plugins, documentalCore.utils, documentalCore.state );


/**
 * Created by ammanvedi on 25/01/2016.
 */


( function( Plugins, Utils, State ) {

	Plugins.variableDeclaration = function( node ) {

		var sourceStart, sourceStop, rightside, terminal, name;
		var foundApplicableFunction = false;

		if ( node.type == 'VariableDeclaration' ) {
			node.declarations.forEach( function ( declaration, declIndex ) {
				if ( declaration.init && declaration.init.type == 'FunctionExpression' ) {

					rightside = declaration.init;
					sourceStart = node.start;
					sourceStop = declaration.init.end;
					name = Utils.cleanName( Utils.recurseUpTree( node ) );

					if ( !name ) {
						name = declaration.id.name;
					} else {
						name += "." + declaration.id.name
					}

					terminal = name.split( '.' )[ name.split( '.' ).length - 1 ];

					foundApplicableFunction = true;
				}
			} )
		}


		if( foundApplicableFunction ) {
			return {
				"sourceStart": sourceStart,
				"sourceStop" : sourceStop,
				"rightside" : rightside,
				"terminal" : terminal,
				"name" : name
			}
		}

		return false;
	}

} )( documentalCore.plugins, documentalCore.utils, documentalCore.state );

/**
 * Created by ammanvedi on 25/01/2016.
 */


( function( Plugins, Utils, State, Constants ) {

	Utils.determineFunctions = function ( file,  sourceString, acornInstance, walk ) {


		var methodCount = 0;
		var ast;
		var pluginNames = Object.keys( Plugins );

		State.currentFunctionBoundaries = 0;


		try {
			ast = acornInstance.parse( sourceString, {
				locations: true,
				ranges: true,
				directSourceFile: true,
				onComment: Utils.commentFunction
			} );

			walk( ast, function ( node ) {

				//get Plugins
				for( x = 0; x < pluginNames.length; x++ ) {
					var pluginResult = Plugins[ pluginNames[ x ] ]( node );

					if( pluginResult ) {
						var body = sourceString.substring( pluginResult.sourceStart, pluginResult.sourceStop );
						var par = Utils.paramsToStringRepresentation( Utils.getSimpleParameters( pluginResult.rightside ) );
						methodCount++;
						var doc = Utils.findComments( pluginResult.rightside.loc );
						if ( doc == -1 ) {
							//console.log( 'method : ', name, ' not documented'  );
							var newdocstring = Utils.autoGenerateDocStub( sourceString, pluginResult.rightside, pluginResult.name );
							doc = doctrine.parse( newdocstring, Constants.doctrineConfig );
						}

						pluginResult.name = Utils.useRulesDetermineNamespace( pluginResult.name, doc, pluginResult.sourceStart, pluginResult.sourceStop );
						//console.log( pluginResult.name );

						Utils.addMemberToSourceMap( State.sourceMap, pluginResult.name, doc, body );
						State.autocomplete.push( { n: pluginResult.name, t: pluginResult.terminal } );
						break;
					}
				}

			} );

		}catch( e ) {
			Utils.logError( 'source parsing failed on file ' + file.path );
			Utils.logError( 'message -  ' + e.toString() );
		}


		State.total += methodCount;
		Utils.clearCommentCache();
		return sourceString;
	};

} )( documentalCore.plugins, documentalCore.utils, documentalCore.state, documentalCore.constants );
/**
 * Created by ammanvedi on 25/01/2016.
 */

module.exports = documentalCore.utils.ingest;
