/**
 * Created by ammanvedi on 25/01/2016.
 */


var acorn = require( 'acorn' );
var walk = require( 'walk-ast' );
var modify = require( 'gulp-modify' );
var doctrine = require( "doctrine" );
var fs = require( 'fs' );
var gulp = require( 'gulp' );
var shell = require('gulp-shell');
var browserSync = require('browser-sync').create();
var open = require("openurl");
var runSequence = require('run-sequence');
var config;

//attempt to include the config
try {
	config = require( process.cwd() + '/' + 'documental.config.json' );
}catch( e ) {
	console.log( 'INFO: no config supplied' );
}


	var documentalCore = {
		plugins: {},
		utils: {},
		state: {
			sourceMap: {},
			commentsHash: {},
			namespaceHash: {},
			autocomplete: [],
			total: 0,
			totalCommented: 0,
			totalAppendedChars: 0,
			nestedFunctionBoundaries: 0,
			currentFunctionBoundaries: 0,
			par: "root",
			docAppPath: "./node_modules/documental/app/dist/data/",
			Tree: {},
			tagConfig: {
				"augments": false, "author": false, "argument": false, "borrows": false, "class": false,
				"constant": false, "constructor": true, "constructs": false, "default": false, "deprecated": true,
				"description": false, "event": false, "example": false, "extends": false, "field": false,
				"fileOverview": false, "function": false, "ignore": false, "inner": false, "lends": false,
				"link": false, "memberOf": false, "name": false, "namespace": false, "param": true, "private": true,
				"property": false, "public": true, "requires": false, "returns": true, "return": true, "see": false,
				"since": false, "static": false, "throws": false, "type": false, "version": false
			}
		}
	};

	var documental = {};

/**
 * Created by ammanvedi on 25/01/2016.
 */

( function( Utils, State, config ) {

	Utils.ingest = function() {

		State.project = config && config.projectName ? config.projectName : "project";
		process.on('beforeExit', function(){
			if( !Utils.appBuilder.isBuilt() ) {
				Utils.exportDataToJSON();
			}
		});

		return modify( {
			fileModifier: function ( file, contents ) {
				return Utils.determineFunctions(file,  contents, acorn, walk );
			}
		} );
	};

} )( documentalCore.utils, documentalCore.state, config );
/**
 * Created by ammanvedi on 25/01/2016.
 */

( function( Utils, State ) {

	Utils.getSimpleParameters = function ( functionStructure ) {
		var params = [];
		functionStructure.params.forEach( function ( p ) {
			params.push( p.name );
		} );
		return params;

	};

} )( documentalCore.utils, documentalCore.state );

( function( Utils, State ) {

	Utils.paramsToStringRepresentation = function ( p ) {
		if ( p.length > 0 ) {
			return " <-- " + p.join( " | " );
		} else {
			return "";
		}
	}

} )( documentalCore.utils, documentalCore.state );

( function( Utils, State ) {

	Utils.checkMemberOf = function( name, docs ) {

		if( docs && docs.tags ) {

			for( var x = 0; x< docs.tags.length; x++ ) {

				if( docs.tags[ x ].title === "memberof" ) {

					//console.log( name, docs );

					var candidate_name = name.split( '.' );
					if( candidate_name.length ) {
						return docs.tags[ x ].description + "." + name;
					}

				}

			}

		}

		return name;
	};

} )( documentalCore.utils, documentalCore.state );

( function( Utils, State ) {

	Utils.useRulesDetermineNamespace = function( name, docs, start, stop  ) {

		//check if there is a namespace that can be used
		var ns = "";
		var spaces = Object.keys( State.namespaceHash );
		if( spaces.length ) {
			for( var l = 0; l < spaces.length; l++ ) {
				if( State.namespaceHash[ spaces[ l ] ].end !== -1 && State.namespaceHash[ spaces[ l ] ].start < start && State.namespaceHash[ spaces[ l ] ].end > stop ) {
					ns = State.namespaceHash[ spaces[ l ] ].name;
					break;
				} else if( State.namespaceHash[ spaces[ l ] ].end === -1 ) {
					ns = State.namespaceHash[ spaces[ l ] ].name;
					break;
				}
			}
		}

		//console.log( 'func bound is : ', start, ' ', stop, ' chosen ns is  ', ns  );

		//chack if the calculated name uses the namespace already
		if( ns && ns !== "" && name.indexOf( ns ) === -1 ) {

			//does not fully contain, check divergence
			var divergenceIndex = Utils.findIndexOfDifference( name.split( '.' ), ns.split( '.' ) );
			console.log( divergenceIndex );
			if( divergenceIndex === -1 ) {
				//console.log( 'created namespace : ',  ns + "." + name);
				return ns + "." + name;
			}

			//combine the namepace and the derived name into one
			return Utils.combineNamespacesAtIndex( ns, name, divergenceIndex ).join( '.' );
		}

		return name;
	};

} )( documentalCore.utils, documentalCore.state );

( function( Utils, State ) {

	Utils.autoGenerateDocStub = function ( source, functionNode, functionname ) {

		var augmentedStart = functionNode.start + State.totalAppendedChars;
		var before = source.slice( 0, augmentedStart );
		var after = source.slice( augmentedStart, source.length + 1 );
		var comment = "This Function Needs Documentation \n ";
		var parameter_names = [];
		parameter_names = Utils.getSimpleParameters( functionNode );

		if ( State.totalAppendedChars == 0 && !Utils.hasConstructor( source ) ) {
			comment = "This Function Needs Documentation  \n * @constructor " + functionname + "\n \n ";
		}

		if ( parameter_names.length > 0 ) {
			for ( var x = 0; x < parameter_names.length; x++ ) {
				comment += " * @param " + parameter_names[ x ] + "\n";
			}
		}
		State.totalAppendedChars += comment.length;

		return comment;
	};

} )( documentalCore.utils, documentalCore.state );


( function( Utils, State ) {

	Utils.hasConstructor = function ( source ) {
		return /@constructor|@Constructor/.test( source );
	};

} )( documentalCore.utils, documentalCore.state );

( function( Utils, State ) {

	Utils.findCommentsBetween = function ( startNewFunction, endOldFunction ) {
		var res = -1;

		Object.keys( State.commentsHash ).forEach( function ( commentLine, indexInHash ) {

				if ( parseInt( commentLine ) > endOldFunction && parseInt( commentLine ) < startNewFunction ) {
					var doctext = State.commentsHash[ commentLine ];
					var rexptest = /^[\s]*\/\*\*/.test( doctext );
					if ( rexptest ) {
						var docAST = doctrine.parse( doctext, { unwrap: true } );
						var issues = [];
						if ( docAST.description !== "" ) {
							for ( var i = 0; i < docAST.tags.length; i++ ) {
								if ( State.tagConfig[ docAST.tags[ i ].title ] == undefined ) {
									issues.push( { type: "BAD TAG", info: docAST.tags[ i ].title } );
								}
							}
						} else {
							issues.push( { type: "MISSING", info: "Description" } );
						}
						if ( issues.length > 0 ) {
							res = docAST;
						} else {
							State.totalCommented++;
							res = docAST;
						}
					}
				}
			}
		);
		return res;
	};

} )( documentalCore.utils, documentalCore.state );


( function( Utils, State ) {

	Utils.addToCommentsHash = function ( start, end, txt, namespace, namespaceID, schar, echar ) {
		if( !namespace ) {
			State.commentsHash[ start.toString() ] = {};
			State.commentsHash[ start.toString() ] = txt;
		} else {

			//create a new namespace reference and give it a
			//scope that is identified by its start and end location

			var nspaces = Object.keys( State.namespaceHash );

			if( nspaces.length > 0 ) {

				State.namespaceHash[ nspaces[ nspaces.length - 1 ] ].end = schar;

			}

			State.namespaceHash[ start.toString() ] = {
				name: namespaceID,
				start: schar,
				end: -1
			}
		}

	};

} )( documentalCore.utils, documentalCore.state );

( function( Utils, State ) {

	Utils.checkNamespace = function( docs ) {

		if( docs && docs.tags ) {

			for( var x = 0; x< docs.tags.length; x++ ) {

				if( docs.tags[ x ].title === "namespace" ) {
					return docs.tags[ x ].name ;

				}

			}

		}

		return false;
	};

} )( documentalCore.utils, documentalCore.state );

( function( Utils, State ) {

	Utils.commentFunction = function ( block, text, start, end, startloc, endloc ) {
		if ( block ) {
			text = "/*" + text + "*/";

			if( text.indexOf( "@namespace" ) === -1 ) {
				Utils.addToCommentsHash( startloc.line, endloc.line, text );
			} else {

				var ns = doctrine.parse( text, { unwrap: true } )
				var desc = Utils.checkNamespace( ns );

				if( desc ) {
					Utils.addToCommentsHash( startloc.line, endloc.line, text, true, desc, start, end  );

				}
			}
		}

	};

} )( documentalCore.utils, documentalCore.state );

( function( Utils, State ) {

	Utils.findComments = function ( location ) {

		var isdoc;

		if ( State.currentFunctionBoundaries ) {
			if ( location.start.line > State.currentFunctionBoundaries.end.line ) {
				isdoc = Utils.findCommentsBetween( location.start.line, State.currentFunctionBoundaries.end.line );
				State.currentFunctionBoundaries = location;
			} else if ( location.start.line < State.currentFunctionBoundaries.end.line ) {
				if ( State.nestedFunctionBoundaries ) {
					isdoc = Utils.findCommentsBetween( location.start.line, State.nestedFunctionBoundaries.end.line );
				} else {
					isdoc = Utils.findCommentsBetween( location.start.line, State.currentFunctionBoundaries.start.line );
				}

				State.nestedFunctionBoundaries = location;
			}

		} else {
			isdoc = Utils.findCommentsBetween( location.start.line, 0 );
			State.currentFunctionBoundaries = location;
		}

		return isdoc;
	};

} )( documentalCore.utils, documentalCore.state );










/**
 * Created by ammanvedi on 25/01/2016.
 */


( function( Utils, State, config ) {

	Utils.exportDataToJSON = function () {

		//var outPath = config && config.jsonOutput && !config.useApp ? process.cwd() + '/' + config.jsonOutput  : process.cwd() + '/';
		var outPath = config && config.jsonOutput && !config.useApp ? process.cwd() + '/' + config.jsonOutput  : State.docAppPath;

		if( config.useApp ) {
			Utils.appBuilder.build( "./node_modules/documental/app/dist", Utils.getProjectName(), config.port || 3000 );
		}

		fs.writeFileSync( outPath + Utils.getProjectName() + '-menuTree.json', Utils.makeMenuTree() );
		fs.writeFileSync( outPath + Utils.getProjectName() + '-sourcemap.json', Utils.getSourceMap() );
		fs.writeFileSync( outPath + Utils.getProjectName() + '-autocomplete.json', Utils.getAutocomplete() );
	};

} )( documentalCore.utils, documentalCore.state, config );
/**
 * Created by ammanvedi on 25/01/2016.
 */

( function( Utils, State ) {

	Utils.clearCommentCache = function () {
		State.commentsHash = {};
		State.namespaceHash = {};
		State.totalAppendedChars = 0;
	};

} )( documentalCore.utils, documentalCore.state );


( function( Utils, State ) {

	Utils.addMemberToSourceMap = function ( updatemap, name, docu, src ) {
		var memberpath = name.split( "." );
		var islast = false;

		for ( i = 0; i < memberpath.length; i++ ) {
			if ( updatemap[ memberpath[ i ] ] == undefined ) {
				updatemap[ memberpath[ i ] ] = {}
			}
			updatemap = updatemap[ memberpath[ i ] ];
		}
		updatemap[ "Documentation" ] = docu;
		if ( src ) {
			updatemap[ "Source" ] = src;
		}

	};

} )( documentalCore.utils, documentalCore.state );


( function( Utils, State ) {

	Utils.getSourceMap = function () {
		return JSON.stringify( State.sourceMap );
	};

} )( documentalCore.utils, documentalCore.state );

( function( Utils, State ) {

	Utils.getProjectName = function () {
		return State.project;
	};

} )( documentalCore.utils, documentalCore.state );

( function( Utils, State ) {

	Utils.getAutocomplete = function () {
		return JSON.stringify( State.autocomplete );
	};

} )( documentalCore.utils, documentalCore.state );

( function( Utils, State ) {

	Utils.getPercentDocumented = function () {
		return ( State.totalCommented / State.total) * 100;
	};

} )( documentalCore.utils, documentalCore.state );

( function( Utils, State ) {

	Utils.getTotal = function () {
		return State.total;
	};

} )( documentalCore.utils, documentalCore.state );
















/**
 * Created by ammanvedi on 25/01/2016.
 */

( function( Utils, State ) {

	Utils.cleanName = function ( name ) {
		if ( name.charAt( 0 ) === "." ) {
			return name.substring( 1 );
		}
	};

} )( documentalCore.utils, documentalCore.state );

( function( Utils, State ) {

	Utils.combineNamespacesAtIndex = function( a, b, idx ) {

		a = a.split( '.' );
		b = b.split( '.' );
		var comb = Array.prototype.concat( a.splice( 0, idx ), b.splice( idx, b.length ) )
		console.log( a, b, idx );
		console.log( comb.join( "." ) );

		return comb;

	};

} )( documentalCore.utils, documentalCore.state );

( function( Utils, State ) {

	Utils.findIndexOfDifference = function( a, b ) {

		//given two arrays check at which index do they
		//diverge into non-directly matching arrays

		var index = -1;
		//only iterate as fara as the smallest array
		var smallestLength = a.length <= b.length ? a.length : b.length;

		for( var c = 0; c < smallestLength; c++  ) {
			if( a[ c ] === b[ c ] ) {
				index ++;
			} else {
				return index;
			}
		}

		return index;

	};

} )( documentalCore.utils, documentalCore.state );
/**
 * Created by ammanvedi on 25/01/2016.
 */

( function( Utils, State ) {

	Utils.recurseMenuTree = function ( sourceObject, tree, nodename, menu, workingpath ) {

		var noden = nodename || State.project;
		tree = tree || " ";

		console.log( tree + noden );
		menu.text = noden;

		if ( menu.text === State.project ) {
			menu.isExpanded = "true";
		}

		if ( menu.children ) {

		} else {
			menu.children = [];
		}

		if ( typeof sourceObject === "object" && sourceObject !== null && !sourceObject[ "description" ] ) {
			//console.log(sourceObject);
			var keys = Object.keys( sourceObject );
			tree = tree + " ";
			var ct = 0;


			if ( noden === State.project ) {
				workingpath = "";
			} else {
				if ( workingpath === "" ) {
					workingpath = noden;
				} else {
					workingpath = workingpath + "." + noden;
				}

			}

			for ( var x = 0; x < keys.length; x++ ) {
				if ( keys[ x ] === 'Documentation' || keys[ x ] === 'Source' ) {

					ct++;
					continue;
				}
				if ( noden !== "Documentation" && keys[ x ] !== 'Documentation' ) {

					var augpath;
					if ( workingpath === "" ) {
						augpath = keys[ x ];
					} else {
						augpath = workingpath + "." + keys[ x ];
					}
					menu.children[ x - ct ] = {
						text: noden,
						children: [],
						path: augpath
					};

					Utils.recurseMenuTree( sourceObject[ keys[ x ] ], tree, keys[ x ], menu.children[ x - ct ], workingpath );
				}

			}
		}

	};

} )( documentalCore.utils, documentalCore.state );

( function( Utils, State ) {

	Utils.makeMenuTree = function () {
		Utils.recurseMenuTree( State.sourceMap, "", "", State.Tree, "" );
		return JSON.stringify( [ State.Tree ] );
	};

} )( documentalCore.utils, documentalCore.state );

( function( Utils, State ) {

	Utils.makeMenuTree = function () {
		Utils.recurseMenuTree( State.sourceMap, "", "", State.Tree, "" );
		return JSON.stringify( [ State.Tree ] );
	};

} )( documentalCore.utils, documentalCore.state );

( function( Utils, State ) {

	Utils.recurseUpTree = function ( node ) {

		if ( node.parentNode.type == "AssignmentExpression" ) {
			return Utils.recurseUpTree( node.parentNode ) + "." + Utils.postOrderTraverse( node.parentNode.left );
		}
		if ( node.parentNode.type == "VariableDeclaration" ) {
			return Utils.recurseUpTree( node.parentNode ) + "." + node.parentNode.declarations[ 0 ].id.name;
		}
		if ( node.parentNode ) {
			return Utils.recurseUpTree( node.parentNode );
		} else {
			return "";
		}
	};
} )( documentalCore.utils, documentalCore.state );

( function( Utils, State ) {

	Utils.postOrderTraverse = function ( node ) {

		if ( node.name ) {
			return node.name;
		} else {
			if ( node.type == 'ThisExpression' ) {
				return "this";
			} else if ( node.type == "Literal" ) {
				return "[ LITERAL ]";
			} else {
				return Utils.postOrderTraverse( node.object ) + "." + Utils.postOrderTraverse( node.property );
			}

		}
	};
} )( documentalCore.utils, documentalCore.state );



























/**
 * Created by ammanvedi on 25/01/2016.
 */


( function( Utils, State ) {

	Utils.appBuilder = ( function( g, shell, bs, opn, rs ) {

		var builder = {};

		var built = false;


		builder.build = function( serverRoot, projectName, port ) {

			g.task( 'bower-install', shell.task( 'bower install', { cwd: "./node_modules/documental/app" } ));

			g.task( 'make-browser', function() {
				bs.init({ server: {
					baseDir: serverRoot,
					open: false },
					open : false});
			} );

			g.task("open-site", function(){
				var options = {
					url: "http://localhost:" + port + "/#/docs/" + projectName,
					app: "chrome"
				};
				console.log( 'opening...' );
				opn.open( options.url );
			});


			g.task( 'build-site', function() {

				rs('bower-install', 'make-browser', 'open-site' );

			} );

			g.start( 'build-site' );
			built = true;
		};

		builder.isBuilt = function() {
			return built;
		};

		return builder;

	} )( gulp, shell, browserSync, open, runSequence );

} )( documentalCore.utils, documentalCore.state );
/**
 * Created by ammanvedi on 25/01/2016.
 */

( function( Plugins, Utils, State ) {

	Plugins.expressionStatement = function( node ) {

		var sourceStart, sourceStop, rightside, terminal, name;
		var foundApplicableFunction = false;

		if ( node.type == 'ExpressionStatement' ) {

			if ( node.expression && node.expression.left && node.expression.right && node.expression.left.type == 'MemberExpression'
				&& (node.expression.right.type == 'FunctionExpression' || node.expression.right.type == "CallExpression" ) ) {

				rightside = node.expression.right;
				if ( node.expression.right.type == "CallExpression" ) {
					rightside = node.expression.right.callee
				}
				sourceStart = node.expression.left.start;
				sourceStop = rightside.end;
				if ( rightside.type == "FunctionExpression" ) {
					name = Utils.postOrderTraverse( node.expression.left );
					prefix = Utils.cleanName( Utils.recurseUpTree( node ) );
					if ( prefix ) {
						name = Utils.cleanName( Utils.recurseUpTree( node ) ) + "." + name;
					}
					terminal = name.split( '.' )[ name.split( '.' ).length - 1 ];
					foundApplicableFunction = true;
				}

			}
		}

		if( foundApplicableFunction ) {
			return {
				"sourceStart": sourceStart,
				"sourceStop" : sourceStop,
				"rightside" : rightside,
				"terminal" : terminal,
				"name" : name
			}
		}

		return false;
	}

} )( documentalCore.plugins, documentalCore.utils, documentalCore.state );
/**
 * Created by ammanvedi on 25/01/2016.
 */


( function( Plugins, Utils, State ) {

	Plugins.functionDeclaration = function( node ) {

		var sourceStart, sourceStop, rightside, terminal, name;
		var foundApplicableFunction = false;

		if ( node.type == 'FunctionDeclaration' ) {
			rightside = node;
			sourceStart = node.start;
			sourceStop = node.end;
			terminal = node.id.name;
			name = node.id.name;
			foundApplicableFunction = true;
		}

		if( foundApplicableFunction ) {
			return {
				"sourceStart": sourceStart,
				"sourceStop" : sourceStop,
				"rightside" : rightside,
				"terminal" : terminal,
				"name" : name
			}
		}

		return false;
	}

} )( documentalCore.plugins, documentalCore.utils, documentalCore.state );

/*

( function( Plugins, Utils, State ) {

	Plugins.pluginName = function( node ) {

		var sourceStart, sourceStop, rightside, terminal, name;
		var foundApplicableFunction = false;

		//plugin code here

		// ....


		if( foundApplicableFunction ) {
			return {
				"sourceStart": sourceStart,
				"sourceStop" : sourceStop,
				"rightside" : rightside,
				"terminal" : terminal,
				"name" : name
			}
		}

		return false;
	}

} )( documentalCore.plugins, documentalCore.utils, documentalCore.state );

*/
/**
 * Created by ammanvedi on 25/01/2016.
 */


( function( Plugins, Utils, State ) {

	Plugins.variableDeclaration = function( node ) {

		var sourceStart, sourceStop, rightside, terminal, name;
		var foundApplicableFunction = false;

		if ( node.type == 'VariableDeclaration' ) {
			node.declarations.forEach( function ( declaration, declIndex ) {
				if ( declaration.init && declaration.init.type == 'FunctionExpression' ) {

					rightside = declaration.init;
					sourceStart = node.start;
					sourceStop = declaration.init.end;
					name = Utils.cleanName( Utils.recurseUpTree( node ) );

					if ( !name ) {
						name = declaration.id.name;
					} else {
						name += "." + declaration.id.name
					}

					terminal = name.split( '.' )[ name.split( '.' ).length - 1 ];

					foundApplicableFunction = true;
				}
			} )
		}


		if( foundApplicableFunction ) {
			return {
				"sourceStart": sourceStart,
				"sourceStop" : sourceStop,
				"rightside" : rightside,
				"terminal" : terminal,
				"name" : name
			}
		}

		return false;
	}

} )( documentalCore.plugins, documentalCore.utils, documentalCore.state );

/**
 * Created by ammanvedi on 25/01/2016.
 */


( function( Plugins, Utils, State ) {

	Utils.determineFunctions = function ( file,  sourceString, acornInstance, walk ) {

		var methodCount = 0;
		var ast;
		var pluginNames = Object.keys( Plugins );

		State.currentFunctionBoundaries = 0;


		//try {
			ast = acornInstance.parse( sourceString, {
				locations: true,
				ranges: true,
				directSourceFile: true,
				onComment: Utils.commentFunction
			} );

			walk( ast, function ( node ) {

				//get Plugins
				for( x = 0; x < pluginNames.length; x++ ) {
					var pluginResult = Plugins[ pluginNames[ x ] ]( node );

					if( pluginResult ) {
						var body = sourceString.substring( pluginResult.sourceStart, pluginResult.sourceStop );
						var par = Utils.paramsToStringRepresentation( Utils.getSimpleParameters( pluginResult.rightside ) );
						methodCount++;
						var doc = Utils.findComments( pluginResult.rightside.loc );
						if ( doc == -1 ) {
							//console.log( 'method : ', name, ' not documented'  );
							var newdocstring = Utils.autoGenerateDocStub( sourceString, pluginResult.rightside, pluginResult.name );
							doc = doctrine.parse( newdocstring, { unwrap: true } );
						}

						pluginResult.name = Utils.useRulesDetermineNamespace( pluginResult.name, doc, pluginResult.sourceStart, pluginResult.sourceStop );
						console.log( pluginResult.name );

						Utils.addMemberToSourceMap( State.sourceMap, pluginResult.name, doc, body );
						State.autocomplete.push( { n: pluginResult.name, t: pluginResult.terminal } );
						break;
					}
				}

			} );

	/*	}catch( e ) {
			console.log( 'cant parse ', file, e )
		}
		*/

		State.total += methodCount;
		Utils.clearCommentCache();
		return sourceString;
	};

} )( documentalCore.plugins, documentalCore.utils, documentalCore.state );
/**
 * Created by ammanvedi on 25/01/2016.
 */

module.exports = documentalCore.utils.ingest;
