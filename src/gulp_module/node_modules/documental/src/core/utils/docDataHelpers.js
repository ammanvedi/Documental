/**
 * Created by ammanvedi on 25/01/2016.
 */

( function( Utils, State ) {

	Utils.getSimpleParameters = function ( functionStructure ) {
		var params = [];
		functionStructure.params.forEach( function ( p ) {
			params.push( p.name );
		} );
		return params;

	};

} )( documentalCore.utils, documentalCore.state );

( function( Utils, State ) {

	Utils.paramsToStringRepresentation = function ( p ) {
		if ( p.length > 0 ) {
			return " <-- " + p.join( " | " );
		} else {
			return "";
		}
	}

} )( documentalCore.utils, documentalCore.state );

( function( Utils, State ) {

	Utils.checkMemberOf = function( name, docs ) {

		if( docs && docs.tags ) {

			for( var x = 0; x< docs.tags.length; x++ ) {

				if( docs.tags[ x ].title === "memberof" ) {

					//console.log( name, docs );

					var candidate_name = name.split( '.' );
					if( candidate_name.length ) {
						return docs.tags[ x ].description + "." + name;
					}

				}

			}

		}

		return name;
	};

} )( documentalCore.utils, documentalCore.state );

( function( Utils, State ) {

	Utils.useRulesDetermineNamespace = function( name, docs, start, stop  ) {

		//check if there is a namespace that can be used
		var ns = "";
		var spaces = Object.keys( State.namespaceHash );
		if( spaces.length ) {
			for( var l = 0; l < spaces.length; l++ ) {
				if( State.namespaceHash[ spaces[ l ] ].end !== -1 && State.namespaceHash[ spaces[ l ] ].start < start && State.namespaceHash[ spaces[ l ] ].end > stop ) {
					ns = State.namespaceHash[ spaces[ l ] ].name;
					break;
				} else if( State.namespaceHash[ spaces[ l ] ].end === -1 ) {
					ns = State.namespaceHash[ spaces[ l ] ].name;
					break;
				}
			}
		}

		//console.log( 'func bound is : ', start, ' ', stop, ' chosen ns is  ', ns  );

		//chack if the calculated name uses the namespace already
		if( ns && ns !== "" && name.indexOf( ns ) === -1 ) {

			//does not fully contain, check divergence
			var divergenceIndex = Utils.findIndexOfDifference( name.split( '.' ), ns.split( '.' ) );
			//console.log( divergenceIndex );
			if( divergenceIndex === -1 ) {
				//console.log( 'created namespace : ',  ns + "." + name);
				return ns + "." + name;
			}

			//combine the namepace and the derived name into one
			return Utils.combineNamespacesAtIndex( ns, name, divergenceIndex ).join( '.' );
		}

		return name;
	};

} )( documentalCore.utils, documentalCore.state );

( function( Utils, State ) {

	Utils.autoGenerateDocStub = function ( source, functionNode, functionname ) {

		var augmentedStart = functionNode.start + State.totalAppendedChars;
		var before = source.slice( 0, augmentedStart );
		var after = source.slice( augmentedStart, source.length + 1 );
		var comment = "This Function Needs Documentation \n ";
		var parameter_names = [];
		parameter_names = Utils.getSimpleParameters( functionNode );

		if ( State.totalAppendedChars == 0 && !Utils.hasConstructor( source ) ) {
			comment = "This Function Needs Documentation  \n * @constructor " + functionname + "\n \n ";
		}

		if ( parameter_names.length > 0 ) {
			for ( var x = 0; x < parameter_names.length; x++ ) {
				comment += " * @param " + parameter_names[ x ] + "\n";
			}
		}
		State.totalAppendedChars += comment.length;

		return comment;
	};

} )( documentalCore.utils, documentalCore.state );


( function( Utils, State ) {

	Utils.hasConstructor = function ( source ) {
		return /@constructor|@Constructor/.test( source );
	};

} )( documentalCore.utils, documentalCore.state );

( function( Utils, State ) {

	Utils.findCommentsBetween = function ( startNewFunction, endOldFunction ) {
		var res = -1;

		Object.keys( State.commentsHash ).forEach( function ( commentLine, indexInHash ) {

				if ( parseInt( commentLine ) > endOldFunction && parseInt( commentLine ) < startNewFunction ) {
					var doctext = State.commentsHash[ commentLine ];
					var rexptest = /^[\s]*\/\*\*/.test( doctext );
					if ( rexptest ) {
						var docAST = doctrine.parse( doctext, { unwrap: true } );
						var issues = [];
						if ( docAST.description !== "" ) {
							for ( var i = 0; i < docAST.tags.length; i++ ) {
								if ( State.tagConfig[ docAST.tags[ i ].title ] == undefined ) {
									issues.push( { type: "BAD TAG", info: docAST.tags[ i ].title } );
								}
							}
						} else {
							issues.push( { type: "MISSING", info: "Description" } );
						}
						if ( issues.length > 0 ) {
							res = docAST;
						} else {
							State.totalCommented++;
							res = docAST;
						}
					}
				}
			}
		);
		return res;
	};

} )( documentalCore.utils, documentalCore.state );


( function( Utils, State ) {

	Utils.addToCommentsHash = function ( start, end, txt, namespace, namespaceID, schar, echar ) {
		if( !namespace ) {
			State.commentsHash[ start.toString() ] = {};
			State.commentsHash[ start.toString() ] = txt;
		} else {

			//create a new namespace reference and give it a
			//scope that is identified by its start and end location

			var nspaces = Object.keys( State.namespaceHash );

			if( nspaces.length > 0 ) {

				State.namespaceHash[ nspaces[ nspaces.length - 1 ] ].end = schar;

			}

			State.namespaceHash[ start.toString() ] = {
				name: namespaceID,
				start: schar,
				end: -1
			}
		}

	};

} )( documentalCore.utils, documentalCore.state );

( function( Utils, State ) {

	Utils.checkNamespace = function( docs ) {

		if( docs && docs.tags ) {

			for( var x = 0; x< docs.tags.length; x++ ) {

				if( docs.tags[ x ].title === "namespace" ) {
					return docs.tags[ x ].name ;

				}

			}

		}

		return false;
	};

} )( documentalCore.utils, documentalCore.state );

( function( Utils, State ) {

	Utils.typedefParser = function( text ) {

		var td = doctrine.parse( text, { unwrap: true } );
		console.log( JSON.stringify(td, null, 4) );

		if( td ) {
			Utils.addMemberToSourceMap( State.sourceMap, "typedefs." + td.tags[ 0 ].name.replace( " ", "" ), td, text );
			State.autocomplete.push( { n: "typedefs." + td.tags[ 0 ].name.replace( " ", "" ), t: td.tags[ 0 ].name.replace( " ", "" ) } );
		}

	}

} )( documentalCore.utils, documentalCore.state );

( function( Utils, State, Constants ) {

	Utils.commentFunction = function ( block, text, start, end, startloc, endloc ) {
		if ( block ) {
			text = "/*" + text + "*/";

			//namespacing and typedefs should be in their own comments
			//as per standard
			if( text.indexOf( "@namespace" ) >= 0 ) {
				var ns = doctrine.parse( text, Constants.doctrineConfig );
				var desc = Utils.checkNamespace( ns );

				if( desc ) {
					Utils.addToCommentsHash( startloc.line, endloc.line, text, true, desc, start, end  );

				}

				return;
			}

			if( text.indexOf( "@typedef" ) >= 0  ) {

				Utils.typedefParser( text );
				return;
			}

			Utils.addToCommentsHash( startloc.line, endloc.line, text );

		}

	};

} )( documentalCore.utils, documentalCore.state, documentalCore.constants );

( function( Utils, State ) {

	Utils.findComments = function ( location ) {

		var isdoc;

		if ( State.currentFunctionBoundaries ) {
			if ( location.start.line > State.currentFunctionBoundaries.end.line ) {
				isdoc = Utils.findCommentsBetween( location.start.line, State.currentFunctionBoundaries.end.line );
				State.currentFunctionBoundaries = location;
			} else if ( location.start.line < State.currentFunctionBoundaries.end.line ) {
				if ( State.nestedFunctionBoundaries ) {
					isdoc = Utils.findCommentsBetween( location.start.line, State.nestedFunctionBoundaries.end.line );
				} else {
					isdoc = Utils.findCommentsBetween( location.start.line, State.currentFunctionBoundaries.start.line );
				}

				State.nestedFunctionBoundaries = location;
			}

		} else {
			isdoc = Utils.findCommentsBetween( location.start.line, 0 );
			State.currentFunctionBoundaries = location;
		}

		return isdoc;
	};

} )( documentalCore.utils, documentalCore.state );









