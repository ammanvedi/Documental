
( function( Utils, State ) {

	/**
	 * for parameters return an array of each name
	 *
	 * @param {object} functionStructure function metadata
	 */
	Utils.getSimpleParameters = function ( functionStructure ) {
		var params = [];
		functionStructure.params.forEach( function ( p ) {
			params.push( p.name );
		} );
		return params;

	};

} )( documentalCore.utils, documentalCore.state );

( function( Utils, State ) {


	/**
	 * print params as a pretty string
	 *
	 * @param {Array.<string>} p parameter
	 */
	Utils.paramsToStringRepresentation = function ( p ) {
		if ( p.length > 0 ) {
			return " <-- " + p.join( " | " );
		} else {
			return "";
		}
	}

} )( documentalCore.utils, documentalCore.state );

( function( Utils, State ) {

	/**
	 * check for a memberof tag and update the namespace based on this
	 *
	 * @param {string} name namespaced name
	 * @param {docNode} docs documentation structure
	 * @returns {string} combined name
	 */
	Utils.checkMemberOf = function( name, docs ) {

		if( docs && docs.tags ) {

			for( var x = 0; x< docs.tags.length; x++ ) {

				if( docs.tags[ x ].title === "memberof" ) {

					//console.log( name, docs );

					var candidate_name = name.split( '.' );
					if( candidate_name.length ) {
						return docs.tags[ x ].description + "." + name;
					}

				}

			}

		}

		return name;
	};

} )( documentalCore.utils, documentalCore.state );

( function( Utils, State ) {

	/**
	 * determine the namespace of the function checking for;
	 *
	 * 1) is there a namespace tag that has been declared that we should use
	 * 2) does this namespace actually have any relevance to the current function namepsacce
	 * 3) if it was check to find how we can combine the namespaces
	 *
	 * @param {string} name namespaced name
	 * @param {spidermonkeyASTNode} docs documentation structure
	 * @params {integer} start start function location ( character number )
	 * @params {integer} stop end function location ( character number )
	 * @returns {string} determined namespace
	 */
	Utils.useRulesDetermineNamespace = function( name, docs, start, stop  ) {

		//check if there is a namespace that can be used
		var ns = "";
		var spaces = Object.keys( State.namespaceHash );
		if( spaces.length ) {
			for( var l = 0; l < spaces.length; l++ ) {
				if( State.namespaceHash[ spaces[ l ] ].end !== -1 && State.namespaceHash[ spaces[ l ] ].start < start && State.namespaceHash[ spaces[ l ] ].end > stop ) {
					ns = State.namespaceHash[ spaces[ l ] ].name;
					break;
				} else if( State.namespaceHash[ spaces[ l ] ].end === -1 ) {
					ns = State.namespaceHash[ spaces[ l ] ].name;
					break;
				}
			}
		}


		//chack if the calculated name uses the namespace already
		if( ns && ns !== "" && name.indexOf( ns ) === -1 ) {

			//does not fully contain, check divergence
			var divergenceIndex = Utils.findIndexOfDifference( name.split( '.' ), ns.split( '.' ) );
			//console.log( divergenceIndex );
			if( divergenceIndex === -1 ) {
				//console.log( 'created namespace : ',  ns + "." + name);
				return ns + "." + name;
			}

			//combine the namepace and the derived name into one
			return Utils.combineNamespacesAtIndex( ns, name, divergenceIndex ).join( '.' );
		}

		return name;
	};

} )( documentalCore.utils, documentalCore.state );

( function( Utils, State ) {

	/**
	 * generate standard doc stub if no documantation was found, this will
	 * infer param names at the least, no types will be inferred, doc is generated as
	 * a comment and parsed as if it was found in source
	 *
	 * @param {string} source source code
	 * @param {spidermonkeyASTNode} functionNode function structure
	 * @returns {string} doc comment
	 */
	Utils.autoGenerateDocStub = function ( source, functionNode ) {

		var augmentedStart = functionNode.start + State.totalAppendedChars;
		var before = source.slice( 0, augmentedStart );
		var after = source.slice( augmentedStart, source.length + 1 );
		var comment = "This Function Needs Documentation \n ";
		var parameter_names = [];
		parameter_names = Utils.getSimpleParameters( functionNode );

		if ( State.totalAppendedChars == 0 ) {
			comment = "This Function Needs Documentation  \n \n ";
		}

		if ( parameter_names.length > 0 ) {
			for ( var x = 0; x < parameter_names.length; x++ ) {
				comment += " * @param " + parameter_names[ x ] + "\n";
			}
		}
		State.totalAppendedChars += comment.length;

		return comment;
	};

} )( documentalCore.utils, documentalCore.state );


( function( Utils, State ) {

	/**
	 * Is there a constructor in the source ?
	 * @returns {boolean} weather there is a constructor
	 */
	Utils.hasConstructor = function ( source ) {
		return /@constructor|@Constructor/.test( source );
	};

} )( documentalCore.utils, documentalCore.state );

( function( Utils, State ) {

	/**
	 * find comments in the comments hash that lie between two points
	 *
	 * @param {integer} startNewFunction the start character to search to
	 * @param {integer} endOldFunction the start character to search from
	 * @returns {docNode|integer} parsed comment doc structure or -1
	 */
	Utils.findCommentsBetween = function ( startNewFunction, endOldFunction ) {
		var res = -1;

		Object.keys( State.commentsHash ).forEach( function ( commentLine, indexInHash ) {

				if ( parseInt( commentLine ) > endOldFunction && parseInt( commentLine ) < startNewFunction ) {
					var doctext = State.commentsHash[ commentLine ];
					var rexptest = /^[\s]*\/\*\*/.test( doctext );
					if ( rexptest ) {
						var docAST = doctrine.parse( doctext, { unwrap: true } );
						var issues = [];
						if ( docAST.description !== "" ) {
							for ( var i = 0; i < docAST.tags.length; i++ ) {
								if ( State.tagConfig[ docAST.tags[ i ].title ] == undefined ) {
									issues.push( { type: "BAD TAG", info: docAST.tags[ i ].title } );
								}
							}
						} else {
							issues.push( { type: "MISSING", info: "Description" } );
						}
						if ( issues.length > 0 ) {
							res = docAST;
						} else {
							State.totalCommented++;
							res = docAST;
						}
					}
				}
			}
		);
		return res;
	};

} )( documentalCore.utils, documentalCore.state );


( function( Utils, State ) {

	/**
	 * add a comment to the comments hash
	 *
	 * @param {integer} start the start character of the comment
	 * @param {integer} end the end character of the comment
	 * @param {string} txt the comments text
	 * @param {boolean} namespace if the comment is a namespace comment
	 * @param {string} namespaceID the namespace name
	 * @param {integer} schar end of the namespace char
	 */
	Utils.addToCommentsHash = function ( start, end, txt, namespace, namespaceID, schar ) {
		if( !namespace ) {
			State.commentsHash[ start.toString() ] = {};
			State.commentsHash[ start.toString() ] = txt;
		} else {

			//create a new namespace reference and give it a
			//scope that is identified by its start and end location

			var nspaces = Object.keys( State.namespaceHash );

			if( nspaces.length > 0 ) {

				State.namespaceHash[ nspaces[ nspaces.length - 1 ] ].end = schar;

			}

			State.namespaceHash[ start.toString() ] = {
				name: namespaceID,
				start: schar,
				end: -1
			}
		}

	};

} )( documentalCore.utils, documentalCore.state );

( function( Utils, State ) {

	/**
	 * check for namespace tags in the docs
	 *
	 * @param {docNode} docs documentation structure
	 */
	Utils.checkNamespace = function( docs ) {

		if( docs && docs.tags ) {
			for( var x = 0; x< docs.tags.length; x++ ) {
				if( docs.tags[ x ].title === "namespace" ) {
					return docs.tags[ x ].name ;
				}
			}
		}
		return false;
	};

} )( documentalCore.utils, documentalCore.state );

( function( Utils, State ) {

	/**
	 * add a typedef declaration comment to the source map
	 *
	 * @param {string} text the typedef source
	 * @param {sourceLocationNode} start the start location of the typedef in source file
	 */
	Utils.typedefParser = function( text, start ) {

		var td = doctrine.parse( text, { unwrap: true } );

		if( td ) {

			var fpath = State.file.path.split( "/" );
			var filenamed = fpath[ fpath.length - 1  ] ;

			Utils.addMemberToSourceMap( State.sourceMap, "typedefs." + td.tags[ 0 ].name.replace( " ", "" ), td, text, filenamed, start );
			State.autocomplete.push( { n: "typedefs." + td.tags[ 0 ].name.replace( " ", "" ), t: td.tags[ 0 ].name.replace( " ", "" ) } );
		}

	}

} )( documentalCore.utils, documentalCore.state );

( function( Utils, State, Constants ) {

	/**
	 * Function that is called when the ast walker finds a comment
	 *
	 * @param {boolean} block if the comment is a black comment, we are only interested in block comments
	 * @param {string} text the comment source
	 * @param {integer} start the start location of the comment
	 * @param {integer} end the end location of the comment
	 * @param {sourceLocationNode} startloc the start location node
	 * @param {sourceLocationNode} endloc the end location node
	 *
	 */
	Utils.commentFunction = function ( block, text, start, end, startloc, endloc ) {
		if ( block ) {
			text = "/*" + text + "*/";

			//namespacing and typedefs should be in their own comments
			//as per standard
			if( text.indexOf( "@namespace" ) >= 0 ) {
				var ns = doctrine.parse( text, Constants.doctrineConfig );
				var desc = Utils.checkNamespace( ns );

				if( desc ) {
					Utils.addToCommentsHash( startloc.line, endloc.line, text, true, desc, start, end  );

				}

				return;
			}

			if( text.indexOf( "@typedef" ) >= 0  ) {

				Utils.typedefParser( text, startloc );
				return;
			}

			Utils.addToCommentsHash( startloc.line, endloc.line, text );

		}

	};

} )( documentalCore.utils, documentalCore.state, documentalCore.constants );

( function( Utils, State ) {

	/**
	 * find comments given a function location
	 *
	 * @param {locationNode} location location to find comments for
	 * @returns {docNode|undefined} documentation or undefined
	 */
	Utils.findComments = function ( location ) {

		var isdoc;

		if ( State.currentFunctionBoundaries ) {
			if ( location.start.line > State.currentFunctionBoundaries.end.line ) {
				isdoc = Utils.findCommentsBetween( location.start.line, State.currentFunctionBoundaries.end.line );
				State.currentFunctionBoundaries = location;
			} else if ( location.start.line < State.currentFunctionBoundaries.end.line ) {
				if ( State.nestedFunctionBoundaries ) {
					isdoc = Utils.findCommentsBetween( location.start.line, State.nestedFunctionBoundaries.end.line );
				} else {
					isdoc = Utils.findCommentsBetween( location.start.line, State.currentFunctionBoundaries.start.line );
				}

				State.nestedFunctionBoundaries = location;
			}

		} else {
			isdoc = Utils.findCommentsBetween( location.start.line, 0 );
			State.currentFunctionBoundaries = location;
		}

		return isdoc;
	};

} )( documentalCore.utils, documentalCore.state );









