{"PULSE":{"BallProgress":{"Documentation":{"description":"Class to encapsulate a ball progress.","tags":[]},"Source":"PULSE.BallProgress = function ( rawBp )\n{\n\tvar fields = rawBp.split( '.' );\n\tthis.innings = fields[0];\n\tthis.over = fields[1];\n\t\n\tif ( fields.length > 2 )\n\t{\n\t\tthis.ball = fields[2];\n\t}\n}","matches":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"PULSE.BallProgress.matches"},{"title":"param","description":null,"type":null,"name":"raw"}]},"Source":"PULSE.BallProgress.matches = function ( raw )\n{\n\treturn !Utils.isNullish( raw ) && raw.match( /\\d+\\.\\d+\\.\\d+/ ) !== null;\n}"},"prototype":{"description":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.BallProgress.prototype.description = function ()\n{\n\treturn this.innings + '.' + this.over + '.' + this.ball;\n}"},"compareTo":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"rawBp"}]},"Source":"PULSE.BallProgress.prototype.compareTo = function ( rawBp )\n{\n\tvar other = new PULSE.BallProgress( rawBp );\n\t\n    var compare = +this.innings - +other.innings;\n    if ( compare === 0 )\n    {\n        compare = +this.over - +other.over;\n        if ( compare === 0 )\n        {\n            compare = +this.ball - +other.ball;\n        }\n    }\n\n    return compare;\n}"}}},"CLIENT":{"CRICKET":{"Utils":{"getRunsOverWickets":{"Documentation":{"description":"Generate a user-friendly score from the matchschedule2 team1 or team2 ScoringSummary object","tags":[]},"Source":"PULSE.CLIENT.CRICKET.Utils.getRunsOverWickets = function( scoringSummary )\r\n{\r\n\tif( scoringSummary && scoringSummary.innings )\r\n\t{\r\n\t\tif( !scoringSummary.innings[0].allOut )\r\n\t\t{\r\n\t\t\treturn scoringSummary.innings[0].runs + \"/\" + scoringSummary.innings[0].wkts;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\treturn scoringSummary.innings[0].runs;\r\n\t\t}\r\n\t}\r\n\treturn \"\";\r\n}"},"getInningsScore":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"PULSE.CLIENT.CRICKET.Utils.getInningsScore"},{"title":"param","description":null,"type":null,"name":"runs"},{"title":"param","description":null,"type":null,"name":"wickets"},{"title":"param","description":null,"type":null,"name":"allOut"},{"title":"param","description":null,"type":null,"name":"declared"},{"title":"param","description":null,"type":null,"name":"flip"},{"title":"param","description":null,"type":null,"name":"scoreDelimeter"}]},"Source":"PULSE.CLIENT.CRICKET.Utils.getInningsScore = function( runs, wickets, allOut, declared, flip, scoreDelimeter )\r\n{\r\n\tvar score = \"\";\r\n\r\n\tif( wickets !== undefined || runs !== undefined )\r\n\t{\r\n\t\tif( flip )\r\n\t\t{\r\n\t\t\tscore = ( !allOut ? ( wickets || 0 ) + ( scoreDelimeter || '/' ) : \"\" ) + ( runs || 0 ) + ( declared ? 'd' : '' );\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tscore = ( runs || 0 ) + ( !allOut ? ( scoreDelimeter || '/' ) + ( wickets || 0 ) : '' ) + ( declared ? 'd' : '' );\r\n\t\t}\r\n\t}\r\n\r\n\treturn score;\r\n}"},"getTeamLatestInnings":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"innings"},{"title":"param","description":null,"type":null,"name":"battingOrder"},{"title":"param","description":null,"type":null,"name":"index"}]},"Source":"PULSE.CLIENT.CRICKET.Utils.getTeamLatestInnings = function( innings, battingOrder, index )\r\n{\r\n\tvar lastInnings;\r\n\r\n\tfor( var i = 0; i < innings.length; i++ )\r\n\t{\r\n\t\tvar inning \t\t= innings[i],\r\n\t\t\tbattingIdx\t= battingOrder[i];\r\n\r\n\t\tif( battingIdx === index )\r\n\t\t{\r\n\t\t\tlastInnings = inning;\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn lastInnings;\r\n}"},"getFakeOversFraction":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"innings"}]},"Source":"PULSE.CLIENT.CRICKET.Utils.getFakeOversFraction = function ( innings )\r\n{\r\n\tvar oversFraction = \"\";\r\n\r\n\tif( innings && innings.ballsFaced )\r\n\t{\r\n\t\tvar completeOvers \t= innings.ballsFaced / 6,\r\n\t\t\tincompleteOver \t= innings.ballsFaced % 6,\r\n\t\t\toversFraction \t= parseInt( completeOvers ) + ( incompleteOver !== 0 ? '.' + incompleteOver : '' );\r\n\t}\t\r\n\t\r\n\treturn oversFraction;\r\n}"},"getPlayerNameHtml":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"name"}]},"Source":"PULSE.CLIENT.CRICKET.Utils.getPlayerNameHtml = function( name )\r\n{\r\n\tvar space = name.indexOf( ' ' );\t\t\t\r\n\tif ( space === -1 )\r\n\t{\r\n\t\tspace = 0;\r\n\t}\r\n\tvar start = name.substr( 0, space );\r\n\tvar rest = name.substr( space );\r\n\t\r\n\treturn start + '<span>' + rest + '</span>';\r\n}"},"formatTeamNameAbbr":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"teamname"}]},"Source":"PULSE.CLIENT.CRICKET.Utils.formatTeamNameAbbr = function( teamname )\r\n{\r\n\treturn teamname.split( '&' ).join( '&amp;' );\r\n}"},"compareRuns":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"stats1"},{"title":"param","description":null,"type":null,"name":"stats2"}]},"Source":"PULSE.CLIENT.CRICKET.Utils.compareRuns = function( stats1, stats2 )\r\n{\r\n\tvar run1 = stats1 && stats1.stats && stats1.stats.r !== '-' ? +stats1.stats.r : -1;\r\n\tvar run2 = stats2 && stats2.stats && stats2.stats.r !== '-' ? +stats2.stats.r : -1;\r\n\tvar sr1 = stats1 && stats1.stats && stats1.stats.sr !== '-' ? +stats1.stats.sr : -1;\r\n\tvar sr2 = stats2 && stats2.stats && stats2.stats.sr !== '-' ? +stats2.stats.sr : -1;\r\n\r\n\tvar compareOutput;\r\n\r\n\tif ( run1 < run2 )\r\n\t{\r\n\t\tcompareOutput = 1;\r\n\t}\r\n\telse if ( run1 > run2 )\r\n\t{\r\n\t\tcompareOutput =  -1;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tif ( sr1 || sr2 )\r\n\t\t{\r\n\t\t\tcompareOutput = 0;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tif ( sr1 < sr2 )\r\n\t\t\t{\r\n\t\t\t\tcompareOutput = 1;\r\n\t\t\t}\r\n\t\t\telse if ( sr1 > sr2 )\r\n\t\t\t{\r\n\t\t\t\tcompareOutput = -1;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tcompareOutput = 0;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn compareOutput;\r\n}"},"compareEconomy":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"stats1"},{"title":"param","description":null,"type":null,"name":"stats2"}]},"Source":"PULSE.CLIENT.CRICKET.Utils.compareEconomy = function( stats1, stats2 )\r\n{\r\n\tvar e1 = stats1 && stats1.stats && typeof stats1.stats.e !== 'undefined' && stats1.stats.e !== '-' ? +stats1.stats.e : -1;\r\n\tvar e2 = stats2 && stats2.stats && typeof stats1.stats.e !== 'undefined' && stats2.stats.e !== '-' ? +stats2.stats.e : -1;\r\n\r\n\tvar compareOutput;\r\n\t\r\n\tif( e1 === -1 && e2 !== -1 )\r\n\t{\r\n\t\tcompareOutput = 1;\r\n\t}\r\n\telse if( e1 !== -1 && e2 === -1 )\r\n\t{\r\n\t\tcompareOutput = -1;\r\n\t}\r\n\telse\r\n\t{\r\n\t    if ( e1 < e2 )\r\n\t    {\r\n\t        compareOutput = -1;\r\n\t    }\r\n\t    else if ( e1 > e2 )\r\n\t    {\r\n\t        compareOutput = 1;\r\n\t    }\r\n\t    else\r\n\t    {\r\n\t        compareOutput = 0;\r\n\t    }\r\n\t}\r\n    \r\n    return compareOutput;\r\n}"},"compareWickets":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"stats1"},{"title":"param","description":null,"type":null,"name":"stats2"}]},"Source":"PULSE.CLIENT.CRICKET.Utils.compareWickets = function( stats1, stats2 )\r\n{\r\n\tvar w1 = stats1 && stats1.stats && typeof stats1.stats.w !== 'undefined' ? +stats1.stats.w : -1;\r\n\tvar w2 = stats2 && stats2.stats && typeof stats1.stats.w !== 'undefined' ? +stats2.stats.w : -1;\r\n\tvar r1 = stats1 && stats1.stats && typeof stats1.stats.r !== 'undefined' ? +stats1.stats.r : -1;\r\n\tvar r2 = stats2 && stats2.stats && typeof stats1.stats.r !== 'undefined' ? +stats2.stats.r : -1;\r\n\r\n\tvar compareOutput = 0;\r\n\t\r\n    if ( w1 < w2 )\r\n    {\r\n        compareOutput = 1;\r\n    }\r\n    else if ( w1 > w2 )\r\n    {\r\n        compareOutput = -1;\r\n    }\r\n    else\r\n    {\r\n    \tif( w1 > 0 && w2 > 0 )\r\n    \t{\r\n\t        if ( r1 < r2 )\r\n\t\t    {\r\n\t\t        compareOutput = -1;\r\n\t\t    }\r\n\t\t    else if ( r1 > r2 )\r\n\t\t    {\r\n\t\t        compareOutput = 1;\r\n\t\t    }\r\n\t\t    else\r\n\t\t    {\r\n\t\t    \tcompareOutput = PULSE.CLIENT.CRICKET.Utils.compareEconomy( stats1, stats2 );\r\n\t\t    }\r\n    \t}\r\n\t    else\r\n\t    {\r\n\t    \tcompareOutput = PULSE.CLIENT.CRICKET.Utils.compareEconomy( stats1, stats2 );\r\n\t    }\r\n    }\r\n    \r\n    return compareOutput;\r\n}"},"mergeBattingStats":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"stats1"},{"title":"param","description":null,"type":null,"name":"stats2"}]},"Source":"PULSE.CLIENT.CRICKET.Utils.mergeBattingStats = function( stats1, stats2 )\r\n{\r\n\tvar mergedStat =\r\n\t{\r\n\t\tplayerId : -1,\r\n\t\tb: 0,\r\n\t\tr: 0,\r\n\t\t'4s': 0,\r\n\t\t'6s': 0\r\n\t}\r\n\r\n\tfor( var m in mergedStat )\r\n\t{\r\n\t\tif( m === 'playerId' )\r\n\t\t{\r\n\t\t\tmergedStat[m] = stats1[m];\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tmergedStat[m] += ( stats1[m] ? stats1[m] : 0 );\r\n\t\t\tmergedStat[m] += ( stats2[m] ? stats2[m] : 0 );\r\n\t\t}\r\n\t}\r\n\r\n\treturn mergedStat;\r\n}"},"mergeBowlingStats":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"stats1"},{"title":"param","description":null,"type":null,"name":"stats2"}]},"Source":"PULSE.CLIENT.CRICKET.Utils.mergeBowlingStats = function( stats1, stats2 )\r\n{\r\n\tvar mergedStat =\r\n\t{\r\n\t\tplayerId : -1,\r\n\t\tw: 0,\r\n\t\td: 0,\r\n\t\tnb: 0,\r\n\t\tr: 0,\r\n\t\tmaid: 0,\r\n\t\twd: 0\r\n\t}\r\n\r\n\tfor( var m in mergedStat )\r\n\t{\r\n\t\tif( m === 'playerId' )\r\n\t\t{\r\n\t\t\tmergedStat[m] = stats1[m];\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tmergedStat[m] += ( stats1[m] ? stats1[m] : 0 );\r\n\t\t\tmergedStat[m] += ( stats2[m] ? stats2[m] : 0 );\r\n\t\t}\r\n\t}\r\n\r\n\treturn mergedStat;\r\n}"},"fakeOversFractionToOversDecimal":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"string"}]},"Source":"PULSE.CLIENT.CRICKET.Utils.fakeOversFractionToOversDecimal = function( string )\r\n{\r\n\tvar over = 0;\r\n\tvar BALLS_IN_OVER = 6;\r\n\t\r\n    if ( string != null && string.match( \"\\\\d+(\\\\.\\\\d)?\" ) )\r\n    {\r\n        var index = string.indexOf( \".\" );\r\n        if ( index == -1 )\r\n        {\r\n            overs = parseInt( string );\r\n        }\r\n        else\r\n        {\r\n            overs = ( parseInt( string.substring( 0, index ) ) ) +\r\n                \t( parseFloat( string.substring( index + 1 ) / BALLS_IN_OVER ) );\r\n        }\r\n    }\r\n\r\n    return overs;\r\n}"},"getBPString":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"bp"}]},"Source":"PULSE.CLIENT.CRICKET.Utils.getBPString = function( bp )\r\n{\r\n\treturn bp.innings + '.' + bp.over + '.' + bp.ball;\r\n}"},"convertBallsToOvers":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"balls"}]},"Source":"PULSE.CLIENT.CRICKET.Utils.convertBallsToOvers = function( balls )\r\n{\r\n\tif ( balls > 0 )\r\n\t{\r\n\t\treturn Math.floor( balls / 6 ) + '.' + ( balls % 6 );\r\n\t}\r\n\t\r\n\treturn '';\r\n}"},"getStandingsForValue":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"standing"}]},"Source":"PULSE.CLIENT.CRICKET.Utils.getStandingsForValue = function( standing )\r\n{\r\n\tif( standing.totalRunsFor )\r\n\t{\r\n\t\tvar overs = PULSE.CLIENT.CRICKET.Utils.convertBallsToOvers( standing.totalBallsFor );\r\n\t\treturn standing.totalRunsFor + '/' + overs;\r\n\t}\r\n\telse\r\n\t{\r\n\t\treturn \"\";\r\n\t}\r\n}"},"getStandingsAgainstValue":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"standing"}]},"Source":"PULSE.CLIENT.CRICKET.Utils.getStandingsAgainstValue = function( standing )\r\n{\r\n\tif( standing.totalRunsAgainst )\r\n\t{\r\n\t\tvar overs = PULSE.CLIENT.CRICKET.Utils.convertBallsToOvers( standing.totalBallsAgainst );\r\n\t\treturn standing.totalRunsAgainst + '/' + overs;\r\n\t}\r\n\telse\r\n\t{\r\n\t\treturn \"\";\r\n\t}\r\n}"}},"Util":{"convertBallsToOvers":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"PULSE.CLIENT.CRICKET.Util.convertBallsToOvers"},{"title":"param","description":null,"type":null,"name":"balls"}]},"Source":"PULSE.CLIENT.CRICKET.Util.convertBallsToOvers = function( balls )\n{\t\n\tif ( +balls > 0 )\n\t{\n\t\treturn Math.floor( balls / 6 ) + '.' + ( balls % 6 );\n\t}\n\t\n\treturn '';\n}"},"inningsScore":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"runs"},{"title":"param","description":null,"type":null,"name":"wkts"},{"title":"param","description":null,"type":null,"name":"allOut"}]},"Source":"PULSE.CLIENT.CRICKET.Util.inningsScore = function( runs, wkts, allOut )\n{\n\treturn runs + ( !allOut ? \"/\" + (wkts || 0) : \"\" );\n}"},"oversLimit":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"ballsFaced"}]},"Source":"PULSE.CLIENT.CRICKET.Util.oversLimit = function ( ballsFaced )\n{\n\tvar oversLimit = \"\";\n\tvar completeOvers = ballsFaced / 6;\n\tvar incompleteOver = ballsFaced % 6;\n\tif( ballsFaced )\n\t{\n\t\tvar oversFaced = parseInt( completeOvers ) + ( incompleteOver !== 0 ? '.' + incompleteOver : '' );\n\t\toversLimit = oversFaced + '/' + this.MAX_OVERS_LIMIT;\n\t}\n\t\n\treturn oversLimit;\n}"},"getFormattedDateTime":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"dateStr"},{"title":"param","description":null,"type":null,"name":"withYear"}]},"Source":"PULSE.CLIENT.CRICKET.Util.getFormattedDateTime = function ( dateStr, withYear )\n{\n\t// parseDateTime gives you local date-time\n\tvar matchDate = PULSE.CLIENT.DateUtil.parseDateTime( dateStr );\n\tif ( matchDate )\n\t{\t\n\t\tvar matchTimeIST = PULSE.CLIENT.DateUtil.calcTimeByOffset( matchDate, this.IST_OFFSET ).time.substr( 0, 5 );\t\t\n\t\tvar formattedDateTime = dateFormat( matchDate, 'dddd mmmm dS yyyy|HH:MM| Z' ).split( this.DATE_TIME_DELIMITER );\n\t\tvar mDate = formattedDateTime[0]; \n\t\tvar mTime = formattedDateTime[1]; \n\t\tvar timezone = formattedDateTime[2];\t\n\n\t\treturn { date    : mDate, \n\t\t\t\t time    : mTime,\n\t\t\t\t timeIST : mTime === matchTimeIST ? '' : matchTimeIST,\n\t\t\t\t timezone: mTime === matchTimeIST ? ' IST' : timezone };\n\t}\t\n}"},"fakeOversFractionToOversDecimal":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"string"}]},"Source":"PULSE.CLIENT.CRICKET.Util.fakeOversFractionToOversDecimal = function( string )\n{\n\tvar over = 0;\n\tvar BALLS_IN_OVER = 6;\n\n\tif ( string != null && string.match( \"\\\\d+(\\\\.\\\\d)?\" ) )\n\t{\n\t\tvar index = string.indexOf( \".\" );\n\t\tif ( index == -1 )\n\t\t{\n\t\t\tovers = parseInt( string );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tovers = ( parseInt( string.substring( 0, index ) ) )\n\t\t\t\t\t+ ( parseFloat( string.substring( index + 1 )\n\t\t\t\t\t\t\t/ BALLS_IN_OVER ) );\n\t\t}\n\t}\n\n\treturn overs;\n}"},"isInt":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"number"}]},"Source":"PULSE.CLIENT.CRICKET.Util.isInt = function( number )\n{\n\treturn typeof(number) === 'number' && parseInt(number) === number;\n}"},"getNames":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"data"}]},"Source":"PULSE.CLIENT.CRICKET.Util.getNames = function ( data )\n{\n\tvar array = [];\n\tif( data.matchInfo.teams )\n\t{\n\t\tif( data.matchInfo.teams[0] && data.matchInfo.teams[0].team )\n\t\t{\n\t\t\tarray.push( data.matchInfo.teams[0].team.fullName );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tarray.push( 'TBD' );\n\t\t}\n\t\t\n\t\tif( data.matchInfo.teams[1] && data.matchInfo.teams[1].team )\n\t\t{\n\t\t\tarray.push( data.matchInfo.teams[1].team.fullName );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tarray.push( 'TBD' );\n\t\t}\n\t}\n\treturn array;\n}"},"getInningsScore":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"runs"},{"title":"param","description":null,"type":null,"name":"wickets"},{"title":"param","description":null,"type":null,"name":"allOut"},{"title":"param","description":null,"type":null,"name":"declared"},{"title":"param","description":null,"type":null,"name":"flip"},{"title":"param","description":null,"type":null,"name":"scoreDelimeter"}]},"Source":"PULSE.CLIENT.CRICKET.Util.getInningsScore = function( runs, wickets, allOut, declared, flip, scoreDelimeter )\n{\n\tvar score = \"\";\n\n\tif( wickets !== undefined || runs !== undefined )\n\t{\n\t\tif( flip )\n\t\t{\n\t\t\tscore = ( !allOut ? ( wickets || 0 ) + ( scoreDelimeter || '/' ) : \"\" ) + ( runs || 0 ) + ( declared ? 'd' : '' );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tscore = ( runs || 0 ) + ( !allOut ? ( scoreDelimeter || '/' ) + ( wickets || 0 ) : '' ) + ( declared ? 'd' : '' );\n\t\t}\n\t}\n\n\treturn score;\n}"},"getTeamLatestInnings":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"innings"},{"title":"param","description":null,"type":null,"name":"battingOrder"},{"title":"param","description":null,"type":null,"name":"index"}]},"Source":"PULSE.CLIENT.CRICKET.Util.getTeamLatestInnings = function( innings, battingOrder, index )\n{\n\tvar lastInnings;\n\n\tfor( var i = 0; i < innings.length; i++ )\n\t{\n\t\tvar inning \t\t= innings[i],\n\t\t\tbattingIdx\t= battingOrder[i];\n\n\t\tif( battingIdx === index )\n\t\t{\n\t\t\tlastInnings = inning;\n\t\t}\n\t}\n\t\n\treturn lastInnings;\n}"},"getFakeOversFraction":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"innings"}]},"Source":"PULSE.CLIENT.CRICKET.Util.getFakeOversFraction = function ( innings )\n{\n\tvar oversFraction = \"\";\n\n\tif( innings && innings.ballsFaced )\n\t{\n\t\tvar completeOvers \t= innings.ballsFaced / 6,\n\t\t\tincompleteOver \t= innings.ballsFaced % 6,\n\t\t\toversFraction \t= parseInt( completeOvers ) + ( incompleteOver !== 0 ? '.' + incompleteOver : '' );\n\t}\t\n\t\n\treturn oversFraction;\n}"},"getTeamInnings":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"index"},{"title":"param","description":null,"type":null,"name":"matchData"},{"title":"param","description":null,"type":null,"name":"flip"}]},"Source":"PULSE.CLIENT.CRICKET.Util.getTeamInnings = function( index, matchData, flip )\n{\n\tvar scoringData = matchData.scoringData;\n\tvar scheduleData = matchData.scheduleData;\n\tvar innings = [];\n\n\t//if scoring data exists, it takes precedence\n\tif( scoringData )\n\t{\n\t\tvar battingOrder= scoringData.matchInfo.battingOrder,\n\t\t\tcii \t\t= scoringData.currentState.currentInningsIndex;\n\n\t\tif( scoringData.innings )\n\t\t{\n\t\t\tfor( var i = 0; i < scoringData.innings.length; i++ )\n\t\t\t{\n\t\t\t\tvar inning \t\t= scoringData.innings[i],\n\t\t\t\t\tbattingIdx\t= battingOrder[i],\n\t\t\t\t\tbowlingIdx\t= battingIdx === 0 ? 1 : 0,\n\t\t\t\t\tbattingTeam = scoringData.matchInfo.teams[ battingIdx ],\n\t\t\t\t\tbowlingTeam = scoringData.matchInfo.teams[ bowlingIdx ];\n\n\t\t\t\tif( inning.scorecard && battingIdx === index )\n\t\t\t\t{\n\t\t\t\t\tinnings.push( PULSE.CLIENT.CRICKET.Util.getInningsScore( inning.scorecard.runs, inning.scorecard.wkts, inning.scorecard.allOut, inning.declared, flip ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//if a new innings has started and an innings object \n\t\t//doesn't exist for the new innings and\n\t\t//batting index for this innings === index\n\t\t//add an empty score\n\t\tif( ( !scoringData.innings || scoringData.innings.length < ( cii + 1 ) ) && battingOrder && battingOrder[cii] === index )\n\t\t{\n\t\t\tinnings.push( PULSE.CLIENT.CRICKET.Util.getMatchState( matchData ) === 'L' ? '0/0' : '' );\n\t\t}\n\t}\n\telse if( scheduleData && scheduleData['team' + ( index + 1 ) ] && scheduleData['team' + ( index + 1 ) ].innings )\n\t{\n\t\tfor( var i = 0; i < scheduleData['team' + ( index + 1 ) ].innings.length; i++ )\n\t\t{\n\t\t\tvar inning = scheduleData['team' + ( index + 1 ) ].innings[i];\n\n\t\t\t// sometimes the data feed returns an innings object, \n\t\t\t// but with no balls faced means the inns never started, so it needs to be ignored\n\t\t\tif( inning.ballsFaced )\n\t\t\t{\n\t\t\t\tinnings.push( PULSE.CLIENT.CRICKET.Util.getInningsScore( inning.runs, inning.wkts, inning.allOut, inning.declared, flip ) );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn innings;\n}"},"getMatchState":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"matchData"}]},"Source":"PULSE.CLIENT.CRICKET.Util.getMatchState = function( matchData )\n{\n\tvar scoringData = matchData.scoringData;\n\tvar scheduleData = matchData.scheduleData;\n\n\tif( scoringData )\n\t{\n\t\tvar matchState = '';\n\n\t\tswitch( scoringData.currentState.phase )\n\t\t{\n\t\t\tcase 'E':\n\t\t\tcase 'U':\n\t\t\t\tmatchState = 'U';\n\t\t\t\tbreak;\n\t\t\tcase 'C':\n\t\t\tcase 'O':\n\t\t\t\tmatchState = 'C';\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tmatchState = 'L';\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn matchState;\n\t}\n\telse if( scheduleData )\n\t{\n\t\tif( PULSE.CLIENT.DateUtil && PULSE.CLIENT.DateUtil.parseDateTime )\n\t\t{\n\t\t\tvar matchDate \t= scheduleData.matchDate,\n\t\t\tdate \t\t= PULSE.CLIENT.DateUtil.parseDateTime( matchDate ),\n\t\t\tnow  \t\t= new Date();\n\n\t\t\tif( date && date - now > 0 )\n\t\t\t{\n\t\t\t\treturn \"U\";\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn scheduleData.matchState;\n\t}\n}"},"getOverProgress":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"index"},{"title":"param","description":null,"type":null,"name":"matchData"}]},"Source":"PULSE.CLIENT.CRICKET.Util.getOverProgress = function( index, matchData )\n{\n\tvar scoringData = matchData.scoringData;\n\tvar scheduleData = matchData.scheduleData;\n\tvar overProgress = '';\n\n\t//if scoring data exists, it takes precedence\n\tif( scoringData && scoringData.innings )\n\t{\n\t\tvar battingOrder= scoringData.matchInfo.battingOrder,\n\t\t\tcii \t\t= scoringData.currentState.currentInningsIndex,\n\t\t\tinning\t\t= PULSE.CLIENT.CRICKET.Util.getTeamLatestInnings( scoringData.innings, battingOrder, index ),\n\t\t\tbatting \t= PULSE.CLIENT.CRICKET.Util.teamIsBatting( index, matchData ),\n\t\t\tlimited\t\t= scoringData.matchInfo.isLimitedOvers,\n\t\t\tmatchType\t= scoringData.matchInfo.matchType,\n\t\t\tmaxOvers\t= matchType === 'ODI' ? 50 : 20;\n\n\t\tif( inning && inning.overProgress )\n\t\t{\n\t\t\tif( limited )\n\t\t\t{\n\t\t\t\toverProgress = inning.overProgress + '/' + ( inning.rodl ? inning.rodl.overs : maxOvers );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//for unlimited overs only add over progress if team is batting\n\t\t\t\t//this means also checking if an innings has started but no innings object exists for it\n\t\t\t\tif(  scoringData.matchInfo.matchState !== 'L' || batting )\n\t\t\t\t{\n\t\t\t\t\tif( scoringData.innings.length < ( cii + 1 ) && batting )\n\t\t\t\t\t{\n\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\toverProgress = inning.overProgress;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\telse if( scheduleData && scheduleData['team' + ( index + 1 ) ] && scheduleData['team' + ( index + 1 ) ].innings )\n\t{\n\t\tvar innings \t= scheduleData['team' + ( index + 1 )].innings,\n\t\t\tinning \t\t= innings[ innings.length - 1 ],\n\t\t\toverFraction= PULSE.CLIENT.CRICKET.Utils.getFakeOversFraction( inning ),\n\t\t\toversLimit  = inning.maxBalls ? PULSE.CLIENT.CRICKET.Util.getFakeOversFraction( { ballsFaced: inning.maxBalls } ) : undefined,\n\t\t\tmatchType\t= scheduleData.matchType,\n\t\t\tmaxOvers\t= matchType === 'ODI' ? 50 : 20,\n\t\t\tlimited\t\t= matchType === 'TEST' ? false : true;\n\t\t\t\n\t\tif( inning && overFraction )\n\t\t{\n\t\t\tif( limited )\n\t\t\t{\n\t\t\t\toverProgress = overFraction + '/' + ( oversLimit || maxOvers );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\toverProgress = overFraction;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn overProgress;\n}"},"getTeamAbbr":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"index"},{"title":"param","description":null,"type":null,"name":"matchData"},{"title":"param","description":null,"type":null,"name":"defaultString"}]},"Source":"PULSE.CLIENT.CRICKET.Util.getTeamAbbr = function( index, matchData, defaultString )\n{\n\tvar scoringData = matchData.scoringData;\n\tvar scheduleData = matchData.scheduleData;\n\n\tvar abbr \t\t= defaultString || 'TBD',\n\t\tteamNumber \t= 'team' + ( index + 1 );\n\n\tif( scoringData && scoringData.matchInfo && scoringData.matchInfo.teams )\n\t{\n\t\tvar team = scoringData.matchInfo.teams[index];\n\n\t\tabbr = team && team.team ? team.team.abbreviation : 'TBD';\n\t}\n\telse if( scheduleData && scheduleData[teamNumber] && scheduleData[teamNumber].team )\n\t{\n\t\tabbr = scheduleData[teamNumber].team.abbreviation;\n\t}\n\n\treturn abbr;\n}"},"getTeamId":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"index"},{"title":"param","description":null,"type":null,"name":"matchData"}]},"Source":"PULSE.CLIENT.CRICKET.Util.getTeamId = function( index, matchData )\n{\n\tvar scoringData = matchData.scoringData;\n\tvar scheduleData = matchData.scheduleData;\n\n\tvar id = -1,\n\t\tteamNumber \t= 'team' + ( index + 1 );\n\t\n\tif( scoringData && scoringData.matchInfo && scoringData.matchInfo.teams )\n\t{\n\t\tvar team = scoringData.matchInfo.teams[index];\n\n\t\tid = team && team.team ? team.team.id : -1;\n\t}\n\telse if( scheduleData && scheduleData[teamNumber] && scheduleData[teamNumber].team )\n\t{\n\t\tid = scheduleData[teamNumber].team.id;\n\t}\n\n\treturn id;\n}"},"getTeamFullName":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"index"},{"title":"param","description":null,"type":null,"name":"matchData"},{"title":"param","description":null,"type":null,"name":"defaultString"}]},"Source":"PULSE.CLIENT.CRICKET.Util.getTeamFullName = function( index, matchData, defaultString )\n{\n\tvar scoringData = matchData.scoringData;\n\tvar scheduleData = matchData.scheduleData;\n\n\tvar fullName \t= defaultString || 'TBD',\n\t\tteamNumber \t= 'team' + ( index + 1 );\n\n\tif( scoringData && scoringData.matchInfo && scoringData.matchInfo.teams )\n\t{\n\t\tvar team = scoringData.matchInfo.teams[index];\n\n\t\tfullName = team && team.team ? team.team.fullName : 'TBD';\n\t}\n\telse if( scheduleData && scheduleData[teamNumber] && scheduleData[teamNumber].team )\n\t{\n\t\tfullName = scheduleData[teamNumber].team.fullName;\n\t}\n\n\treturn fullName;\n}"},"getTeamShortName":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"index"},{"title":"param","description":null,"type":null,"name":"matchData"},{"title":"param","description":null,"type":null,"name":"defaultString"}]},"Source":"PULSE.CLIENT.CRICKET.Util.getTeamShortName = function( index, matchData, defaultString )\n{\n\tvar scoringData = matchData.scoringData;\n\tvar scheduleData = matchData.scheduleData;\n\n\tvar shortName \t= defaultString || 'TBD',\n\t\tteamNumber \t= 'team' + ( index + 1 );\n\n\tif( scoringData && scoringData.matchInfo && scoringData.matchInfo.teams )\n\t{\n\t\tvar team = scoringData.matchInfo.teams[index];\n\n\t\tshortName = team && team.team ? team.team.shortName : 'TBD';\n\t}\n\telse if( scheduleData && scheduleData[teamNumber] && scheduleData[teamNumber].team )\n\t{\n\t\tshortName = scheduleData[teamNumber].team.shortName;\n\t}\n\n\treturn shortName;\n}"},"teamIsBatting":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"index"},{"title":"param","description":null,"type":null,"name":"matchData"}]},"Source":"PULSE.CLIENT.CRICKET.Util.teamIsBatting = function( index, matchData )\n{\n\tvar scoringData = matchData.scoringData;\n\tvar scheduleData = matchData.scheduleData;\n\n\t//only determined via scoring data\n\t//(schedule doesn't contain enough info)\n\tif( scoringData && scoringData.matchInfo.battingOrder )\n\t{\n\t\tvar cii\t\t\t= scoringData.currentState.currentInningsIndex,\n\t\t\tinProgress\t= scoringData.currentState.inProgress,\n\t\t\tbattingOrder= scoringData.matchInfo.battingOrder,\n\t\t\tbattingIdx\t= battingOrder[cii];\n\n\t\treturn ( inProgress && battingIdx === index );\n\t}\n}"},"teamIsBowling":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"index"},{"title":"param","description":null,"type":null,"name":"matchData"}]},"Source":"PULSE.CLIENT.CRICKET.Util.teamIsBowling = function( index, matchData )\n{\n\tvar scoringData = matchData.scoringData;\n\tvar scheduleData = matchData.scheduleData;\n\n\t//only deermined via scoring data\n\t//(schedule doesn't contain enough info)\n\tif( scoringData && scoringData.matchInfo.battingOrder )\n\t{\n\t\tvar cii\t\t\t= scoringData.currentState.currentInningsIndex,\n\t\t\tinProgress\t= scoringData.currentState.inProgress,\n\t\t\tbattingOrder= scoringData.matchInfo.battingOrder,\n\t\t\tbattingIdx\t= battingOrder[cii],\n\t\t\tbowlingIdx\t= battingIdx === 0 ? 1 : 0;\n\n\t\treturn ( inProgress && bowlingIdx === index );\n\t}\n}"}},"GroupStandingsViewModel":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"PULSE.CLIENT.CRICKET.GroupStandingsViewModel"}]},"Source":"PULSE.CLIENT.CRICKET.GroupStandingsViewModel = function()\n{\n\tvar that \t\t= this;\n\t\n\tthat.isFirst\t= true;\n}","prototype":{"onData":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"data"}]},"Source":"PULSE.CLIENT.CRICKET.GroupStandingsViewModel.prototype.onData = function( data )\n{\n\tif( !this.tournamentId.name() )\n\t{\n\t\t//populate tournamentId information\n\t\tthis.tournamentId.name( data.tournamentId.name );\n\t\tthis.tournamentId.id( data.tournamentId.id );\n\t}\n\t\n\tthis.populateStandings( data );\n}"},"populateStandings":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"data"}]},"Source":"PULSE.CLIENT.CRICKET.GroupStandingsViewModel.prototype.populateStandings = function( data )\n{\n\tvar that = this;\n\tif (   data \n\t\t&& data.tournamentId.name === that.tournamentId.name()\n\t\t&& data.groups \n\t\t&& data.groups.length > 0 )\n\t{\n\t\t//add / update all standings found in the JSON\n\t\tfor( var i = 0; i < data.groups.length; i++ )\n\t\t{\n\t\t\tvar group = data.groups[i];\n\t\t\t\n\t\t\tthat.setGroup( i );\n\t\t\t\n\t\t\tfor( var j = 0; j < group.standings.length; j++ )\n\t\t\t{\n\t\t\t\tvar standing = group.standings[j];\n\t\t\t\tthat.setStanding( standing, i, j );\n\t\t\t}\n\t\t\t\n\t\t\t//find / remove any standings that have since been removed\n\t\t\tthat.removeDeleted( data.groups[i].standings, i );\n\t\t}\n\t\t\n\t}\n}"},"setGroup":{"Documentation":{"description":"sets either the pre-existing team object or a new instance of Standing","tags":[]},"Source":"PULSE.CLIENT.CRICKET.GroupStandingsViewModel.prototype.setGroup = function( i )\n{\n\tvar that = this;\n\t\n\tif( !that.groups().length > i )\n\t{\n\t\tthat.groups.push( { standings: ko.observableArray( [] ) } );\n\t}\n}"},"setStanding":{"Documentation":{"description":"sets either the pre-existing team object or a new instance of Standing","tags":[]},"Source":"PULSE.CLIENT.CRICKET.GroupStandingsViewModel.prototype.setStanding = function( data, i, j )\n{\n\tvar that = this;\n\t\n\tif( that.groups()[i].standings().length > j )\n\t{\n\t\tthat.groups()[i].standings()[j].populate( data );\n\t}\n\telse\n\t{\n\t\tthat.groups()[i].standings.push( new that.Standing( data, that ) );\n\t}\n}"},"removeDeleted":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"standings"},{"title":"param","description":null,"type":null,"name":"i"}]},"Source":"PULSE.CLIENT.CRICKET.GroupStandingsViewModel.prototype.removeDeleted = function( standings, i )\n{\n\tvar that \t= this,\n\t\tdiff \t= that.groups()[i].standings().length - standings.length;\n\t\n\t//if the model has more objects than the data, remove the last ones\n\tif( diff > 0 )\n\t{\n\t\tthat.groups()[i].standings.splice( that.groups()[i].standings().length - diff );\n\t}\n}"},"Standing":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"standing"},{"title":"param","description":null,"type":null,"name":"parent"}]},"Source":"PULSE.CLIENT.CRICKET.GroupStandingsViewModel.prototype.Standing = function( standing, parent )\n{\n\tvar that = this;\n\t\n\tthat.position \t= ko.observable('');\n\tthat.points \t= ko.observable('');\n\tthat.team \t\t= \n\t{\n\t\tabbreviation\t: ko.observable(''),\n\t\tfullname\t\t: ko.observable(''),\n\t\tshortname\t\t: ko.observable(''),\n\t\tprimaryColor\t: ko.observable(''),\n\t\tsecondaryColor\t: ko.observable(''),\n\t\tid\t\t\t\t: ko.observable('')\n\t};\n\t\n\t//custom IPLT20 observables\n\t\n\tthat.team.teamUrl = ko.computed( function()\n\t{\n\t\tvar fullname = that.team.fullname();\n\t\treturn PULSE.CLIENT.IPLT20.Common.getTeamURL( fullname );\n\t} );\n\t\n\tthat.team.teamClass = ko.computed( function()\n\t{\n\t\tvar abbr = that.team.abbreviation().toLowerCase();\n\t\treturn 'tLogo16x30 ' + abbr;\n\t} );\n\t\n\tthat.team.imageUrl = ko.computed( function()\n\t{\n\t\treturn PULSE.CLIENT.IPLT20.Common.makeImgUrl( 'resource/i/css-support/trans.png' );\n\t} );\n\t\n\tthat.team.hasQualified = ko.computed( function()\n\t{\n\t\tvar abbr \t\t= that.team.abbreviation(),\n\t\t\tseasonName \t= parent.tournamentId.name();\n\t\t\n\t\treturn PULSE.CLIENT.IPLT20.Common.hasQualified( seasonName, that.team.abbreviation() );\n\t} );\n\t\n\tthat.team.hasQualifiedText = ko.computed( function()\n\t{\n\t\tvar hasQualified = that.team.hasQualified();\n\t\treturn hasQualified ? 'Q' : that.position();\n\t} );\n\n\tthat.team.inCurrentSeason = ko.computed( function()\n\t{\n\t\tvar abbr = that.team.abbreviation();\n\t\treturn  PULSE.CLIENT.IPLT20.Common.teamInCurrentSeason( abbr );\n\t} );\n\t\n\t//end - custom IPLT20 observables\n\t\n\tthat.played \t\t\t= ko.observable('');\n\tthat.won \t\t\t\t= ko.observable('');\n\tthat.lost \t\t\t\t= ko.observable('');\n\tthat.tied \t\t\t\t= ko.observable('');\n\tthat.noresult \t\t\t= ko.observable('');\n\tthat.netrunrate \t\t= ko.observable('');\n\tthat.totalRunsFor \t\t= ko.observable('');\n\tthat.totalRunsAgainst \t= ko.observable('');\n\tthat.totalBallsFor \t\t= ko.observable('');\n\tthat.totalBallsAgainst \t= ko.observable('');\n\t\n\tthat.totalFor\t= ko.computed( function()\n\t{\n\t\tvar runsFor = that.totalRunsFor(),\n\t\t\tballsFor= that.totalBallsFor();\n\t\t\n\t\treturn runsFor ? runsFor + '/' + ( PULSE.CLIENT.CRICKET.Util.convertBallsToOvers( ballsFor ) ) : \"\";\n\t} );\n\t\n\tthat.totalAgainst= ko.computed( function()\n\t{\n\t\tvar runsAgainst = that.totalRunsAgainst(),\n\t\t\tballsAgainst= that.totalBallsAgainst();\n\t\t\n\t\treturn runsAgainst ? runsAgainst + '/' + ( PULSE.CLIENT.CRICKET.Util.convertBallsToOvers( ballsAgainst ) ) : \"\";\n\t} );\n\n\tthat.recentForm \t= ko.observableArray([]);\n\t\n\tthat.recentFormFive = ko.computed( function()\n\t{\n\t\tvar recentForm \t= that.recentForm(),\n\t\t\tfiltered\t= [],\n\t\t\ti\t\t\t= recentForm.length;\n\t\t\n\t\twhile( i-- )\n\t\t{\n\t\t\tif( recentForm.length - i > 5)break;\n\t\t\t\n\t\t\tfiltered.push( recentForm[i] );\n\t\t}\n\t\t\n\t\treturn filtered;\n\t} );\n\t\n\tif( standing )\n\t{\n\t\tthat.populate( standing );\n\t}\n}","prototype":{"populate":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"standing"}]},"Source":"PULSE.CLIENT.CRICKET.GroupStandingsViewModel.prototype.Standing.prototype.populate = function( standing )\n{\n\tvar that = this;\n\tthat.position( standing.position || '' );\n\tthat.points( standing.points || '0' );\n\t\n\tthat.team.abbreviation( standing.team.abbreviation || '' );\n\tthat.team.fullname( standing.team.fullname || '' );\n\tthat.team.shortname( standing.team.shortname || '' );\n\tthat.team.primaryColor( standing.team.primaryColor || '' );\n\tthat.team.secondaryColor( standing.team.secondaryColor || '' );\n\tthat.team.id( standing.team.id || '' );\n\t\n\tthat.played( standing.played || '0' );\n\tthat.won( standing.won || '0' );\n\tthat.lost( standing.lost || '0' );\n\tthat.tied( standing.tied || '0' );\n\tthat.noresult( standing.noresult || '0' );\n\tthat.netrunrate( standing.netrunrate || '0.000' );\n\tthat.totalRunsFor( standing.totalRunsFor || '0' );\n\tthat.totalRunsAgainst( standing.totalRunsAgainst || '0' );\n\tthat.totalBallsFor( standing.totalBallsFor || '0' );\n\tthat.totalBallsAgainst( standing.totalBallsAgainst || '0' );\n\t\n\t//takes recent form\n\tfor( var i = 0; i < standing.recentForm.length; i++ )\n\t{\n\t\tvar recent = standing.recentForm[i];\n\t\tthat.setForm( recent, i );\n\t}\n\n\t//find / remove any standings that have since been removed\n\tthat.removeDeleted( standing.recentForm );\n}"},"setForm":{"Documentation":{"description":"Adds / updates the recentForm","tags":[]},"Source":"PULSE.CLIENT.CRICKET.GroupStandingsViewModel.prototype.Standing.prototype.setForm = function( data, i )\n{\n\tvar that = this;\n\t\n\tif( that.recentForm().length > i )\n\t{\n\t\tthat.recentForm()[i].update( data );\n\t}\n\telse\n\t{\n\t\tthat.recentForm.push( new that.Form( data ) );\n\t}\n}"},"removeDeleted":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"recentForm"}]},"Source":"PULSE.CLIENT.CRICKET.GroupStandingsViewModel.prototype.Standing.prototype.removeDeleted = function( recentForm )\n{\n\tvar that \t= this,\n\t\tdiff \t= that.recentForm().length - recentForm.length;\n\t\n\t//if the model has more objects than the data, remove the last ones\n\tif( diff > 0 )\n\t{\n\t\tthat.recentForm.splice( that.recentForm().length - diff );\n\t}\n}"},"Form":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"data"}]},"Source":"PULSE.CLIENT.CRICKET.GroupStandingsViewModel.prototype.Standing.prototype.Form = function( data )\n{\n\tvar that = this;\n\t\n\tthat.update( data );\n\t\n\tthat.outcomeClass = ko.computed( function()\n\t{\n\t\tswitch( that.outcome )\n\t\t{\n\t\t\tcase \"T\":\n\t\t\t\treturn \"tie\";\n\t\t\tcase \"W\":\n\t\t\t\treturn \"win\";\n\t\t\tcase \"L\":\n\t\t\t\treturn \"lose\";\n\t\t\tdefault:\n\t\t\t\treturn \"\";\n\t\t}\n\t} );\n}","prototype":{"update":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"data"}]},"Source":"PULSE.CLIENT.CRICKET.GroupStandingsViewModel.prototype.Standing.prototype.Form.prototype.update = function( data )\n{\n\tvar that = this;\n\t\n\tfor( d in data )\n\t{\n\t\tthat[d] = data[d];\n\t}\n}"}}}}},"update":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"data"}]},"Source":"PULSE.CLIENT.CRICKET.GroupStandingsViewModel.prototype.update = function( data )\n{\n\tvar that = this;\n\t\n\tko.mapping.fromJS( data, PULSE.CLIENT.CRICKET.GroupStandingsMapping, that );\n\n\tif( that.isFirst )\n\t{\n\t\t//ipl specific observables\n\t\t\n\t\tthat.iplSeasonText = ko.computed( function()\n\t\t{\n\t\t\tvar name = that.tournamentId.name();\n\t\t\t\n\t\t\tswitch( name )\n\t\t\t{\n\t\t\t\tcase \"ipl2012\":\n\t\t\t\t\treturn \"All teams play 16 matches. Top 4 advance to Play-offs.\";\n\t\t\t\tdefault:\n\t\t\t\t\treturn \"\";\n\t\t\t}\n\t\t} );\n\n\t\tthat.seasonYear = ko.computed( function()\n\t\t{\n\t\t\tvar seasonName = that.tournamentId.name(),\n\t\t\t\tseasonYear = PULSE.CLIENT.IPLT20.Common.getSeasonYearFromSeasonName( seasonName );\n\t\t\treturn seasonYear;\n\t\t} );\n\t\t\n\t\tthat.iplStatsPageUrl = ko.computed( function()\n\t\t{\n\t\t\tvar seasonYear = that.seasonYear();\n\t\t\treturn \"/stats/\" + seasonYear;\n\t\t} );\n\t\t\n\t\t//end - ipl specific observables\n\t\t\n\t\tthat.isFirst = false;\n\t}\n}"}}},"MatchScheduleViewModel":{"prototype":{"addFilter":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"PULSE.CLIENT.CRICKET.MatchScheduleViewModel.prototype.addFilter"}]},"Source":"PULSE.CLIENT.CRICKET.MatchScheduleViewModel.prototype.addFilter = function()\n{\n\tvar that = this;\n\t\n\tif( !that.filter )\n\t{\n\t\t//TODO: extract into a filter subclass\n\t\tthat.filter =\n\t\t{\n\t\t\tteamId: ko.observable( '' ),\n\t\t\tteamsFilterOpen : ko.observable( false ),\n\t\t\tvenueId: ko.observable( '' ),\n\t\t\tvenueFilterOpen : ko.observable( false )\n\t\t}\n\t\t\n\t\tthat.filter.filteredResults = ko.computed( function ()\n\t\t{\n\t\t\tvar filteredData= [],\n\t\t\t\tteamId \t\t= that.filter.teamId(),\n\t\t\t\tvenueId \t= that.filter.venueId(),\n\t\t\t\ti \t\t\t= that.schedule().length;\n\t\t\t\n\t\t\twhile ( i-- ) \n\t\t\t{\n\t\t\t\tvar ms = that.schedule()[i];\n\t\t\t\tif ( ms.matchState() === 'C' )\n\t\t\t\t{\n\t\t\t\t\tif ( ( !teamId || \n\t\t\t\t\t\t\t( ms.team1.team.id() === +teamId ) || \n\t\t\t\t\t\t\t( ms.team2.team.id() === +teamId ) ) &&\n\t\t\t\t\t\t ( !venueId || ( ms.venue.id() === venueId  ) ) )\n\t\t\t\t\t{\n\t\t\t\t\t\tfilteredData.push( ms );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn filteredData;\n\t\t} );\n\n\t\tthat.filter.filteredSchedule = ko.computed( function ()\n\t\t{\n\t\t\tvar filteredData= [],\n\t\t\t\tteamId \t\t= that.filter.teamId(),\n\t\t\t\tvenueId \t= that.filter.venueId(),\n\t\t\t\tsLength \t= that.schedule().length;\n\t\t\t\n\t\t\tfor ( var i = 0; i < sLength; i++ ) \n\t\t\t{\n\t\t\t\tvar ms = that.schedule()[i];\n\t\t\t\tif ( ms.matchState() === 'U' || ms.matchState() === 'L' )\n\t\t\t\t{\n\t\t\t\t\tif ( ( !teamId || \n\t\t\t\t\t\t\t( ms.team1.team.id() === +teamId ) || \n\t\t\t\t\t\t\t( ms.team2.team.id() === +teamId ) ) &&\n\t\t\t\t\t\t ( !venueId || ( ms.venue.id() === venueId  ) ) )\n\t\t\t\t\t{\n\t\t\t\t\t\tfilteredData.push( ms );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn filteredData;\n\t\t} );\n\t\t\n\t\tthat.filter.getAllTeams = ko.computed( function ()\n\t\t{\n\t\t\tvar teams \t= [],\n\t\t\t\tschedule= that.schedule();\n\t\t\t\t\n\t\t\tvar idIsInTeams = function( id )\n\t\t\t{\n\t\t\t\tfor ( var i = 0; i < teams.length; i++ ) \n\t\t\t\t{\n\t\t\t\t\tvar team = teams[i];\n\t\t\t\t\tif( team.id() === id )return true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor ( var i = 0; i < schedule.length; i++ ) \n\t\t\t{\n\t\t\t\tvar team1 = schedule[i].team1;\n\t\t\t\tvar team2 = schedule[i].team2;\n\t\t\t\t\n\t\t\t\tif ( team1.team.id() )\n\t\t\t\t{\n\t\t\t\t\tif ( !idIsInTeams( team1.team.id() ) )\n\t\t\t\t\t{\n\t\t\t\t\t\tteams.push( team1.team );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( team2.team.id() )\n\t\t\t\t{\n\t\t\t\t\tif ( !idIsInTeams( team2.team.id() ) )\n\t\t\t\t\t{\n\t\t\t\t\t\tteams.push( team2.team );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// Sort teams array ( by abbreviation ) alphabetically\n\t\t\tteams.sort( function(a, b) \n\t\t\t{\n\t\t        var abbrA = a.abbreviation().toLowerCase(), abbrB = b.abbreviation().toLowerCase();\n\t\t        if ( abbrA < abbrB ) //sort abbreviation ascending\n\t\t        {\n\t\t        \treturn -1;\n\t\t        }\n\t\t        if ( abbrA > abbrB )\n\t\t        {\n\t\t            return 1;\n\t\t        }        \n\t\t        return 0; //default return value (no sorting)\n\t\t    });\n\t\t\t\n\t\t\treturn teams;\n\t\t} );\n\t\t\n\t\tthat.filter.getAllVenues = function ()\n\t\t{\n\t\t\tvar venues \t= [],\n\t\t\t\tschedule= that.schedule();\n\n\t\t\tvar idIsInVenues = function( id )\n\t\t\t{\n\t\t\t\tfor ( var i = 0; i < venues.length; i++ ) \n\t\t\t\t{\n\t\t\t\t\tvar venue = venues[i];\n\t\t\t\t\tif( venue.id() === id )return true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor ( var i = 0; i < schedule.length; i++ ) \n\t\t\t{\n\t\t\t\tvar venue = schedule[i].venue;\n\t\t\t\t\n\t\t\t\tif ( venue )\n\t\t\t\t{\n\t\t\t\t\tif ( !idIsInVenues( venue.id() ) )\n\t\t\t\t\t{\n\t\t\t\t\t\tvenues.push( venue );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// Sort venues ( by city ) array alphabetically \n\t\t\tvenues.sort( function(a, b) \n\t\t\t{\n\t\t        var cityA = a.city().toLowerCase(), cityB = b.city().toLowerCase();\n\t\t        if ( cityA < cityB ) //sort city ascending\n\t\t        {\n\t\t        \treturn -1;\n\t\t        }\n\t\t        if ( cityA > cityB )\n\t\t        {\n\t\t            return 1;\n\t\t        }        \n\t\t        return 0; //default return value (no sorting)\n\t\t    });\n\t\t\t\n\t\t\treturn venues;\n\t\t};\n\t\t\n\t\tthat.filter.allTeamsDD = ko.computed( function ()\n\t\t{\n\t\t\t//add a temporary team to the all teams list\n\t\t\tvar allTeams= new PULSE.CLIENT.CRICKET.MatchScheduleViewModel.Team( that ),\n\t\t\t\tteams\t= that.filter.getAllTeams();\n\t\t\t\n\t\t\tallTeams.populate( { id: '', abbreviation: 'All Teams' } )\n\t\t\t\n\t\t\tteams.unshift( allTeams );\n\t\t\t\n\t\t\treturn teams;\n\t\t} );\n\n\t\tthat.filter.allVenuesDD = ko.computed( function ()\n\t\t{\n\t\t\t//add a temporary team to the all teams list\n\t\t\tvar allVenues\t= new PULSE.CLIENT.CRICKET.MatchScheduleViewModel.Venue( that ),\n\t\t\t\tvenues\t\t= that.filter.getAllVenues();\n\t\t\t\n\t\t\tallVenues.populate( { id:'', city:'All Venues' } )\n\t\t\t\n\t\t\tvenues.unshift( allVenues );\n\t\t\t\n\t\t\treturn venues;\n\t\t} );\n\n\t\tthat.filter.teamById = function ( id )\n\t\t{\n\t\t\tvar schedule = that.schedule();\n\t\t\t\n\t\t\tfor ( var i = 0; i < schedule.length; i++ ) \n\t\t\t{\n\t\t\t\tvar team1 = schedule[i].team1;\n\t\t\t\tvar team2 = schedule[i].team2;\n\t\t\t\t\n\t\t\t\tif ( team1.team.id() === id )\n\t\t\t\t{\n\t\t\t\t\treturn team1.team;\n\t\t\t\t}\n\n\t\t\t\tif ( team2.team.id() === id )\n\t\t\t\t{\n\t\t\t\t\treturn team2.team;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tthat.filter.venueById = function ( id )\n\t\t{\n\t\t\tvar schedule = that.schedule();\n\t\t\t\n\t\t\tfor ( var i = 0; i < schedule.length; i++ ) \n\t\t\t{\n\t\t\t\tvar venue = schedule[i].venue;\n\t\t\t\t\n\t\t\t\tif ( venue.id() === id )\n\t\t\t\t{\n\t\t\t\t\treturn venue;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\t\n\t\tthat.filter.selectedTeamAbbr = ko.computed( function ()\n\t\t{\n\t\t\tvar teamId \t= that.filter.teamId(),\n\t\t\t\tteam\t= that.filter.teamById( teamId );\n\t\t\t\n\t\t\tif( team )\n\t\t\t{\n\t\t\t\treturn team.abbreviation();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn 'All Teams';\n\t\t\t}\n\t\t} );\n\n\t\tthat.filter.selectedVenue = ko.computed( function ()\n\t\t{\n\t\t\tvar venueId = that.filter.venueId(),\n\t\t\t\tvenue\t= that.filter.venueById( venueId );\n\t\t\n\t\t\tif( venue )\n\t\t\t{\n\t\t\t\treturn venue.city();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn 'All Venues';\n\t\t\t}\n\t\t} );\n\t\t\n\t\tthat.filter.teamsFilterClass = ko.computed( function()\n\t\t{\n\t\t\tvar teamsFilterOpen = that.filter.teamsFilterOpen();\n\t\t\t\n\t\t\treturn 'filterCntr' + ( teamsFilterOpen ? ' open' : '' );\n\t\t} );\n\n\t\tthat.filter.venueFilterClass = ko.computed( function()\n\t\t{\n\t\t\tvar venueFilterOpen = that.filter.venueFilterOpen();\n\t\t\t\n\t\t\treturn 'filterCntr' + ( venueFilterOpen ? ' open' : '' );\n\t\t} );\n\t\t\n\t\tthat.filter.toggleTeams = function( d, e )\n\t\t{\n\t\t\tthat.filter.teamsFilterOpen( !that.filter.teamsFilterOpen() );\n\t\t\t\n\t\t\tif( that.filter.venueFilterOpen() )\n\t\t\t{\n\t\t\t\tthat.filter.venueFilterOpen( false );\n\t\t\t}\n\t\t}\n\n\t\tthat.filter.toggleVenue = function( d, e )\n\t\t{\n\t\t\tthat.filter.venueFilterOpen( !that.filter.venueFilterOpen() );\n\n\t\t\tif( that.filter.teamsFilterOpen() )\n\t\t\t{\n\t\t\t\tthat.filter.teamsFilterOpen( false );\n\t\t\t}\n\t\t}\n\t\t\n\t\tthat.filter.filterTeams = function( d, e )\n\t\t{\n\t\t\tthat.filter.teamId( d.id() );\n\t\t\t\n\t\t\tthat.filter.toggleTeams();\n\t\t}\n\n\t\tthat.filter.filterVenues = function( d, e )\n\t\t{\n\t\t\tthat.filter.venueId( d.id() );\n\t\t\t\n\t\t\tthat.filter.toggleVenue();\n\t\t}\n\t}\n}"},"onData":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"data"}]},"Source":"PULSE.CLIENT.CRICKET.MatchScheduleViewModel.prototype.onData = function( data )\n{\n\tif( !this.tournamentId.name() )\n\t{\n\t\t//populate tournamentId information\n\t\tthis.tournamentId.name( data.tournamentId.name );\n\t\tthis.tournamentId.id( data.tournamentId.id );\n\t}\n\t\n\tthis.populateSchedule( data );\n}"},"populateSchedule":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"data"}]},"Source":"PULSE.CLIENT.CRICKET.MatchScheduleViewModel.prototype.populateSchedule = function( data )\n{\n\tvar that = this;\n\tif (   data \n\t\t&& data.tournamentId.name === that.tournamentId.name()\n\t\t&& data.schedule.length > 0 )\n\t{\n\t\t//add / update all standings found in the JSON\n\t\t\t\n\t\tfor( var i = 0; i < data.schedule.length; i++ )\n\t\t{\n\t\t\tvar schedule = data.schedule[i];\n\t\t\tthat.setSchedule( schedule, i );\n\t\t}\n\t\t\n\t\t//find / remove any standings that have since been removed\n\t\tthat.removeDeleted( data.schedule );\n\t\t\n\t}\n}"},"setSchedule":{"Documentation":{"description":"sets either the pre-existing team object or a new instance of Standing","tags":[]},"Source":"PULSE.CLIENT.CRICKET.MatchScheduleViewModel.prototype.setSchedule = function( data, i )\n{\n\tvar that = this;\n\t\n\tif( that.schedule().length > i )\n\t{\n\t\tthat.schedule()[i].populate( data );\n\t}\n\telse\n\t{\n\t\tthat.schedule.push( new PULSE.CLIENT.CRICKET.MatchScheduleViewModel.ScheduleEntry( data, that ) );\n\t}\n}"},"removeDeleted":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"schedule"},{"title":"param","description":null,"type":null,"name":"i"}]},"Source":"PULSE.CLIENT.CRICKET.MatchScheduleViewModel.prototype.removeDeleted = function( schedule, i )\n{\n\tvar that \t= this,\n\t\tdiff \t= that.schedule().length - schedule.length;\n\t\n\t//if the model has more objects than the data, remove the last ones\n\tif( diff > 0 )\n\t{\n\t\tthat.schedule().splice( that.schedule().length - diff );\n\t}\n}"}},"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"PULSE.CLIENT.CRICKET.MatchScheduleViewModel"}]},"Source":"PULSE.CLIENT.CRICKET.MatchScheduleViewModel = function()\n{\n\tvar that \t\t\t= this;\n\tthat.schedule \t\t= ko.observableArray( [] );\n\tthat.tournamentId \t= new PULSE.CLIENT.CRICKET.MatchScheduleViewModel.TournamentId();\n\t\n\t//computed\n\tthat.seasonYear = ko.computed( function()\n\t{\n\t\tvar seasonName = that.tournamentId.name(),\n\t\t\tseasonYear = PULSE.CLIENT.IPLT20.Common.getSeasonYearFromSeasonName( seasonName );\n\t\treturn seasonYear;\n\t} );\n\t\n\tthat.matchCentreLink = ko.computed( function()\n\t{\n\t\tvar year = that.seasonYear();\n\t\t\n\t\treturn '/match/' + year + '/';\n\t} );\n\n\t//bindable event listeners\n\tthat.openMatchCentre = function( d, e )\n\t{\n\t\tvar name \t\t\t= d.matchId.name(),\n\t\t\tmatchNumber \t= PULSE.CLIENT.IPLT20.Common.getMatchNumber( name ),\n\t\t\tmatchCentreLink = that.matchCentreLink(),\n\t\t\tmatchUrl \t\t= matchCentreLink + matchNumber;\n\t\t\n\t\twindow.open( matchUrl, 'IPLT20', \n\t\t\t'height=672,width=980,menubar=no,resizable=no,scrollbars=no,status=no,toolbar=no,location=no' ); \n\t};\n}","ScheduleEntry":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"schedule"},{"title":"param","description":null,"type":null,"name":"root"}]},"Source":"PULSE.CLIENT.CRICKET.MatchScheduleViewModel.ScheduleEntry = function( schedule, root )\n{\n\tvar that = this;\n\t\n\tthat.matchState \t\t= ko.observable('');\n\tthat.matchDate \t\t\t= ko.observable('');\n\tthat.description \t\t= ko.observable('');\n\tthat.matchPreviewLink \t= ko.observable('');\n\tthat.photostreamLink \t= ko.observable('');\n\tthat.reportLink \t\t= ko.observable('');\n\tthat.highlightsLink \t= ko.observable('');\n\tthat.matchType\t\t\t= ko.observable('');\n\tthat.matchStatus =\n\t{\n\t\ttext \t: ko.observable(''),\n\t\toutcome : ko.observable('')\n\t}\n\t\n\tthat.matchId = new PULSE.CLIENT.CRICKET.MatchScheduleViewModel.MatchId();\n\t\n\tthat.venue = new PULSE.CLIENT.CRICKET.MatchScheduleViewModel.Venue( root );\n\t\n\tthat.team1 = new PULSE.CLIENT.CRICKET.MatchScheduleViewModel.ScoringSummary( root );\n\tthat.team2 = new PULSE.CLIENT.CRICKET.MatchScheduleViewModel.ScoringSummary( root );\n\n\tthat.isToday = ko.computed( function() {\n\t\t\n\t\tvar mDate\t\t\t= that.matchDate(),\n\t\t\tmatchDate \t\t= PULSE.CLIENT.DateUtil.parseDateTime( mDate ),\n\t\t\tdate \t\t\t= new Date(),\n\t\t\ttmp_matchDate \t= new Date(matchDate.getTime());\n\t\t\n\t\ttmp_matchDate.setHours(0,0,0,0);\n\t\tdate.setHours(0,0,0,0);\n\t\t\n\t\treturn (tmp_matchDate.getTime() === date.getTime());\n\t} );\n\t\n\tif( schedule )\n\t{\n\t\tthat.populate( schedule );\n\t}\n}","prototype":{"populate":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"schedule"}]},"Source":"PULSE.CLIENT.CRICKET.MatchScheduleViewModel.ScheduleEntry.prototype.populate = function( schedule )\n{\n\tvar that = this;\n\tthat.matchState( schedule.matchState );\n\tthat.matchDate( schedule.matchDate );\n\tthat.description( schedule.description || '' );\n\tthat.matchPreviewLink( schedule.matchPreviewLink || '' );\n\tthat.photostreamLink( schedule.photostreamLink || '' );\n\tthat.reportLink( schedule.reportLink || '' );\n\tthat.highlightsLink( schedule.highlightsLink || '' );\n\tthat.matchType( schedule.matchType || '' );\n\t\n\tif( schedule.matchStatus )\n\t{\n\t\tthat.matchStatus.text( schedule.matchStatus.text );\n\t\tthat.matchStatus.outcome( schedule.matchStatus.outcome );\n\t}\n\n\tif( schedule.matchId )\n\t{\n\t\tthat.matchId.populate( schedule.matchId );\n\t}\n\t\n\tif( schedule.venue )\n\t{\n\t\tthat.venue.populate( schedule.venue )\n\t}\n\n\tif( schedule.team1 )\n\t{\n\t\tthat.team1.populate( schedule.team1 );\n\t}\n\t\n\tif( schedule.team2 )\n\t{\n\t\t//team\n\t\tthat.team2.populate( schedule.team2 );\n\t}\n\t\n\t//computed\n\tthat.formattedDateTime = ko.computed( function()\n\t{\n\t\tvar matchDate = that.matchDate();\n\t\t\n\t\treturn PULSE.CLIENT.CRICKET.Util.getFormattedDateTime( matchDate, true );\n\t} );\n\t\n\tthat.formattedVenue = ko.computed( function()\n\t{\n\t\tvar fullName \t= that.venue.fullName(),\n\t\t\tcity\t\t= that.venue.city();\n\t\t\n\t\treturn fullName + ', ' + city;\n\t} );\n\t\n\tthat.matchDetails = ko.computed( function()\n\t{\n\t\tvar formattedDateTime \t= that.formattedDateTime().date,\n\t\t\tformattedVenue\t\t= that.formattedVenue();\n\t\t\n\t\treturn formattedDateTime + ', ' + formattedVenue;\n\t} );\n\n\tthat.scheduleDetails = ko.computed( function()\n\t{\n\t\tvar formattedDateTime \t= that.formattedDateTime();\n\t\t\n\t\treturn formattedDateTime.time + ' ' + formattedDateTime.timezone + ' (' + formattedDateTime.timeIST + ' IST)';\n\t} );\n}"}}},"ScoringSummary":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"root"}]},"Source":"PULSE.CLIENT.CRICKET.MatchScheduleViewModel.ScoringSummary = function( root )\n{\n\tthis.team \t= new PULSE.CLIENT.CRICKET.MatchScheduleViewModel.Team( root );\n\tthis.innings= ko.observableArray( [] );\n}","prototype":{"populate":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"data"}]},"Source":"PULSE.CLIENT.CRICKET.MatchScheduleViewModel.ScoringSummary.prototype.populate = function( data )\n{\n\tthis.team.populate( data.team );\n\t\n\tif( data.innings && data.innings.length )\n\t{\n\t\tvar diff = data.innings.length - this.innings().length;\n\t\t\n\t\tif( diff > 0 )\n\t\t{\n\t\t\tfor( var i = 0; i < diff; i++ )\n\t\t\t{\n\t\t\t\tthis.innings.push( new PULSE.CLIENT.CRICKET.MatchScheduleViewModel.Innings() );\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor( var i = 0; i < data.innings.length; i++ )\n\t\t{\n\t\t\tvar innings = data.innings[i];\n\t\t\tthis.innings()[i].populate( innings );\n\t\t}\n\t}\n}"}}},"TournamentId":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.CLIENT.CRICKET.MatchScheduleViewModel.TournamentId = function()\n{\n\tthis.id \t= ko.observable('');\n\tthis.name \t= ko.observable('');\n}"},"MatchId":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.CLIENT.CRICKET.MatchScheduleViewModel.MatchId = function()\n{\n\tthis.id\t\t\t\t= ko.observable('');\n\tthis.name\t\t\t= ko.observable('');\n\tthis.tournamentId\t= new PULSE.CLIENT.CRICKET.MatchScheduleViewModel.TournamentId();\n}","prototype":{"populate":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"data"}]},"Source":"PULSE.CLIENT.CRICKET.MatchScheduleViewModel.MatchId.prototype.populate = function( data )\n{\n\tthis.id( data.id || '' );\n\tthis.name( data.name || '' );\n\t\n\tif( data.tournamentId )\n\t{\n\t\tthis.tournamentId.id( data.tournamentId.id );\n\t\tthis.tournamentId.name( data.tournamentId.name );\n\t}\n}"}}},"Team":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"root"}]},"Source":"PULSE.CLIENT.CRICKET.MatchScheduleViewModel.Team = function( root )\n{\n\tvar that = this;\n\tthis.abbreviation\t= ko.observable('');\n\tthis.fullname\t\t= ko.observable('');\n\tthis.shortname\t\t= ko.observable('');\n\tthis.primaryColor\t= ko.observable('');\n\tthis.secondaryColor\t= ko.observable('');\n\tthis.id\t\t\t\t= ko.observable('');\n\tthis.root\t\t\t= function() { return root; };\n\t\n\tthat.teamUrl = ko.computed( function()\n\t{\n\t\tvar fullname = that.fullname();\n\t\treturn PULSE.CLIENT.IPLT20.Common.getTeamURL( fullname );\n\t} );\n\t\n\t//TODO: formulate a better way of adding classes, shouldn't be a part of viewmodel\n\t\n\tthat.teamClass = ko.computed( function()\n\t{\n\t\tvar abbr = that.abbreviation().toLowerCase();\n\t\treturn 'tLogo16x30 ' + abbr;\n\t} );\n\n\tthat.logo100Class = ko.computed( function()\n\t{\n\t\tvar abbr = that.abbreviation().toLowerCase();\n\t\treturn 'tLogo100x ' + abbr;\n\t} );\n\t\n\tthat.imageUrl = ko.computed( function()\n\t{\n\t\treturn PULSE.CLIENT.IPLT20.Common.makeImgUrl( 'resource/i/css-support/trans.png' );\n\t} );\n\n\tthat.inCurrentSeason = ko.computed( function()\n\t{\n\t\tvar abbr = that.abbreviation();\n\t\treturn  PULSE.CLIENT.IPLT20.Common.teamInCurrentSeason( abbr );\n\t} );\n\n\tthat.selectedTeam = ko.computed( function()\n\t{\n\t\tvar selectedId \t= that.root().filter.teamId(),\n\t\t\tid\t\t\t= that.id();\n\t\t\n\t\treturn  selectedId === id;\n\t} );\n\n\tthat.selectedTeamClass = ko.computed( function()\n\t{\n\t\tvar selectedTeam \t= that.selectedTeam();\n\t\t\n\t\treturn selectedTeam ? 'selected' : '';\n\t} );\n\n\tthat.ticketUrl = ko.computed( function()\n\t{\n\t\tvar abbreviation \t= that.abbreviation();\n\t\t\n\t\treturn PULSE.CLIENT.IPLT20.Common.getTicketLinkByAbbreviation( abbreviation );\n\t} );\n}","prototype":{"populate":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"team"}]},"Source":"PULSE.CLIENT.CRICKET.MatchScheduleViewModel.Team.prototype.populate = function( team )\n{\n\t//team\n\tthis.id( team.id );\n\tthis.fullname( team.fullname || '');\n\tthis.shortname( team.shortname || '' );\n\tthis.abbreviation( team.abbreviation || '' );\n\tthis.primaryColor( team.primaryColor || '' );\n\tthis.secondaryColor( team.secondaryColor || '' );\n}"}}},"Innings":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.CLIENT.CRICKET.MatchScheduleViewModel.Innings = function()\n{\n\tvar that \t\t\t= this;\n\tthis.allOut \t\t= ko.observable( false );\n\tthis.inningsNumber \t= ko.observable( '' );\n\tthis.ballsFaced \t= ko.observable( '' );\n\tthis.runs \t\t\t= ko.observable( '' );\n\tthis.wkts \t\t\t= ko.observable( '' );\n\t\n\t//TODO: add once implemented\n\t//this.declared = ko.observable( '' );\n\t//TODO: subclass below functionality\n\t\n\tthis.score = ko.computed( function()\n\t{\n\t\tvar runs = that.runs(),\n\t\t\twkts = that.wkts(),\n\t\t\tallOut = that.allOut();\n\t\t\n\t\treturn PULSE.CLIENT.CRICKET.Util.inningsScore( runs, wkts, allOut );\n\t} );\n\t\n\tthis.oversLimit = ko.computed( function()\n\t{\n\t\tvar ballsFaced = that.ballsFaced();\n\t\t\n\t\treturn PULSE.CLIENT.CRICKET.Util.oversLimit( ballsFaced );\n\t} );\n\n\tthis.oversLimitHtml = ko.computed( function()\n\t{\n\t\tvar oversLimit = that.oversLimit();\n\t\t\n\t\treturn '(' + oversLimit + ')';\n\t} );\n\t\n\tthis.resultHtml = ko.computed( function()\n\t{\n\t\tvar score \t\t= that.score(),\n\t\toversLimitHtml \t= that.oversLimitHtml();\n\t\t\n\t\treturn score + '<span>' + oversLimitHtml + '</span>';\n\t} );\n}","prototype":{"populate":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"innings"}]},"Source":"PULSE.CLIENT.CRICKET.MatchScheduleViewModel.Innings.prototype.populate = function( innings )\n{\n\tthis.allOut( !!innings.allOut );\n\tthis.inningsNumber( innings.inningsNumber );\n\tthis.ballsFaced( innings.ballsFaced );\n\tthis.runs( innings.runs );\n\tthis.wkts( innings.wkts );\n}"}}},"Venue":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"root"}]},"Source":"PULSE.CLIENT.CRICKET.MatchScheduleViewModel.Venue = function( root )\n{\n\tvar that\t\t= this;\n\tthis.id\t\t\t= ko.observable('');\n\tthis.fullName\t= ko.observable('');\n\tthis.shortName\t= ko.observable('');\n\tthis.city\t\t= ko.observable('');\n\tthis.country\t= ko.observable('');\n\tthis.root\t\t= function(){ return root; };\n\t\n\tthat.selectedVenue = ko.computed( function()\n\t{\n\t\tvar selectedId \t= that.root().filter.venueId(),\n\t\t\tid\t\t\t= that.id();\n\t\t\n\t\treturn selectedId === id;\n\t} );\n\n\tthat.selectedVenueClass = ko.computed( function()\n\t{\n\t\tvar selectedVenue \t= that.selectedVenue();\n\t\t\n\t\treturn selectedVenue ? 'selected' : '';\n\t} );\n}","prototype":{"populate":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"venue"}]},"Source":"PULSE.CLIENT.CRICKET.MatchScheduleViewModel.Venue.prototype.populate = function( venue )\n{\n\tthis.id( venue.id );\n\tthis.fullName( venue.fullName || '' );\n\tthis.shortName( venue.shortName || '' );\n\tthis.city( venue.city || '' );\n\tthis.country( venue.country || '' );\n}"}}}}},"CometdClient":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"PULSE.CLIENT.CometdClient"}]},"Source":"PULSE.CLIENT.CometdClient = function() {\n\tthis.cometd = $.cometd;\n\tthis._connected = false;\n\tthis._handshake = false;\n\tthis._subscriptions = [];\n\tthis.init();\n\t//Register the unload to envoke the disconnect.\n\t$(window).unload( function() { if (this.cometdClient) { this.cometdClient.disconnect( ); } } );\n}","prototype":{"init":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.CLIENT.CometdClient.prototype.init = function() {\n\t//TODO could externalise the URL?\n\tvar cometURL = \"http://localhost:8082\" + \"/kuiper/cometd\";\n\tthis.cometd.configure({\n\t\turl : cometURL,\n\t\tlogLevel : 'info'\n\t});\n\n\tthis.cometd.addListener('/meta/handshake', this, this._metaHandshake);\n\tthis.cometd.addListener('/meta/connect', this, this._metaConnect);\n\t\n\t// Enable WebSockets\n\tthis.cometd.websocketEnabled = true;\n\tthis.cometd.handshake();\n\t\n}"},"_metaConnect":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"message"}]},"Source":"PULSE.CLIENT.CometdClient.prototype._metaConnect = function(message) {\n\n\tif (this.cometd.isDisconnected()) {\n\t\tthis._connected = false;\n\t\tthis._handshake = false;\n\t\tthis._connectionClosed();\n\t\treturn;\n\t}\n\n\tvar wasConnected = this._connected;\n\n\tthis._connected = message.successful === true;\n\tif (!wasConnected && this._connected) {\n\n\t\tthis._connectionEstablished();\n\n\t} else if (wasConnected && !this._connected) {\n\t\tthis._handshake = false;\n\t\tthis._connectionBroken();\n\t}\n\n}"},"_metaHandshake":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"handshake"}]},"Source":"PULSE.CLIENT.CometdClient.prototype._metaHandshake = function(handshake) {\n\n\tif (handshake.successful === true) {\n\t\t\n\t\tconsole.log('Handshake Successful');\n\t\t\n\t\tthis._handshake = true;\n\t\t\n\t\t// Subscribe to any channels if they exist\n\t\tif (this._subscriptions.length > 0) {\n\t\t\tvar resubscriptions = this._subscriptions;\n\t\t\tthis._subscriptions = [];\n\t\t\tthis.subscribe(resubscriptions);\n\t\t}\n\t}\n}"},"subscribe":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"subscriptions"}]},"Source":"PULSE.CLIENT.CometdClient.prototype.subscribe = function(subscriptions) {\n\t\n\t\tthis.subscriptions = subscriptions;\n\t\t\n\t\tthis.cometd.batch(this, function() {\n\t\t\t\n\t\t\tfor ( var i = 0; i < this.subscriptions.length; i++ ) {\n\t\t\t\t\t\n\t\t\t\t\tvar subscription = this.subscriptions[i];\n\t\t\t\t\tconsole.log('subscribing to : ' + subscription.channel);\n\t\t\t\t\tthis.cometd.subscribe(subscription.channel, subscription.callback);\n\t\t\t\t\t\n\t\t\t\t\t// Keep track of subscriptions so we can re-subscribe if the connection ever breaks\n\t\t\t\t\tthis._subscriptions.push(subscription);\n\t\t\t\t}\n\t\t});\n}"},"_connectionEstablished":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.CLIENT.CometdClient.prototype._connectionEstablished = function() {\n\tconsole.log('Connection Established');\n}"},"_connectionBroken":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.CLIENT.CometdClient.prototype._connectionBroken = function() {\n\tconsole.log('Connection Broken');\n}"},"_connectionClosed":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.CLIENT.CometdClient.prototype._connectionClosed = function() {\n\tconsole.log('Connection Closed');\n}"},"disconnect":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.CLIENT.CometdClient.prototype.disconnect = function() {\n\tthis.cometd.disconnect(true);\n}"}}},"Cookie":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"PULSE.CLIENT.Cookie"},{"title":"param","description":null,"type":null,"name":"c_name"}]},"Source":"PULSE.CLIENT.Cookie = function( c_name )\n{\n\tthis.c_name = c_name || '';\n\tthis.c_value;\n\tthis.ex_minutes = 1 * 60 * 24 * 100; // 100 days by default\n\tthis.json = {};\n\tthis.kojson = {};\t\t\t\t\t//optional - used to convert to and from knockoutjs variables\n}","prototype":{"setName":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"newName"}]},"Source":"PULSE.CLIENT.Cookie.prototype.setName = function( newName )\n{\n\tthis.c_name = newName;\n}"},"setValue":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"newValue"}]},"Source":"PULSE.CLIENT.Cookie.prototype.setValue = function( newValue )\n{\n\tthis.c_value = newValue;\n}"},"setExpireMinutes":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"newValue"}]},"Source":"PULSE.CLIENT.Cookie.prototype.setExpireMinutes = function( newValue )\n{\n\tthis.ex_minutes = newValue;\n}"},"getCookie":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.CLIENT.Cookie.prototype.getCookie = function()\n{\n\tvar c_name = this.c_name;\n\treturn this.getCookieByKey( c_name );\n}"},"setCookie":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.CLIENT.Cookie.prototype.setCookie = function()\n{\n\tvar c_name = this.c_name;\n\tvar value = this.c_value;\n\tvar ex_minutes = this.ex_minutes;\n\tvar extime = new Date( );\n\textime.setTime( extime.getTime( ) + ( ex_minutes * 60 * 1000 ) );\n\tvar c_value = escape( value )\n\t\t\t+ ( ( ex_minutes == null ) ? \"\" : \"; expires=\"\n\t\t\t\t\t+ extime.toUTCString( ) );\n\tdocument.cookie = c_name + \"=\" + c_value;\n}"},"saveJSON":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"object"}]},"Source":"PULSE.CLIENT.Cookie.prototype.saveJSON = function( object )\n{\n\tthis.c_value = $.toJSON( object )\n\tthis.setCookie( );\n}"},"retiveJSON":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.CLIENT.Cookie.prototype.retiveJSON = function( )\n{\n\tvar jsonString = this.getCookie();\n\tif( jsonString )\n\t{\n\t\tthis.json = $.evalJSON( jsonString );\n\t}\n\treturn this.json;\n}"}}},"DataManager":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"PULSE.CLIENT.DataManager"}]},"Source":"PULSE.CLIENT.DataManager = function ()\n{\n\tthis.timers = {};\n\tthis.callbacks = {};\n\tthis.lastdata = {};\n\tthis.savedTargets = {};\n}","prototype":{"addFeed":{"Documentation":{"description":"Note that the interval is in SECONDS, and will be multiplied by 1000 to derive a millisecond\nvalue.","tags":[]},"Source":"PULSE.CLIENT.DataManager.prototype.addFeed = function ( id, url, interval, callback, targets )\n{\n    var currentTargets = this.savedTargets[id] || [];\n    \n\t// Remove any existing feed with this ID\n\tthis.removeFeed( id );\n\n\t// Save the callback name\n\tthis.callbacks[id] = callback;\n    \n    // Add all the targets to the current targets\n    for ( var i = 0, limit = targets.length; i < limit; i++ )\n    {\n        var needToAdd = true;\n        for ( var j = 0, jLimit = currentTargets.length; j < jLimit; j++ )\n        {\n            if ( targets[ i ] === currentTargets[ j ] )\n            {\n                needToAdd = false;\n                break;\n            }\n        }\n        if ( needToAdd )\n        {\n            currentTargets.push( targets[ i ] );\n        }\n    }\n    \n    this.savedTargets[id] = currentTargets;\n\t\n\t// Dynamically create the callback method\n\tvar that = this;\n\twindow[callback] = function ( jsonpData )\n\t{\n\t\tif ( jsonpData )\n\t\t{\n\t\t\tvar payload = jsonpData;\n\t\t\t\n\t\t\t// Serialise the payload\n\t\t\tvar serialised = $.toJSON( payload );\n\t\t    if ( that.lastdata[id] !== serialised )\n\t\t    {\n\t\t    \t// Save the new data\n\t\t    \tthat.lastdata[id] = serialised;\n\t\t\t\t\n\t\t\t\t// Pass the data to all of the targets...\n\t\t\t\tfor ( var t = 0, tlimit = currentTargets.length; t < tlimit; t++ )\n\t\t\t\t{\n\t\t\t\t\t// ...if they are valid\n\t\t\t\t\tvar target = currentTargets[t];\n\t\t\t\t\tif ( target && target.onData )\n\t\t\t\t\t{\n\t\t\t\t\t\ttarget.onData( payload, id );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t    }\n\t\t}\n\t};\n\t\n\t// Create the timer\n\tthis.timers[id] = new PULSE.CLIENT.NewJSONPTimer( url, interval * 1000 );\n}"},"startAll":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.CLIENT.DataManager.prototype.startAll = function ()\n{\n\tfor ( var id in this.timers )\n\t{\n\t\tthis.start( id );\n\t}\n}"},"stopAll":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.CLIENT.DataManager.prototype.stopAll = function ()\n{\n\tfor ( var id in this.timers )\n\t{\n\t\tthis.stop( id );\n\t}\n}"},"start":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"id"}]},"Source":"PULSE.CLIENT.DataManager.prototype.start = function ( id )\n{\n\tif ( this.timers[id] )\n\t{\n\t\tthis.timers[id].start();\n\t}\n}"},"stop":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"id"}]},"Source":"PULSE.CLIENT.DataManager.prototype.stop = function ( id )\n{\n\tif ( this.timers[id] )\n\t{\n\t\tthis.timers[id].stop();\n\t}\n}"},"removeFeed":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"id"}]},"Source":"PULSE.CLIENT.DataManager.prototype.removeFeed = function ( id )\n{\n\tthis.stop( id );\n\t\n\tif ( this.timers[id] )\n\t{\n\t\tthis.timers[id] = undefined;\n\t}\n\t\n\tif ( window[ this.callbacks[id] ] )\n\t{\n\t\twindow[ this.callbacks[id] ] = undefined;\n\t}\n\t\n\tif ( this.lastdata[id] )\n\t{\n\t\tthis.lastdata[id] = undefined;\n\t}\n\t\n\tif ( this.savedTargets[id] )\n\t{\n\t    this.savedTargets[id] = undefined;\n\t}\n}"}}},"DateUtil":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"PULSE.CLIENT.DateUtil"}]},"Source":"PULSE.CLIENT.DateUtil = function()\n{}","parseDateTime":{"Documentation":{"description":"Takes a date string ( supports 'yyyy-mm-dd' & 'yyyy-mm-ddTHH:MM:SS+0100' formats ) as a parameter","tags":[{"title":"param","description":"ISO 8601 date string","type":{"type":"NameExpression","name":"String"},"name":"dateStr"},{"title":"return","description":"JavaScript date object","type":{"type":"NameExpression","name":"Date"}}]},"Source":"PULSE.CLIENT.DateUtil.parseDateTime = function( dateStr )\n{\n    if( !dateStr )\n    {\n        return;\n    }\n\n    var date = new Date( dateStr );\n\n    if( isDateValid( date ) )\n    {\n        return date;\n    }\n    else\n    {\n        var dateTime = dateStr.split('T');\n        if ( dateTime.length === 1 )\n        {\n            return new Date( dateTime[0].replace( /\\-/g, '/' ) );\n        }\n        else if ( dateTime.length === 2 )\n        {\n            // we only want to replace the hyphens of date bit (there might be hypens(minus) as in GMT-0200)\n            var aDate1 = dateTime[0].replace( /\\-/g, '/' );\n            var aDate2 = dateTime[1];\n            var newDate = aDate1 + ' ' + aDate2;\n\n            date = new Date( newDate );\n        }\n\n        if( isDateValid( date ) )\n        {\n            return date;\n        }\n        else\n        {\n            window.console.log( 'Invalid Date String ' + dateStr );\n        }\n    }\n}"},"getMonth":{"Documentation":{"description":"Takes a valid date object and returns the month either full name or partial,\nbased on fullName boolean flag","tags":[]},"Source":"PULSE.CLIENT.DateUtil.getMonth = function( dateObj, fullName )\n{\n    var monthNames = [\n            \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\",\n            \"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\" ];\n\n    var month = dateObj.getMonth();\n\n    if ( fullName )\n    {\n        month = month + PULSE.CLIENT.DateUtil.MONTHS_IN_A_YEAR;\n    }\n\n    return monthNames[ month ];\n}"},"getMonthNumber":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"date"}]},"Source":"PULSE.CLIENT.DateUtil.getMonthNumber = function(date)\n{\n    var month = date.getMonth() + 1;\n\n    if (month < 10) {\n\n        return '0' + month;\n    }\n    return month;\n}"},"getDaysAgo":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"stamp"}]},"Source":"PULSE.CLIENT.DateUtil.getDaysAgo = function(stamp)\n{\n    var timeStamp = parseInt(stamp.toString().replace(/,/g ,'')),\n                dateObject = new Date( timeStamp ),\n                thisDate = new Date(Date.now()),\n                difference = thisDate.getTime() - dateObject.getTime(),\n                diffSecs,\n                diffMins,\n                diffHours,\n                diffDays,\n                timeAgo = '';\n\n            diffSecs =  Math.round(difference / (1000));\n            diffMins = Math.round(difference / (1000 * 60));\n            diffHours = Math.round(difference / (1000 * 3600));\n            diffDays = Math.round(difference / (1000 * 3600 * 24));\n\n            if (diffSecs < 60)\n            {\n                if (diffSecs < 1)\n                {\n                    timeAgo = diffSecs + ' secs ago';\n                }\n                else\n                {\n                    timeAgo = diffSecs + ' sec ago';\n                }\n            }\n            else if (diffMins < 60)\n            {\n                if (diffMins > 1)\n                {\n                    timeAgo = diffMins + ' mins ago';\n                }\n                else\n                {\n                    timeAgo = diffMins  + ' min ago';\n                }\n            }\n            else if (diffHours < 24)\n            {\n                if (diffHours > 1)\n                {\n                    timeAgo = diffHours + ' hours ago';\n                }\n                else\n                {\n                    timeAgo = diffHours + ' hour ago';\n                }\n            }\n            else\n            {\n                if (diffDays > 1)\n                {\n                    timeAgo = diffDays + ' days ago';\n                }\n                else\n                {\n                    timeAgo = diffDays + ' day ago';\n                }\n            }\n\n        return timeAgo;\n}"},"getFullMonthFromShort":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"monthShort"}]},"Source":"PULSE.CLIENT.DateUtil.getFullMonthFromShort = function(monthShort)\n{\n    monthFull = '';\n        switch(monthShort)\n    {\n        case ('Jan'):\n            monthFull = 'January';\n            break;\n        case ('Feb'):\n            monthFull = 'February';\n            break;\n        case ('Mar'):\n            monthFull = 'March';\n            break;\n        case ('Apr'):\n            monthFull = 'April';\n            break;\n        case ('May'):\n            monthFull = 'May';\n            break;\n        case ('Jun'):\n            monthFull = 'June';\n            break;\n        case ('Jul'):\n            monthFull = 'July';\n            break;\n        case ('Aug'):\n            monthFull = 'August';\n            break;\n        case ('Sep'):\n            monthFull = 'September';\n            break;\n        case ('Oct'):\n            monthFull = 'October';\n            break;\n        case ('Nov'):\n            monthFull = 'November';\n            break;\n        case ('Dec'):\n            monthFull = 'December';\n            break;\n        default:\n            monthFull = undefined;\n    }\n\n    return monthFull;\n\n}"},"getWeekDay":{"Documentation":{"description":"Takes a valid date object and returns the week day either full name or partial,\nbased on fullName boolean flag","tags":[]},"Source":"PULSE.CLIENT.DateUtil.getWeekDay = function( dateObj, fullName )\n{\n    var dayNames = [\n            \"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\",\n            \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\" ];\n\n    var day = dateObj.getDay();\n\n    if ( fullName )\n    {\n        day = day + PULSE.CLIENT.DateUtil.DAYS_IN_A_WEEK;\n    }\n\n    return dayNames[ day ];\n}"},"getDayNumber":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"date"}]},"Source":"PULSE.CLIENT.DateUtil.getDayNumber = function(date)\n{\n    var day = date.getDate();\n\n    if (day < 10) {\n\n        return '0' + day;\n    }\n\n    return day;\n}"},"getDate":{"Documentation":{"description":"Takes a valid date object and returns the date with or without suffix,\nbased on withSuffix boolean flag","tags":[]},"Source":"PULSE.CLIENT.DateUtil.getDate = function( dateObj, withSuffix )\n{\n    var d = dateObj.getDate();\n\n    if ( withSuffix )\n    {\n        return d + [\"th\", \"st\", \"nd\", \"rd\"][d % 10 > 3 ? 0 : (d % 100 - d % 10 != 10) * d % 10];\n    }\n\n    return d;\n}"},"calcTimeByOffset":{"Documentation":{"description":"Takes a valid date object and returns the date-time string after taking\ncare of timezone offset","tags":[]},"Source":"PULSE.CLIENT.DateUtil.calcTimeByOffset = function( dateObj, offset )\n{\n    // convert to msec\n    // add local time zone offset\n    // get UTC time in msec\n    var localTime       = dateObj.getTime(),\n        timezoneOffset  = dateObj.getTimezoneOffset() * 60000;\n\n    var utc = localTime + timezoneOffset;\n\n    // create new Date object for different city\n    // using supplied offset\n    var utcDate = new Date ( utc );\n    var convertedDate = new Date( utc + ( 3600000 * offset ) );\n\n    var time = convertedDate.getHours() + ':' + (convertedDate.getMinutes() + '' < '10' ? '0' : '' ) + convertedDate.getMinutes()\n\n    // return date and time in a object\n    return {\n        date : convertedDate.toLocaleDateString(),\n        time : time\n    };\n}"},"getUtcDateObject":{"Documentation":{"description":"Gets a date object (corresponding to the local time and date) and returns\nthe UTC date object","tags":[]},"Source":"PULSE.CLIENT.DateUtil.getUtcDateObject = function convertDateToUTC( date )\n{\n    return new Date(\n        date.getUTCFullYear(),\n        date.getUTCMonth(),\n        date.getUTCDate(),\n        date.getUTCHours(),\n        date.getUTCMinutes(),\n        date.getUTCSeconds()\n    );\n}"},"getUtcTime":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"dateStr"}]},"Source":"PULSE.CLIENT.DateUtil.getUtcTime = function ( dateStr )\n{\n    // parseDateTime gives you local date-time\n    var matchDate   = PULSE.CLIENT.DateUtil.parseDateTime( dateStr );\n\n    if ( matchDate )\n    {\n        var utcDate                 = PULSE.CLIENT.DateUtil.getUtcDateObject( matchDate ),\n            formattedUTCDateTime    = dateFormat( utcDate, 'dddd mmmm dS yyyy|HH:MM| Z' ).split( \"|\" ),\n            utcTime                 = formattedUTCDateTime[1];\n\n        return utcTime;\n    }\n}"},"getTimeFromTimestamp":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"dateStr"},{"title":"param","description":null,"type":null,"name":"offset"},{"title":"param","description":null,"type":null,"name":"timeFormat"}]},"Source":"PULSE.CLIENT.DateUtil.getTimeFromTimestamp = function ( dateStr, offset, timeFormat )\n{\n    // Default values\n    if( !offset )\n    {\n        offset = 0;\n    }\n    if( !timeFormat )\n    {\n        timeFormat = \"HH:MM\";\n    }\n\n    // parseDateTime gives you local date-time\n    var matchDate   = PULSE.CLIENT.DateUtil.parseDateTime( dateStr ),\n        offsetDate  = matchDate ? new Date( matchDate.getTime() + ( 3600000 * offset ) ) : undefined;\n\n    if ( offsetDate )\n    {\n        var utcDate           = PULSE.CLIENT.DateUtil.getUtcDateObject( offsetDate ),\n            formattedDateTime = dateFormat( utcDate, 'dddd mmmm dS yyyy|' + timeFormat + '| Z' ).split( \"|\" ),\n            utcTime           = formattedDateTime[1];\n\n        return utcTime;\n    }\n}"},"getDateFromTimestamp":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"dateStr"},{"title":"param","description":null,"type":null,"name":"offset"},{"title":"param","description":null,"type":null,"name":"desiredFormat"}]},"Source":"PULSE.CLIENT.DateUtil.getDateFromTimestamp = function ( dateStr, offset, desiredFormat )\n{\n    // Default values\n    if( !offset )\n    {\n        offset = 0;\n    }\n    if( !desiredFormat )\n    {\n        desiredFormat = 'dd mmmm yyyy';\n    }\n\n    // parseDateTime gives you local date-time\n    var matchDate   = PULSE.CLIENT.DateUtil.parseDateTime( dateStr ),\n        offsetDate  = matchDate ? new Date( matchDate.getTime() + ( 3600000 * offset ) ) : undefined;\n\n    if ( offsetDate )\n    {\n        var utcDate           = PULSE.CLIENT.DateUtil.getUtcDateObject( offsetDate ),\n            formattedDateTime = dateFormat( utcDate, desiredFormat + '|HH:MM| Z' ).split( \"|\" ),\n            formattedDate     = formattedDateTime[0];\n\n        return formattedDate;\n    }\n}"},"getSinceString":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"date"},{"title":"param","description":null,"type":null,"name":"format"}]},"Source":"PULSE.CLIENT.DateUtil.getSinceString = function( date, format )\n{\n    if( date )\n    {\n        var now = new Date();\n\n        var diff = Math.floor( ( now - date ) / 1000 );\n\n        if( diff <= 0 )\n        {\n            return format ? format.justNow : \"just now\";\n        }\n        else if( diff < 60 )\n        {\n            var output = Math.round( diff );\n            return output + ( format ? format.seconds : \"s\" );\n        }\n        else if( diff < 60 * 60 )\n        {\n            var output = Math.round( diff / 60 );\n            return output + ( format ? format.minutes : \"m\" );\n        }\n        else if( diff < 60 * 60 * 24 )\n        {\n            var output = Math.round( diff / ( 60 * 60 ) );\n            return output + ( format ? format.hours : \"h\" );\n        }\n        else\n        {\n            var output = Math.round( diff / ( 60 * 60 * 24 ) );\n            return output + ( format ? format.days : \"d\" );\n        }\n    }\n}"},"getFormattedEventDate":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"dateString"},{"title":"param","description":null,"type":null,"name":"dateFormatString"}]},"Source":"PULSE.CLIENT.DateUtil.getFormattedEventDate = function( dateString, dateFormatString )\n{\n    var date = PULSE.CLIENT.DateUtil.parseDateTime( dateString ),\n        utcDate = PULSE.CLIENT.DateUtil.getUtcDateObject( date );\n\n    if( utcDate )\n    {\n        var formattedDateString = dateFormat( utcDate, dateFormatString ).split('|')[0];\n        return formattedDateString;\n    }\n}"}},"JSONPTimer":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"PULSE.CLIENT.JSONPTimer"}]},"Source":"PULSE.CLIENT.JSONPTimer = function()\n{\n\tthis.timer = undefined;\n\tthis.isStopped = false;\n}","prototype":{"fireTimer":{"Documentation":{"description":"This makes an ajax call for the given url and fires the timer with the given parameters. \ninterval should be > 0  to make it run periodically. \ntimeout attr is required to handle 404","tags":[]},"Source":"PULSE.CLIENT.JSONPTimer.prototype.fireTimer = function( url, params, interval )\n{\n\tvar that = this;\n\t$.ajax(\n\t{        \n\t    dataType: 'jsonp',\t    \n\t    url: url,\t    \n\t    data: params,\n\t    timeout: interval,\n\t    complete: function(param1, param2)\n\t    {\n\t\t\tthat.cancelTimer();\n\t\t\tif( interval > 0 && !that.isStopped )\n\t\t\t{\n\t\t\t\tthat.timer = setTimeout( function(){ that.fireTimer( url, params, interval ); }, interval );\n\t\t\t}\n\t\t}\n\t});\t\n}"},"cancelTimer":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.CLIENT.JSONPTimer.prototype.cancelTimer = function()\n{\n\tif( this.timer )\n\t{\n\t\tclearTimeout( this.timer );\n\t}\n}"}}},"JqueryJSONPDataManager":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"PULSE.CLIENT.JqueryJSONPDataManager"}]},"Source":"PULSE.CLIENT.JqueryJSONPDataManager = function ()\n{\n\t//depricated\n\t//this.timers = {};\n\t//this.lastdata = {};\n\t//this.savedTargets = {};\n\t\n\tthis.urls = {};\n\t/**\n\t * //proposed object for a given url\n\tthis.urls['scoring-01.js'] = {\n\t\ttimer: 'new JqueryJSONPTimer'\n\t\tsavedTargets: [],\n\t\tlastData: '',\n\t\tcallback: '',\n\t\tinterval: -1,\n\t\turl: '',\n\t\tid: ''\n\t}\n\t*/\n}","prototype":{"addFeed":{"Documentation":{"description":"Note that the interval is in SECONDS, and will be multiplied by 1000 to derive a millisecond\nvalue.","tags":[]},"Source":"PULSE.CLIENT.JqueryJSONPDataManager.prototype.addFeed = function ( id, url, interval, callback, targets )\n{\n    var currentTargets = this.urls[url] && this.urls[url].savedTargets ? this.urls[url].savedTargets : [];\n    \n\t// Remove any existing feed with this ID\n\tthis.removeFeed( url );\n\n\t// Save the callback name\n\tthis.urls[url] = { id:id, url:url, interval:interval, callback:callback };\n    \n    // Add all the targets to the current targets\n    for ( var i = 0, limit = targets.length; i < limit; i++ )\n    {\n        var needToAdd = true;\n        for ( var j = 0, jLimit = currentTargets.length; j < jLimit; j++ )\n        {\n            if ( targets[ i ] === currentTargets[ j ] )\n            {\n                needToAdd = false;\n                break;\n            }\n        }\n        if ( needToAdd )\n        {\n            currentTargets.push( targets[ i ] );\n        }\n    }\n    \n    this.urls[url].savedTargets = currentTargets;\n\t\n\t// Dynamically create the callback method\n\tvar that = this;\n\tvar f = function ( jsonpData )\n\t{\n\t\tif ( jsonpData )\n\t\t{\n\t\t\tvar payload = jsonpData;\n\t\t\t\n\t\t\t// Serialise the payload\n\t\t\tvar serialised = $.toJSON( payload );\n\t\t    if ( that.urls[url] && that.urls[url].lastData !== serialised )\n\t\t    {\n\t\t    \t// Save the new data\n\t\t    \tthat.urls[url].lastData = serialised;\n\t\t\t\t// Pass the data to all of the targets...\n\t\t\t\tfor ( var t = 0, tlimit = currentTargets.length; t < tlimit; t++ )\n\t\t\t\t{\n\t\t\t\t\t// ...if they are valid\n\t\t\t\t\tvar target = currentTargets[t];\n\t\t\t\t\tif ( target && target.onData )\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttarget.onData( payload, id );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch(e)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif( window.console && window.console.log ) console.log(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t    }\n\t\t}\n\t};\n\t\n\tvar e = function ( )\n\t{\n\t\tfor ( var t = 0, tlimit = currentTargets.length; t < tlimit; t++ )\n\t\t{\n\t\t\t// ...if they are valid\n\t\t\tvar target = currentTargets[t];\n\t\t\tif ( target && target.onError )\n\t\t\t{\n\t\t\t\ttarget.onError( id );\n\t\t\t}\n\t\t}\n\t};\n\t\n\t// Create the timer\n\tthat.urls[url].timer = new PULSE.CLIENT.JqueryJSONPTimer( this.urls[url], f, e );\n}","f":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"jsonpData"}]},"Source":"var f = function ( jsonpData )\n\t{\n\t\tif ( jsonpData )\n\t\t{\n\t\t\tvar payload = jsonpData;\n\t\t\t\n\t\t\t// Serialise the payload\n\t\t\tvar serialised = $.toJSON( payload );\n\t\t    if ( that.urls[url] && that.urls[url].lastData !== serialised )\n\t\t    {\n\t\t    \t// Save the new data\n\t\t    \tthat.urls[url].lastData = serialised;\n\t\t\t\t// Pass the data to all of the targets...\n\t\t\t\tfor ( var t = 0, tlimit = currentTargets.length; t < tlimit; t++ )\n\t\t\t\t{\n\t\t\t\t\t// ...if they are valid\n\t\t\t\t\tvar target = currentTargets[t];\n\t\t\t\t\tif ( target && target.onData )\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttarget.onData( payload, id );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch(e)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif( window.console && window.console.log ) console.log(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t    }\n\t\t}\n\t}"},"e":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"var e = function ( )\n\t{\n\t\tfor ( var t = 0, tlimit = currentTargets.length; t < tlimit; t++ )\n\t\t{\n\t\t\t// ...if they are valid\n\t\t\tvar target = currentTargets[t];\n\t\t\tif ( target && target.onError )\n\t\t\t{\n\t\t\t\ttarget.onError( id );\n\t\t\t}\n\t\t}\n\t}"}},"startAll":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.CLIENT.JqueryJSONPDataManager.prototype.startAll = function ()\n{\n\tfor ( var url in this.urls )\n\t{\n\t\tthis.start( url );\n\t}\n}"},"stopAll":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.CLIENT.JqueryJSONPDataManager.prototype.stopAll = function ()\n{\n\tfor ( var url in this.urls )\n\t{\n\t\tthis.stop( url );\n\t}\n}"},"start":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"url"}]},"Source":"PULSE.CLIENT.JqueryJSONPDataManager.prototype.start = function ( url )\n{\n\tif ( this.urls[url] && this.urls[url].timer )\n\t{\n\t\tthis.urls[url].timer.start();\n\t}\n}"},"stop":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"url"}]},"Source":"PULSE.CLIENT.JqueryJSONPDataManager.prototype.stop = function ( url )\n{\n\tif ( this.urls[url] && this.urls[url].timer )\n\t{\n\t\tthis.urls[url].timer.stop();\n\t}\n}"},"removeFeed":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"url"}]},"Source":"PULSE.CLIENT.JqueryJSONPDataManager.prototype.removeFeed = function ( url )\n{\n\tthis.stop( url );\n\t\n\tif ( this.urls[url] )\n\t{\n\t\tthis.urls[url] = undefined;\n\t}\n\t\n}"}}},"JqueryJSONPTimer":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"PULSE.CLIENT.JqueryJSONPTimer"},{"title":"param","description":null,"type":null,"name":"params"},{"title":"param","description":null,"type":null,"name":"f"},{"title":"param","description":null,"type":null,"name":"e"}]},"Source":"PULSE.CLIENT.JqueryJSONPTimer = function( params, f, e )\n{\n\tthis.initialise( params || {}, f, e );\n\n\tthis.running = false;\n}","prototype":{"initialise":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"params"},{"title":"param","description":null,"type":null,"name":"f"},{"title":"param","description":null,"type":null,"name":"e"}]},"Source":"PULSE.CLIENT.JqueryJSONPTimer.prototype.initialise = function( params, f, e )\n{\n\tthis.url = params.url || '';\n\tthis.interval = params.interval || 0;\n\tthis.params = params.params || {};\n\tthis.callbackName = params.callback || '';\n\tthis.callback = f;\n\tthis.errorCallback = e;\n\tthis.name = params.id || 'un-named';\n}"},"start":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.CLIENT.JqueryJSONPTimer.prototype.start = function()\n{\n\tif ( !this.running )\n\t{\n\t\tthis.running = true;\n\t\tthis.fireTimer( );\n\t}\n}"},"stop":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.CLIENT.JqueryJSONPTimer.prototype.stop = function()\n{\n\tif ( this.running )\n\t{\n\t\tthis.running = false;\n\t\tthis.cancelTimer( );\n\t}\n}"},"fireTimer":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.CLIENT.JqueryJSONPTimer.prototype.fireTimer = function()\n{\n\tvar that = this;\n\n\tiPhoneApp.loadJSONP(this.url, this.interval, false);\n}"},"cancelTimer":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.CLIENT.JqueryJSONPTimer.prototype.cancelTimer = function()\n{\n\tif ( this.timer )\n\t{\n\t\tclearTimeout( this.timer );\n\t}\n}"}}},"Log":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"PULSE.CLIENT.Log"},{"title":"param","description":null,"type":null,"name":"message"}]},"Source":"PULSE.CLIENT.Log = function( message )\n{\n\tif ( typeof console === \"object\" ) {\n\t    console.log( message )\n\t}\n}"},"MatchFlowOverlay":{"Documentation":{"description":"Constructor.","tags":[{"title":"param","description":"the div name in which this match flow overlay will be created","type":null,"name":"id"},{"title":"param","description":"the configuration parameters","type":null,"name":"config"}]},"Source":"PULSE.CLIENT.MatchFlowOverlay = function ( id, config )\n{\n    this.config = config;\n    this.r = Raphael( id, config.width, config.height );\n    \n    this.player1 = this.r.path().attr( { stroke:config.colors[0], 'stroke-width':2 } );\n    this.player2 = this.r.path().attr( { stroke:config.colors[1], 'stroke-width':2 } );\n\n    if ( config.shadow )\n    {\n        doc = document;\n\t    this.shadow1 = this.r.path().attr( { stroke:'#333', 'stroke-width':2 } );\n\t    this.shadow1.blur( 3 );\n\t    \n\t    this.shadow2 = this.r.path().attr( { stroke:'#333', 'stroke-width':2 } );\n\t    this.shadow2.blur( 3 );\n    }\n}","prototype":{"setData":{"Documentation":{"description":"Sets the value that this swingometer should display.","tags":[{"title":"param","description":"the value, in the range 0-1000","type":null,"name":"data"}]},"Source":"PULSE.CLIENT.MatchFlowOverlay.prototype.setData = function ( data )\n{\n    var points = data.length;\n    if ( this.config.minx && points < this.config.minx )\n    {\n    \tpoints = this.config.minx;\n    }\n\n    var dx = ( this.config.width - this.config.margin.e - this.config.margin.w ) / ( points - 1 );\n    var dy = ( this.config.height - this.config.margin.n - this.config.margin.s ) / 1000;\n\n    var p1 = '';\n    var p2 = '';\n    \n    for ( var i = 0; i < points && i < data.length; i++ )\n    {\n        var v1 = data[i];\n        var v2 = 1000 - v1;\n        \n        var x = Math.round( this.config.margin.w + ( i * dx ) );\n        var y1 = Math.round( this.config.height - this.config.margin.s - ( v1 * dy ) );\n        var y2 = Math.round( this.config.height - this.config.margin.s - ( v2 * dy ) ); \n\n        if ( i === 0 )\n        {\n            p1 = 'M';\n            p2 = 'M';\n        }\n        else\n        {\n            p1 += 'L';\n            p2 += 'L';\n        }\n\n        p1 += x + ',' + y1;\n        p2 += x + ',' + y2; \n    }\n\n    this.player1.attr( { path:p1 } );\n    this.player2.attr( { path:p2 } );\n\n    if ( this.shadow1 )\n    {\n\t    this.shadow1.attr( { path:p1, translation:'3,4' } );\n\t    this.shadow2.attr( { path:p2, translation:'3,4' } );\n    }\n}"}}},"NewJSONPTimer":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"PULSE.CLIENT.NewJSONPTimer"},{"title":"param","description":null,"type":null,"name":"url"},{"title":"param","description":null,"type":null,"name":"interval"},{"title":"param","description":null,"type":null,"name":"params"}]},"Source":"PULSE.CLIENT.NewJSONPTimer = function ( url, interval, params )\n{\n\tthis.url = url;\n\tthis.interval = interval;\n\tthis.params = params;\n\t\n\tthis.running = false;\n}","prototype":{"start":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.CLIENT.NewJSONPTimer.prototype.start = function ()\n{\n\tif ( !this.running )\n\t{\n\t\tthis.running = true;\n\t\tthis.fireTimer();\n\t}\n}"},"stop":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.CLIENT.NewJSONPTimer.prototype.stop = function ()\n{\n\tif ( this.running )\n\t{\n\t\tthis.running = false;\n\t\tthis.cancelTimer();\n\t}\n}"},"fireTimer":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.CLIENT.NewJSONPTimer.prototype.fireTimer = function ()\n{\n\tvar that = this;\n\t$.ajax( { dataType : 'jsonp',\t    \n\t    \t  url      : that.url,\t    \n\t    \t  data     : that.params,\n\t    \t  timeout  : that.interval,\n\t    \t  complete : function ()\n\t    \t  {\n\t\t\t      that.cancelTimer();\n\t\t\t      if ( that.interval > 0 && that.running )\n\t\t\t      {\n\t\t\t    \t  that.timer = setTimeout( function () { that.fireTimer(); }, that.interval );\n\t\t\t      }\n\t    \t  } } );\n}"},"cancelTimer":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.CLIENT.NewJSONPTimer.prototype.cancelTimer = function()\n{\n\tif ( this.timer )\n\t{\n\t\tclearTimeout( this.timer );\n\t}\n}"}}},"ResponsiveUtils":{"detectMobile":{"Documentation":{"description":"Detect mobile device via user agent - Does not detect various tablets/ipads","tags":[{"title":"return","description":"Returns true if the user's device is mobile","type":{"type":"NameExpression","name":"boolean"}}]},"Source":"PULSE.CLIENT.ResponsiveUtils.detectMobile = function()\n{\n    if( /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) )\n    {\n        return true;\n    }\n    return false;\n}"},"detectTouchSupport":{"Documentation":{"description":"Detects touch support on launch - removes and re-adds the touch class to the html tag\nRemoval is required to function correctly when running the application in an iframe\n\nREQUIRES MODERNIZR LIB","tags":[]},"Source":"PULSE.CLIENT.ResponsiveUtils.detectTouchSupport = function()\n{\n    if( Modernizr && Modernizr.touch )\n    {\n        Modernizr.addTest('overflowscrolling', Modernizr.testAllProps( 'overflowScrolling', 'touch', true ));\n        if( Modernizr.overflowscrolling )\n        {\n            $('html').removeClass('touch');\n            //add class to element to enable hardware accelerated scrolling\n            document.documentElement.className += \"touch\";\n            $('html').addClass('touch');\n        }\n    }\n}"},"detectWakeFromSleep":{"Documentation":{"description":"Adds a listener to detect if the browser has been running in the background on a mobile device\nand refreshes the page if sufficient time has passed","tags":[]},"Source":"PULSE.CLIENT.ResponsiveUtils.detectWakeFromSleep = function()\n{\n    var _lastTick = +new Date;\n\n    function detectWakeFromSleep()\n    {\n        var now = +new Date;\n        if( (now - _lastTick) > 240000 )\n        {\n            if( window.navigator.onLine === false )\n            {\n                return false; //don't refresh if they are not online\n            }\n\n            window.location.href = window.location.href;\n        }\n\n        _lastTick = now;\n        return true;\n    }\n\n    window.setInterval( detectWakeFromSleep, 2000 );\n}"},"detectFlashSupport":{"Documentation":{"description":"Detect whether current device supports flash","tags":[{"title":"return","description":"True if browser supports flash else false","type":{"type":"NameExpression","name":"boolean"}}]},"Source":"PULSE.CLIENT.ResponsiveUtils.detectFlashSupport = function()\n{\n    if((typeof navigator.plugins != \"undefined\" &&\n        typeof navigator.plugins[\"Shockwave Flash\"] == \"object\") ||\n        (window.ActiveXObject && (new ActiveXObject(\"ShockwaveFlash.ShockwaveFlash\")) != false))\n    {\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n}"},"detectEndOfWindowResize":{"Documentation":{"description":"Detects when the user has stopped resizing the window","tags":[{"title":"param","description":"Callback function to be called on end of resize","type":{"type":"NameExpression","name":"Function"},"name":"callback"}]},"Source":"PULSE.CLIENT.ResponsiveUtils.detectEndOfWindowResize = function( callback )\n{\n    var rtime = new Date(1, 1, 2000, 12,00,00),\n        timeout = false,\n        delta = 200;\n\n    $( window ).resize( function()\n    {\n        rtime = new Date();\n        if( timeout === false )\n        {\n            timeout = true;\n            setTimeout( resizeend, delta );\n        }\n    });\n\n    function resizeend()\n    {\n        if( new Date() - rtime < delta )\n        {\n            setTimeout( resizeend, delta );\n        }\n        else\n        {\n            timeout = false;\n            if( callback )\n            {\n                callback();\n            }\n        }\n    }\n}"}},"Set":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"PULSE.CLIENT.Set"}]},"Source":"PULSE.CLIENT.Set = function()\n{\n\tthis.object = {};\n}","prototype":{"add":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"value"}]},"Source":"PULSE.CLIENT.Set.prototype.add = function(value)\n{\t\t\n\tthis.object[value] = true;\t\n}"},"remove":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"value"}]},"Source":"PULSE.CLIENT.Set.prototype.remove = function(value)\n{\t\t\n\tdelete this.object[value];\t\n}"},"contains":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"value"}]},"Source":"PULSE.CLIENT.Set.prototype.contains = function(value)\n{\t\t\t\n\treturn this.object[value] !== undefined;\n}"},"noOfItems":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.CLIENT.Set.prototype.noOfItems = function()\n{\n\tvar counter = 0;\n\t\n\tfor( var property in this.object )\n\t{\t\t\n\t\tcounter++;\t\t\t\n\t}\n\t\n\treturn counter;\n}"}},"fromString":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"string"}]},"Source":"PULSE.CLIENT.Set.fromString = function(string)\n{\t\t\n\tvar set = new PULSE.CLIENT.Set();\n\tvar fieldsArray = string.split(PULSE.CLIENT.Set.Delimiter);\n\tfor(var i = 0; i < fieldsArray.length; i++)\n\t{\n\t\tset.add(fieldsArray[i]);\n\t}\n\treturn set;\n}"}},"SUPERSIZED":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"PULSE.CLIENT.SUPERSIZED"},{"title":"param","description":null,"type":null,"name":"container"},{"title":"param","description":null,"type":null,"name":"mode"}]},"Source":"PULSE.CLIENT.SUPERSIZED = function( container, mode ) /*Container must be and ID, mode is none, video, other, if you leave blank is photo*/\n{\n\tthis.container = container;\n\tthis.mode = mode;\n\t//this.data = data;\n\tthis.$overlayContainer = $( container + '.photo-overlay');\n\n\tif ( this.$overlayContainer )\n\t{\n\t\tif ( this.$overlayContainer.length < 1 )\n\t\t{\n\t\t\tthis.$overlayContainer = $( container + ' .photo-overlay-relative');\n\t\t}\n\t}\n\n\tthis.$thumbList = this.$overlayContainer.find('#thumb-list');\n\tthis.$closeButton = this.$overlayContainer.find('#close-button');\n\tthis.$fullscreenButton = this.$overlayContainer.find('#fullscreen-button');\n\tthis.$trayButton = this.$overlayContainer.find('#tray-button');\n\t// this.$tbackButton = this.$overlayContainer.find('#thumb-back');\n\t// this.$tfwdButton = this.$overlayContainer.find('#thumb-forward');\n\tthis.$backButton = this.$overlayContainer.find('#prevslide');\n\n\tthis.addlistener();\n}","prototype":{"openModal":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"content_id"},{"title":"param","description":null,"type":null,"name":"start_id"}]},"Source":"PULSE.CLIENT.SUPERSIZED.prototype.openModal = function( content_id,start_id )\n{\n\tvar temp_data = []\n\t$(\".superscroll_data[superscroll-collectionid='\" + content_id + \"']\").each(function( index ) {\n\t\tvar temp_photo = {\n\t\t\timage : $( this ).attr('superscroll-src'),\n\t\t\ttitle : $( this ).attr('superscroll-title'),\n\t\t\tthumb : $( this ).attr('superscroll-thumb'),\n\t\t\turl : '',\n\t\t\tsocial: $( this ).attr('superscroll-social')\n\t\t}\n\t\ttemp_data.push(temp_photo);\n\t});\n\tthis.data = temp_data;\n\tthis.$overlayContainer.show();\n\tthis.initialize(start_id);\n\tthis.$supersizedContainer = this.$overlayContainer.find('#supersized');\n}"},"addlistener":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.CLIENT.SUPERSIZED.prototype.addlistener = function()\n{\n\tvar that = this;\n\n\t// //close modal\n\tthis.$closeButton.bind( \"click\", function() {\n\n\t\tthat.exitFullscreen();\n\n\t\tthat.closeOverlay();\n\t});\n\n\tif (\n\t    document.fullscreenEnabled ||\n\t    document.webkitFullscreenEnabled ||\n\t    document.mozFullScreenEnabled ||\n\t    document.msFullscreenEnabled\n\t) {\n\t\tthis.$fullscreenButton.bind( \"click\", function() {\n\t\t\t// full-screen available?\n\t\t\tthat.toggleFullscreen();\n\t\t});\n\t}\n\telse\n\t{\n\t\tthis.$fullscreenButton.hide();\n\t}\n}"},"closeOverlay":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.CLIENT.SUPERSIZED.prototype.closeOverlay = function()\n{\n\t//delete supersized\n\tthis.$overlayContainer.hide();\n\tthis.$overlayContainer.find('#thumb-tray').empty().append('<div id=\"thumb-back\"></div><div id=\"thumb-forward\"></div>');\n\tthis.$supersizedContainer.empty();\n\t//this.$thumbList.remove();\n\n\t//Fix the thumbs\n\tthis.$trayButton.css('left','10px');\n\tthis.$backButton.css('left','10px');\n\t// this.$tbackButton.off();\n\t// this.$tfwdButton.off();\n\tthis.$trayButton.off();\n}"},"exitFullscreen":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.CLIENT.SUPERSIZED.prototype.exitFullscreen = function()\n{\n\t// exit full-screen\n\tif (document.exitFullscreen) {\n\t    document.exitFullscreen();\n\t} else if (document.webkitExitFullscreen) {\n\t    document.webkitExitFullscreen();\n\t} else if (document.mozCancelFullScreen) {\n\t    document.mozCancelFullScreen();\n\t} else if (document.msExitFullscreen) {\n\t    document.msExitFullscreen();\n\t}\n}"},"toggleFullscreen":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.CLIENT.SUPERSIZED.prototype.toggleFullscreen = function()\n{\n\tvar id = this.container.slice(1);\n\tvar i = document.getElementById(id);\n\n\t// full-screen available?\n\tif (\n\t    document.fullscreenEnabled ||\n\t    document.webkitFullscreenEnabled ||\n\t    document.mozFullScreenEnabled ||\n\t    document.msFullscreenEnabled\n\t) {\n\t\tif (\n\t\t    document.fullscreenElement ||\n\t\t    document.webkitFullscreenElement ||\n\t\t    document.mozFullScreenElement ||\n\t\t    document.msFullscreenElement\n\t\t) {\n\t\t\t// exit full-screen\n\t\t\tthis.exitFullscreen();\n\t\t}\n\t\telse{\n\t\t\t// go full-screen\n\t\t\tif (i.requestFullscreen) {\n\t\t\t    i.requestFullscreen();\n\t\t\t} else if (i.webkitRequestFullscreen) {\n\t\t\t    i.webkitRequestFullscreen();\n\t\t\t} else if (i.mozRequestFullScreen) {\n\t\t\t    i.mozRequestFullScreen();\n\t\t\t} else if (i.msRequestFullscreen) {\n\t\t\t    i.msRequestFullscreen();\n\t\t\t}\n\t\t}\n\t}\n}"},"initialize":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"id"}]},"Source":"PULSE.CLIENT.SUPERSIZED.prototype.initialize = function( id )\n{\n\tvar that = this;\n\tvar start_id = id ? id : 0;\n\tjQuery(function($){\n\n\t\t$.supersized({\n\n\t\t\t// Functionality\n\t\t\tslideshow               :   1,\t\t\t// Slideshow on/off\n\t\t\tautoplay\t\t\t\t:\t0,\t\t\t// Slideshow starts playing automatically\n\t\t\tstart_slide             :   start_id,\t\t\t// Start slide (0 is random)\n\t\t\tstop_loop\t\t\t\t:\t0,\t\t\t// Pauses slideshow on last slide\n\t\t\trandom\t\t\t\t\t: \t0,\t\t\t// Randomize slide order (Ignores start slide)\n\t\t\tslide_interval          :   3000,\t\t// Length between transitions\n\t\t\ttransition              :   6, \t\t\t// 0-None, 1-Fade, 2-Slide Top, 3-Slide Right, 4-Slide Bottom, 5-Slide Left, 6-Carousel Right, 7-Carousel Left\n\t\t\ttransition_speed\t\t:\t1000,\t\t// Speed of transition\n\t\t\tnew_window\t\t\t\t:\t1,\t\t\t// Image links open in new window/tab\n\t\t\tpause_hover             :   0,\t\t\t// Pause slideshow on hover\n\t\t\tkeyboard_nav            :   1,\t\t\t// Keyboard navigation on/off\n\t\t\tperformance\t\t\t\t:\t1,\t\t\t// 0-Normal, 1-Hybrid speed/quality, 2-Optimizes image quality, 3-Optimizes transition speed // (Only works for Firefox/IE, not Webkit)\n\t\t\timage_protect\t\t\t:\t1,\t\t\t// Disables image dragging and right click with Javascript\n\n\t\t\t// Size & Position\n\t\t\tmin_width\t\t        :   0,\t\t\t// Min width allowed (in pixels)\n\t\t\tmin_height\t\t        :   0,\t\t\t// Min height allowed (in pixels)\n\t\t\tvertical_center         :   1,\t\t\t// Vertically center background\n\t\t\thorizontal_center       :   1,\t\t\t// Horizontally center background\n\t\t\tfit_always\t\t\t\t:\t1,\t\t\t// Image will never exceed browser width or height (Ignores min. dimensions)\n\t\t\tfit_portrait         \t:   1,\t\t\t// Portrait images will not exceed browser height\n\t\t\tfit_landscape\t\t\t:   1,\t\t\t// Landscape images will not exceed browser width\n\n\t\t\t// Components\n\t\t\tslide_links\t\t\t\t:\t'blank',\t// Individual links for each slide (Options: false, 'num', 'name', 'blank')\n\t\t\tthumb_links\t\t\t\t:\t1,\t\t\t// Individual thumb links for each slide\n\t\t\tthumbnail_navigation    :   0,\t\t\t// Thumbnail navigation\n\t\t\tslides \t\t\t\t\t:  \tthat.data,\n\n\t\t\t// Theme Options\n\t\t\tprogress_bar\t\t\t:\t1,\t\t\t// Timer for each slide\n\t\t\tmouse_scrub\t\t\t\t:\t0,\n\t\t\tcontainer \t\t\t\t: \tthat.container,\n\t\t\tmode \t\t\t\t\t: \tthat.mode\n\n\t\t});\n    });\n}"}}},"Swingometer":{"Documentation":{"description":"Constructor.","tags":[{"title":"param","description":"the div name in which this swingometer will be created","type":null,"name":"id"}]},"Source":"PULSE.CLIENT.Swingometer = function ( id, config )\n{\n    this.radius = config.height - ( 2 * config.margin );\n    \n    this.r = Raphael( id, config.width, config.height );\n    this.r.rect( 0, 0, config.width, config.height ).attr( { fill:'#000' } );\n\n    this.ox = config.width / 2;\n    this.oy = config.margin;\n\n    // Segments\n    var c1 = config.colors[0];\n    this.r.path( 'M' + this.ox + ' ' + this.oy + 'L' + config.margin + ' ' + this.oy +\n            'A' + this.radius + ' ' + this.radius + ' 0 0 0 ' + this.ox + ' ' + \n                ( config.height - config.margin ) +                                  \n            'L' + this.ox + ' ' + this.oy ).attr( { fill:c1, stroke:c1 } );\n\n    var c2 = config.colors[1];\n    this.r.path( 'M' + this.ox + ' ' + this.oy + 'L' + ( config.width - config.margin ) + \n    \t\t     ' ' + this.oy +\n            'A' + this.radius + ' ' + this.radius + ' 0 0 1 ' + this.ox + ' ' + \n                ( config.height - config.margin ) +                                  \n            'L' + this.ox + ' ' + this.oy ).attr( { fill:c2, stroke:c2 } );\n\n    // Ticks\n    var tick = 1;\n    for ( var angle = 3; angle < 180; angle += 3, tick++ )\n    {\n        var rad = Raphael.rad( angle );\n        var cos = Math.cos( rad );\n        var sin = Math.sin( rad );\n\n        var sz = 33;\n        if ( tick % 6 !== 0 )\n        {\n            sz = 37;\n        }\n        \n        this.r.path( 'M' + ( this.ox + ( sz * cos ) ) + ' ' + ( this.oy + ( sz * sin ) ) +\n                     'L' + ( this.ox + ( 40 * cos ) ) + ' ' + ( this.oy + ( 40 * sin ) ) ).\n                     attr( { stroke:'#ccc' } );\n    }  \n\n    var needlePath = 'M' + ( this.ox - 2 ) + ' ' + this.oy +\n                     'L' + ( this.ox - 2 ) + ' ' + ( this.oy + ( config.height * 0.45 ) ) +\n                     'L' + ( this.ox )     + ' ' + ( this.oy + ( config.height * 0.75 ) ) +\n                     'L' + ( this.ox + 2 ) + ' ' + ( this.oy + ( config.height * 0.45 ) ) +\n                     'L' + ( this.ox + 2 ) + ' ' + this.oy;\n\n    this.needle = this.r.path( needlePath ).attr( { fill:'#ccc', stroke:'#242424' } );\n    this.r.circle( this.ox, this.oy, 6 ).attr( { fill:'#000', stroke:'none' } );\n    this.r.circle( this.ox, this.oy, 2 ).attr( { fill:'#ccc', stroke:'none' } );\n}","prototype":{"setData":{"Documentation":{"description":"Sets the value that this swingometer should display.","tags":[{"title":"param","description":"the value, in the range 0-1000","type":null,"name":"data"}]},"Source":"PULSE.CLIENT.Swingometer.prototype.setData = function ( data )\n{\n\tvar theta = ( 180 * data / 1000 ) - 90;\n    this.needle.animate( { rotation: theta + ' ' + this.ox + ' ' + this.oy }, 800, '<>' );\n}"}}},"Template":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"PULSE.CLIENT.Template"}]},"Source":"PULSE.CLIENT.Template = function()\r\n{\r\n}","fetch":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"path"},{"title":"param","description":null,"type":null,"name":"done"}]},"Source":"PULSE.CLIENT.Template.fetch = function(path, done)\r\n{\r\n\tvar JST = window.JST = window.JST || {};\r\n\tvar targets = PULSE.CLIENT.Template.targets[path] = PULSE.CLIENT.Template.targets[path] || [];\r\n\tvar def = new $.Deferred();\r\n    var needToAdd = true;\r\n\r\n\t// Should be an instant synchronous way of getting the template, if it\r\n\t// exists in the JST object.\r\n\tif (JST[path])\r\n\t{\r\n\t\tif (_.isFunction(done))\r\n\t\t{\r\n\t\t\tdone(JST[path]);\r\n\t\t}\r\n\t\treturn;\r\n\t}\r\n\r\n    for ( var j = 0, jLimit = targets.length; j < jLimit; j++ )\r\n    {\r\n        if ( targets[ j ] === done )\r\n        {\r\n            needToAdd = false;\r\n            break;\r\n        }\r\n    }\r\n    if ( needToAdd )\r\n    {\r\n        targets.push( done );\r\n    }\r\n\r\n\t// Fetch it asynchronously if not available from JST, ensure that\r\n\t// template requests are never cached and prevent global ajax event\r\n\t// handlers from firing.\r\n\tif( targets.length === 1 )\r\n\t{\r\n\t\t$.ajax({\r\n\t\t\turl: path,\r\n\t\t\ttype: \"get\",\r\n\t\t\tdataType: \"text\",\r\n\t\t\tcache: false,\r\n\t\t\tglobal: false,\r\n\r\n\t\t\tsuccess: function(contents)\r\n\t\t\t{\r\n\t\t\t\tJST[path] = _.template(contents);\r\n\r\n\t\t\t\tfor ( var j = 0, jLimit = targets.length; j < jLimit; j++ )\r\n\t\t\t    {\r\n\t\t\t        if (_.isFunction( targets[ j ] ) )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\ttargets[ j ](JST[path]);\r\n\t\t\t\t\t}\r\n\t\t\t    }\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n}"},"fetchMultiple":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"paths"},{"title":"param","description":null,"type":null,"name":"done"}]},"Source":"PULSE.CLIENT.Template.fetchMultiple = function( paths, done )\r\n{\r\n\tvar templates = {};\r\n\r\n\tfor( var i = 0; i < paths.length; i++ )\r\n\t{\r\n\t\tvar path = paths[i];\r\n\r\n\t\tPULSE.CLIENT.Template.fetch( path, function()\r\n\t\t{\r\n\t\t\tfor( var x = 0; x < paths.length; x++ )\r\n\t\t\t{\r\n\t\t\t\tvar p = paths[x];\r\n\r\n\t\t\t\tif( !JST[p] )\r\n\t\t\t\t{\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\ttemplates[p] = JST[p];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (_.isFunction(done))\r\n\t\t\t{\r\n\t\t\t\tdone(templates);\r\n\t\t\t}\r\n\t\t} );\r\n\t}\r\n}"},"publish":{"Documentation":{"description":"Handy functions to insert templates into the page\r\n\r\n -  publish: replaces container contents with template\r\n -  replace: replaces container with template\r\n -  append:  appends template to container","tags":[]},"Source":"PULSE.CLIENT.Template.publish = function( templateUrl, selector, model, callback )\r\n{\r\n\tPULSE.CLIENT.Template.fetch( templateUrl, function(tmpl) {\r\n    \t$( selector ).html( tmpl( model ) );\r\n\r\n    \tif( callback ) \r\n    \t\tcallback();\r\n\t} );\r\n}"},"replace":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"templateUrl"},{"title":"param","description":null,"type":null,"name":"selector"},{"title":"param","description":null,"type":null,"name":"model"},{"title":"param","description":null,"type":null,"name":"callback"}]},"Source":"PULSE.CLIENT.Template.replace = function( templateUrl, selector, model, callback )\r\n{\r\n\tPULSE.CLIENT.Template.fetch( templateUrl, function(tmpl) {\r\n    \t$( selector ).replaceWith( tmpl( model ) );\r\n\r\n    \tif( callback ) \r\n    \t\tcallback();\r\n\t} );\r\n}"},"append":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"templateUrl"},{"title":"param","description":null,"type":null,"name":"selector"},{"title":"param","description":null,"type":null,"name":"model"},{"title":"param","description":null,"type":null,"name":"callback"}]},"Source":"PULSE.CLIENT.Template.append = function( templateUrl, selector, model, callback )\r\n{\r\n\tPULSE.CLIENT.Template.fetch( templateUrl, function(tmpl) {\r\n    \t$( selector ).append( tmpl( model ) );\r\n\r\n    \tif( callback ) \r\n    \t\tcallback();\r\n\t} );\r\n}"},"prepend":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"templateUrl"},{"title":"param","description":null,"type":null,"name":"selector"},{"title":"param","description":null,"type":null,"name":"model"},{"title":"param","description":null,"type":null,"name":"callback"}]},"Source":"PULSE.CLIENT.Template.prepend = function( templateUrl, selector, model, callback )\r\n{\r\n    PULSE.CLIENT.Template.fetch( templateUrl, function(tmpl) {\r\n        $( selector ).prepend( tmpl( model ) );\r\n\r\n        if( callback ) \r\n            callback();\r\n    } );\r\n}"},"compareAndPublish":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"templateUrl"},{"title":"param","description":null,"type":null,"name":"selector"},{"title":"param","description":null,"type":null,"name":"model"},{"title":"param","description":null,"type":null,"name":"callback"}]},"Source":"PULSE.CLIENT.Template.compareAndPublish = function( templateUrl, selector, model, callback )\r\n{\r\n\tPULSE.CLIENT.Template.fetch( templateUrl, function(tmpl) {\r\n\t\tif( $( selector ).get(0) !== $( tmpl( model ) ).get(0) )\r\n\t\t{\r\n\t\t\t$( selector ).replaceWith( tmpl( model ) );\r\n\t\t\tif( callback ) \r\n\t\t\t{\r\n    \t\t\tcallback();\r\n    \t\t}\r\n\t\t}\r\n\t} );\r\n}"},"getHtml":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"templateUrl"},{"title":"param","description":null,"type":null,"name":"model"}]},"Source":"PULSE.CLIENT.Template.getHtml = function( templateUrl, model )\r\n{\r\n    var html = \"\";\r\n    if( JST[ templateUrl ] )\r\n    {\r\n        PULSE.CLIENT.Template.fetch( templateUrl, function( tmpl )\r\n        {\r\n            html = tmpl( model );\r\n        } );\r\n    }\r\n    return html;\r\n}"}},"Timer":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"PULSE.CLIENT.Timer"}]},"Source":"PULSE.CLIENT.Timer = function()\n{\n\tthis.running = false;\n}","prototype":{"initialise":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"params"}]},"Source":"PULSE.CLIENT.Timer.prototype.initialise = function( params )\n{\n\tthis.callback = params.callback;\n\tthis.interval = params.interval * 1000;\n}"},"start":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"delay"}]},"Source":"PULSE.CLIENT.Timer.prototype.start = function( delay )\n{\n\tif ( !this.running )\n\t{\n\t\tthis.running = true;\n\t\tthis.fireTimer( delay );\n\t}\n}"},"stop":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.CLIENT.Timer.prototype.stop = function()\n{\n\tif ( this.running )\n\t{\n\t\tthis.running = false;\n\t\tthis.cancelTimer( );\n\t}\n}"},"fireTimer":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"delay"}]},"Source":"PULSE.CLIENT.Timer.prototype.fireTimer = function( delay )\n{\n\tvar that = this;\n\n\tif( !delay )\n\t{\n\t\tthat.callback();\n\t}\n\n\tthat.fire();\n}"},"fire":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.CLIENT.Timer.prototype.fire = function()\n{\n\tvar that = this;\n\n\tthat.cancelTimer();\n\n\tif ( that.interval > 0 && that.running )\n\t{\n\t\tthat.timer = setTimeout( function()\n\t\t{\n\t\t\tthat.callback();\n\t\t\tthat.fireTimer( true );\n\t\t}, that.interval );\n\t}\n}"},"cancelTimer":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.CLIENT.Timer.prototype.cancelTimer = function()\n{\n\tif ( this.timer )\n\t{\n\t\tclearTimeout( this.timer );\n\t}\n}"}}},"TwitterController":{"tweetEvent":{"Documentation":{"description":"Creates a new window for a specific twitter event; determines the type of event\nthrough the 'intent' parameter\n\nMore info at: https://dev.twitter.com/docs/intents","tags":[{"title":"param","description":"can be: 'tweet', 'favorite', 'retweet'","type":{"type":"NameExpression","name":"String"},"name":"intent"},{"title":"param","description":"optional; describes additional tweet params","type":{"type":"NameExpression","name":"Object"},"name":"params"},{"title":"param","description":"optional; the width of the pop-up window created","type":{"type":"NameExpression","name":"Number"},"name":"w"},{"title":"param","description":"optional; the height of the pop-up window created","type":{"type":"NameExpression","name":"Number"},"name":"h"}]},"Source":"PULSE.CLIENT.TwitterController.tweetEvent = function(intent, params, w, h)\n{\n    var TC = PULSE.CLIENT.TwitterController;\n\n    var width = w || 575,\n        height = h || 400,\n        left = ($(window).width() - width) / 2,\n        top = ($(window).height() - height) / 2,\n        options = 'status=1' +\n            ',width=' + width +\n            ',height=' + height +\n            ',top=' + top +\n            ',left=' + left;\n\n    var tweetUrl = TC.getIntentUrl(intent, params);\n\n    window.open(tweetUrl, 'twitter', options);\n}"},"getIntentUrl":{"Documentation":{"description":"Returns a URL to call the Twitter API\nMore info at: https://dev.twitter.com/docs/intents","tags":[{"title":"return","description":"the intent URL, complete with added params","type":{"type":"NameExpression","name":"String"}}]},"Source":"PULSE.CLIENT.TwitterController.getIntentUrl = function(intent, params)\n{\n    var TC = PULSE.CLIENT.TwitterController,\n        paramsString = TC.prepareParams(params);\n\n    return \"https://twitter.com/intent/\" + intent + paramsString;\n}"},"getPermalink":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"PULSE.CLIENT.TwitterController.getPermalink"},{"title":"param","description":null,"type":null,"name":"tweet"}]},"Source":"PULSE.CLIENT.TwitterController.getPermalink = function(tweet)\n{\n    var userName = tweet.user.screen_name;\n    var userUrl = PULSE.CLIENT.TwitterController.getUserAccountUrl(userName);\n\n    return userUrl + \"/status/\" + tweet.id_str;\n}"},"prepareParams":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"params"}]},"Source":"PULSE.CLIENT.TwitterController.prepareParams = function(params)\n{\n    var paramsArray = [];\n    $.each(params, function(key, value)\n    {\n        var keyValuePair = [key, encodeURIComponent(value)];\n        paramsArray.push(keyValuePair.join(\"=\"));\n    });\n\n    return \"?\" + paramsArray.join(\"&\");\n}"},"getUserAccountUrl":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"screenName"}]},"Source":"PULSE.CLIENT.TwitterController.getUserAccountUrl = function(screenName)\n{\n    return \"http://twitter.com/\" + screenName;\n}"},"getSearchTagUrl":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"topic"}]},"Source":"PULSE.CLIENT.TwitterController.getSearchTagUrl = function(topic)\n{\n    return \"http://twitter.com/search?q=%23\" + topic;\n}"},"markUpLinks":{"Documentation":{"description":"Utility method to scan the given String for what look like HTTP links,\nTwitter handles and hashtags (called entities), and mark them up with <a> tags.\n\nFor URLs and media links, use expanded_url as the title and use the\ndisplay_url provided by Twitter as the text of the anchor tag\n\nSee: https://dev.twitter.com/docs/tco-url-wrapper/best-practices","tags":[{"title":"param","description":"the original body of the tweet","type":{"type":"NameExpression","name":"String"},"name":"string"},{"title":"param","description":"mapping of types of entities to an array of entity objects","type":{"type":"NameExpression","name":"Object"},"name":"entities"},{"title":"return","description":"the processed body of the tweet, with anchor tags","type":{"type":"NameExpression","name":"String"}}]},"Source":"PULSE.CLIENT.TwitterController.markUpLinks = function(string, entities)\n{\n    // to support the old way of doing things, when entities weren't use\n    // to determine links to pages or media and the URL was directly processed\n    // from the tweet text body\n    if (!entities)\n    {\n        string = string.replace(/(https{0,1}:\\/\\/\\S+)/g, '<a target=\"_blank\" href=\"$1\">$1</a>')\n            .replace(/@(\\S+)/g, '<a target=\"_blank\" href=\"http://twitter.com/$1\">@$1</a>')\n            .replace(/#(\\S+)/g,\n                '<a target=\"_blank\" href=\"http://twitter.com/#!/search?q=%23$1\">#$1</a>');\n\n        return string;\n    }\n\n    // extrapolate URLs from the identified entities of the tweet\n    var entitiesArray = [];\n\n    if (entities.urls)\n    {\n        for (var i = 0, iLimit = entities.urls.length; i < iLimit; i++)\n        {\n            var entity = entities.urls[i];\n\n            var html = '<a href=\"' +\n                entity.url +\n                '\" title=\"' +\n                entity.expanded_url +\n                '\" target=\"_blank\">' +\n                entity.display_url +\n                '</a>';\n\n            entitiesArray.push(\n            {\n                html: html,\n                original: entity.url,\n                start: entity.indices[0],\n                end: entity.indices[1]\n            });\n        }\n    }\n\n    // extrapolate URLs from the identified entities of the tweet\n    if (entities.media)\n    {\n        for (var i = 0, iLimit = entities.media.length; i < iLimit; i++)\n        {\n            var entity = entities.media[i];\n\n            var html = '<a href=\"' +\n                entity.url +\n                '\" title=\"' +\n                entity.expanded_url +\n                '\" target=\"_blank\">' +\n                entity.display_url +\n                '</a>';\n\n            entitiesArray.push(\n            {\n                html: html,\n                original: entity.url,\n                start: entity.indices[0],\n                end: entity.indices[1]\n            });\n        }\n    }\n\n    if (entities.user_mentions)\n    {\n        for (var i = 0, iLimit = entities.user_mentions.length; i < iLimit; i++)\n        {\n            var entity = entities.user_mentions[i];\n\n            var url = PULSE.CLIENT.TwitterController.getUserAccountUrl(entity.screen_name);\n\n            var html = '<a href=\"' +\n                url +\n                '\" target=\"_blank\">&#64;' +\n                entity.screen_name +\n                '</a>';\n\n            entitiesArray.push(\n            {\n                html: html,\n                original: '@' + entity.screen_name,\n                start: entity.indices[0],\n                end: entity.indices[1]\n            });\n        }\n    }\n\n    if (entities.hashtags)\n    {\n        for (var i = 0, iLimit = entities.hashtags.length; i < iLimit; i++)\n        {\n            var entity = entities.hashtags[i];\n\n            var url = PULSE.CLIENT.TwitterController.getSearchTagUrl(entity.text);\n\n            var html = '<a href=\"' +\n                url +\n                '\" target=\"_blank\">&#35;' +\n                entity.text +\n                '</a>';\n\n            entitiesArray.push(\n            {\n                html: html,\n                original: '#' + entity.text,\n                start: entity.indices[0],\n                end: entity.indices[1]\n            });\n        }\n    }\n\n    /**\n     * Since the entities are ordered by type, sort the array by their start indice,\n     * so they are in the order of appearances\n     */\n    entitiesArray.sort(function(a, b)\n    {\n        return a.start - b.start;\n    });\n\n    // re-do start/end indices for entities\n    // this is a fix accounting for two-byte characters read as ASCII\n    for (var i = 0, iLimit = entitiesArray.length; i < iLimit; i++)\n    {\n        var entity = entitiesArray[i];\n\n        var lowercaseString = string.toLowerCase();\n        var lowercaseOriginal = entity.original.toLowerCase();\n        entity.start = lowercaseString.search( lowercaseOriginal );\n        entity.end = entity.start + entity.original.length;\n    }\n\n    /**\n     * The new tweet body, with anchor tags rather than just plain text\n     * @type {String}\n     */\n    var newString = '';\n\n    /**\n     * Used to determine where in the original tweet body we're last\n     * @type {Number}\n     */\n    var previousIdx = 0;\n\n    /**\n     * Go through all entities (if any) and replace their plain text version with\n     * their anchor-tag equivalents\n     * @type {Number}\n     */\n    for (var i = 0, iLimit = entitiesArray.length; i < iLimit; i++)\n    {\n        var entity = entitiesArray[i];\n        var length = entity.start - previousIdx;\n\n        newString += string.substr(previousIdx, length);\n        newString += entity.html;\n\n        previousIdx = entity.end;\n    }\n\n    /**\n     * At the end, add what's left of the original string\n     */\n    newString += string.substr(previousIdx);\n\n    return newString;\n}"},"parseTwitterDate":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"timestamp"}]},"Source":"PULSE.CLIENT.TwitterController.parseTwitterDate = function(timestamp)\n{\n    var date = new Date(Date.parse(timestamp));\n    if (K.ie)\n    {\n        date = Date.parse(timestamp.replace(/( \\+)/, ' UTC$1'))\n    }\n\n    return date;\n}"},"getMediaImg":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"entities"},{"title":"param","description":null,"type":null,"name":"index"}]},"Source":"PULSE.CLIENT.TwitterController.getMediaImg = function(entities, index)\n{\n\n    var idx = typeof index === 'undefined' ? 0 : index,\n        img;\n\n    for (var type in entities)\n    {\n\n        if (entities.hasOwnProperty(type) && type === 'media')\n        {\n\n            var media = entities[type],\n                entry = media[idx];\n\n            img = entry.media_url;\n        }\n    }\n\n    return img\n}"}},"REDIRECTOR":{"checkRedirectRequired":{"Documentation":{"description":"Check whether or not we require a redirect to a mobile site. First check screen size then check\nour mobile agent string.","tags":[]},"Source":"PULSE.CLIENT.REDIRECTOR.checkRedirectRequired = function( device )\n{\n    var isMobile = this.isMobileAgent() || this.isMobileScreenSize();\n    return device !== ( isMobile ? \"Mobile\" : \"Desktop\" );\n}"},"checkAndRedirect":{"Documentation":{"description":"Check whether or not we require a redirect to a mobile site and redirect by examining the\n'redirect_url' parameter.","tags":[{"title":"param","description":"map of params:\n  device_type: one of MOBILE or DESKTOP\n  mobile_redirect_url: the url to redirect to if we're a mobile site\n  desktop_redirect_url: the url to redirect to if we're a desktop site","type":null,"name":"configValues"}]},"Source":"PULSE.CLIENT.REDIRECTOR.checkAndRedirect = function( configValues )\n{\n    if ( this.checkRedirectRequired( configValues.device_type ) )\n    {\n        var isMobile = this.isMobileAgent() || this.isMobileScreenSize();\n        if ( isMobile )\n        {\n            window.location = configValues.mobile_redirect_url;\n        } else\n        { //assume desktop required.\n            window.location = configValues.desktop_redirect_url;\n        }\n    }\n}"},"isMobileAgent":{"Documentation":{"description":"Is our browser agent registered as a mobile client?","tags":[{"title":"returns","description":"true or false depending on our","type":{"type":"NameExpression","name":"boolean"}}]},"Source":"PULSE.CLIENT.REDIRECTOR.isMobileAgent = function()\n{\n    var agent = navigator.userAgent.toLowerCase();\n    return /(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i.test(agent) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\\-(n|u)|c55\\/|capi|ccwa|cdm\\-|cell|chtm|cldc|cmd\\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\\-s|devi|dica|dmob|do(c|p)o|ds(12|\\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\\-|_)|g1 u|g560|gene|gf\\-5|g\\-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd\\-(m|p|t)|hei\\-|hi(pt|ta)|hp( i|ip)|hs\\-c|ht(c(\\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\\-(20|go|ma)|i230|iac( |\\-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc\\-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|\\-[a-w])|libw|lynx|m1\\-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m\\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\\-2|po(ck|rt|se)|prox|psio|pt\\-g|qa\\-a|qc(07|12|21|32|60|\\-[2-7]|i\\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\\-|oo|p\\-)|sdk\\/|se(c(\\-|0|1)|47|mc|nd|ri)|sgh\\-|shar|sie(\\-|m)|sk\\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\\-|v\\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\\-|tdg\\-|tel(i|m)|tim\\-|t\\-mo|to(pl|sh)|ts(70|m\\-|m3|m5)|tx\\-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\\-|your|zeto|zte\\-/i.test(agent.substr(0, 4));\n        //console.log(\"Navigator: \" + navigator.userAgent);\n        // return /(iphone|ipod|ipad|android|blackberry|windows ce|palm|symbian)/i.test(navigator.userAgent);\n}"},"isTabletAgent":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"PULSE.CLIENT.REDIRECTOR.isTabletAgent"}]},"Source":"PULSE.CLIENT.REDIRECTOR.isTabletAgent = function()\n{\n    var agent = navigator.userAgent.toLowerCase();\n    var pattern = \"(iPad|SCH-I|xoom|NOOK|silk|kindle|GT-P|touchpad|kindle|sch-t|viewpad|bolt|playbook)/i\";\n    var regularExpr = new RegExp(pattern);\n    return (!!(agent.match( regularExpr ) ) );\n}"},"isMobileScreenSize":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.CLIENT.REDIRECTOR.isMobileScreenSize = function ()\n{\n    return screen.width <= 699 ;\n}"}},"Util":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"PULSE.CLIENT.Util"}]},"Source":"PULSE.CLIENT.Util = function()\n{}","getValueOrBlank":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"value"}]},"Source":"PULSE.CLIENT.Util.getValueOrBlank = function( value )\n{\n\tif ( value === null )\n\t{\n\t    return '';\n\t}\n\telse\n\t{\n\t\treturn value;\n\t}\n}"},"getValueOrNBSP":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"value"}]},"Source":"PULSE.CLIENT.Util.getValueOrNBSP = function( value )\n{\n\tif ( value === null )\n\t{\n\t    return '&nbsp';\n\t}\n\telse\n\t{\n\t\treturn value;\n\t}\n}"},"CreatePlayerLookup":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"teams"},{"title":"param","description":null,"type":null,"name":"withTeam"}]},"Source":"PULSE.CLIENT.Util.CreatePlayerLookup = function( teams, withTeam )\n{\n\tvar playerLookup = {};\n\tfor ( var i = 0, ilimit = teams.length; i < ilimit; i++ )\n\t{\n\t\tvar team = teams[i];\n\t\tvar players = team.players;\n\t\tif( players )\n\t\t{\n\t\t\tfor ( var j = 0, jlimit = players.length; j < jlimit; j++ )\n\t\t\t{\n\t\t\t\tvar player = players[j];\n\t\t\t\tif( withTeam )\n\t\t\t\t{\n\t\t\t\t\tplayer.teamIds = [ team.team.id ];\n\t\t\t\t}\n\t\t\t\tplayerLookup[ player.id ] = player;\n\t\t\t}\n\t\t}\n\t}\n\treturn playerLookup;\n}"},"CreateSquadToMatchesLookup":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"schedule"},{"title":"param","description":null,"type":null,"name":"tournamentName"}]},"Source":"PULSE.CLIENT.Util.CreateSquadToMatchesLookup = function( schedule, tournamentName )\n{\n\tvar squadsLookup = {};\n\tfor ( var i = 0, ilimit = schedule.length; i < ilimit; i++ )\n\t{\n\t\tvar match = schedule[i],\n\t\t\tteam1 = match.team1,\n\t\t\tteam2 = match.team2;\n\n\t\tif( team1 && team2\n\t\t\t&& team1.team\n\t\t\t&& team2.team )\n\t\t{\n\t\t\tif( !squadsLookup[ team1.team.id ] )\n\t\t\t{\n\t\t\t\tsquadsLookup[ team1.team.id ] = [];\n\t\t\t}\n\t\t\tsquadsLookup[ team1.team.id ].push( {\n\t\t\t\tmatchId: match.matchId.name ,\n\t\t\t\ttournamentName: tournamentName\n\t\t\t} );\n\n\t\t\tif( !squadsLookup[ team2.team.id ] )\n\t\t\t{\n\t\t\t\tsquadsLookup[ team2.team.id ] = [];\n\t\t\t}\n\t\t\tsquadsLookup[ team2.team.id ].push( {\n\t\t\t\tmatchId: match.matchId.name ,\n\t\t\t\ttournamentName: tournamentName\n\t\t\t} );\n\t\t}\n\t}\n\treturn squadsLookup;\n}"},"GetCurrentInnings":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"data"}]},"Source":"PULSE.CLIENT.Util.GetCurrentInnings = function( data )\n{\n\tvar innings = null;\n\tif ( data.innings && data.currentState )\n\t{\n\t\tinnings = data.innings[ data.currentState.currentInningsIndex ];\n\t}\n\treturn innings;\n}"},"isInt":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"number"}]},"Source":"PULSE.CLIENT.Util.isInt = function( number )\n{\n\treturn typeof(number)=='number'&&parseInt(number)==number;\n}"},"isUpcomingMatch":{"Documentation":{"description":"Function which determines whether a certain match is upcoming","tags":[{"title":"param","description":"index","type":null,"name":"match"}]},"Source":"PULSE.CLIENT.Util.isUpcomingMatch = function( index, schedule )\n{\n\tvar match = schedule[ index ];\n\tif( match.matchState === \"U\" )\n\t{\n\t\treturn PULSE.CLIENT.DateUtil.parseDateTime( match.matchDate );\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}"},"GetTeamAbbr":{"Documentation":{"description":"This method retrieves team abbreviation based on the index (0|1) in their original case.","tags":[]},"Source":"PULSE.CLIENT.Util.GetTeamAbbr = function ( data, index )\n{\n\tvar teamObj = data.teams[ index ];\n\tif ( teamObj )\n\t{\n\t\treturn teamObj.team.abbreviation;\n\t}\n\n\treturn '';\n}"},"GetBattingTeamObject":{"Documentation":{"description":"Returns an object that wraps batting team related data.","tags":[]},"Source":"PULSE.CLIENT.Util.GetBattingTeamObject = function( data, inningsIdx )\n{\n\tvar teamIdx = data.matchInfo.battingOrder[ inningsIdx ];\n\treturn data.matchInfo.teams[ teamIdx ];\n}"},"getMatchDuration":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"durations"}]},"Source":"PULSE.CLIENT.Util.getMatchDuration = function( durations )\n{\n\tif(durations)\n\t{\n\t\tvar minutes = 0;\n\t\tvar formattedTime = '';\n\n\t\tfor( var i = 0; i < durations.length; i++ )\n\t\t{\n\t\t\tif( !isNaN( parseInt( durations[i] ) ) )\n\t\t\t{\n\t\t\t\tminutes = minutes + parseInt( durations[i] );\n\t\t\t}\n\t\t}\n\n\t\tvar hr = Math.floor( minutes / 60 );\n\t\tvar min = Math.floor( ( minutes % 60 ) );\n\n\t\tif( minutes === 0 )\n\t\t{\n\t\t    return '';\n\t\t}\n\t\telse if( hr === 0 && min !== 0 )\n\t\t{\n\t\t    return min + 'm';\n\t\t}\n\t\telse if(  hr !== 0 && min === 0 )\n\t\t{\n\t\t    return hr + 'h';\n\t\t}\n\t\telse\n\t\t{\n\t\t    return  hr + 'h ' + min + 'm';\n\t\t}\n\t}\n\treturn '';\n}"},"getParamValueByName":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"name"}]},"Source":"PULSE.CLIENT.Util.getParamValueByName = function( name )\n{\n\tif( name )\n\t{\n\t\tvar paramVal = unescape((RegExp(name + '=' + '(.+?)(&|$)').exec(location.search)||[,null])[1]);\n\n\t\treturn paramVal;\n\t}\n\n\treturn 'null';\n}"},"getDataFromJsonCallback":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"data"}]},"Source":"PULSE.CLIENT.Util.getDataFromJsonCallback = function( data )\n{\n\tvar dataObj = data[0];\n\tif ( dataObj )\n\t{\n\t\tif ( dataObj.success )\n\t\t{\n\t\t\treturn dataObj.params;\n\t\t}\n\t}\n\n\treturn null;\n}"},"applyActiveClass":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"selector"},{"title":"param","description":null,"type":null,"name":"selectedIndex"},{"title":"param","description":null,"type":null,"name":"className"}]},"Source":"PULSE.CLIENT.Util.applyActiveClass = function( selector, selectedIndex, className )\n{\n\t$( selector ).removeClass( className );\n\t$( selector ).eq( selectedIndex ).addClass( className );\n}"},"parseUrlParameters":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.CLIENT.Util.parseUrlParameters = function ()\n{\n\tvar url = window.location.href;\n\tvar params = {};\n\tvar idx = url.indexOf( '?' );\n\tif ( idx > -1 )\n\t{\n\t\tvar paramString = url.substr( idx + 1 );\n\t\tvar paramArray = paramString.split( '&' );\n\t\tfor ( var i = 0, ilimit = paramArray.length; i < ilimit; i++ )\n\t\t{\n\t\t\tvar param = paramArray[i];\n\t\t\tvar eq = param.indexOf( '=' );\n\n\t\t\tif ( eq > -1 )\n\t\t\t{\n\t\t\t\tvar key = unescape( param.slice( 0, eq ) );\n\t\t\t\tvar val = param.slice( eq + 1 ).split('#');\n\t\t\t\tval = unescape( val[0] );\n\t\t\t\tparams[ key ] = val;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tparams[ unescape( param ) ] = true;\n\t\t\t}\n\t\t}\n\t}\n\treturn params;\n}"},"isEmptyObject":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"obj"}]},"Source":"PULSE.CLIENT.Util.isEmptyObject = function( obj )\n{\n\tvar counter = 0;\n\n\tfor( var property in obj )\n\t{\n\t\tcounter++;\n\t}\n\n\treturn counter === 0;\n}"},"isSimilarArray":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"arr1"},{"title":"param","description":null,"type":null,"name":"arr2"}]},"Source":"PULSE.CLIENT.Util.isSimilarArray = function( arr1, arr2 )\n{\n\tif ( arr1 && arr2 )\n\t{\n\t\treturn $(arr1).not(arr2).length === 0 && $(arr2).not(arr1).length === 0;\n\t}\n\n\treturn false;\n}"},"objectFoundById":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"arr"},{"title":"param","description":null,"type":null,"name":"obj"}]},"Source":"PULSE.CLIENT.Util.objectFoundById = function ( arr, obj )\n{\n\tfor ( var i = 0; i < arr.length; i++ )\n\t{\n\t\tvar t = arr[i];\n\t\tif ( obj.id === t.id )\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}"},"getFormattedDate":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"ISO8601DateString"},{"title":"param","description":null,"type":null,"name":"desiredFormat"}]},"Source":"PULSE.CLIENT.Util.getFormattedDate = function ( ISO8601DateString, desiredFormat )\n{\n\tvar matchDate = PULSE.CLIENT.DateUtil.parseDateTime( ISO8601DateString );\n\t//console.log(ISO8601DateString + ' ---- ' + matchDate);\n\tif ( matchDate )\n\t{\n\t\treturn matchDate.format( desiredFormat || 'dd mmmm yyyy' );\n\t}\n\treturn \"\";\n}"},"$hide":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"$element"}]},"Source":"PULSE.CLIENT.Util.$hide = function( $element )\n{\n\t$element.css({ position: \"absolute\", visibility: \"hidden\", display: \"block\" });\n}"},"$show":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"$element"}]},"Source":"PULSE.CLIENT.Util.$show = function( $element )\n{\n\t$element.css({ position: \"\", visibility: \"\", display: \"\" });\n}"},"getPlayerNames":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"fullName"}]},"Source":"PULSE.CLIENT.Util.getPlayerNames = function( fullName )\n{\n\tvar names \t\t= fullName.split( ' ' ),\n\t\tfirstName\t= names[0],\n\t\tsecondName \t= names.slice( 1 ).join( ' ' );\n\n\treturn {firstName : firstName, secondName : secondName };\n}"},"toOrdinal":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"n"},{"title":"param","description":null,"type":null,"name":"$wrap"}]},"Source":"PULSE.CLIENT.Util.toOrdinal = function( n, $wrap )\n{\n    var s = [\"th\",\"st\",\"nd\",\"rd\"],\n    \tv = n % 100;\n\n    if( typeof $wrap === \"undefined\" )\n    {\n    \treturn n+(s[(v-20)%10]||s[v]||s[0]);\n    }\n    else\n    {\n    \treturn n + $('<div>').append($wrap.text( s[(v-20)%10]||s[v]||s[0] )).html();\n    }\n}"},"layerIdxInArray":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"array"},{"title":"param","description":null,"type":null,"name":"id"}]},"Source":"PULSE.CLIENT.Util.layerIdxInArray = function( array, id )\n{\n\tfor( var i = 0; i < array.length; i++ )\n\t{\n\t\tif( array[i].playerId === id )\n\t\t{\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}"},"keyFromValue":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"object"},{"title":"param","description":null,"type":null,"name":"value"}]},"Source":"PULSE.CLIENT.Util.keyFromValue = function( object, value )\n{\n\tfor( var property in object )\n\t{\n\t\tif( object[property] === value )\n\t\t{\n\t\t\treturn property;\n\t\t}\n\t}\n}"},"addCommaForThousands":{"Documentation":{"description":"","tags":[{"title":"deprecated","description":"Use commafy instead"}]},"Source":"PULSE.CLIENT.Util.addCommaForThousands = function( number )\n{\n\tif( number === \"0\" )\n\t{\n\t\treturn \"0\";\n\t}\n\n\tvar output = [],\n\t\tremainder = number % 1000,\n\t\tresult = Math.floor( number / 1000 );\n\n\tvar normaliseRemainder = function( remainder )\n\t{\n\t\tif( remainder < 100 )\n\t\t{\n\t\t\tif( remainder < 10 )\n\t\t\t{\n\t\t\t\tremainder = \"00\" + remainder;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tremainder = \"0\" + remainder;\n\t\t\t}\n\t\t}\n\n\t\treturn remainder;\n\t};\n\n\toutput.push( result ? normaliseRemainder(remainder) : remainder );\n\twhile( result )\n\t{\n\t\tremainder = result % 1000;\n\t\tresult = Math.floor( result / 1000 );\n\t\toutput.push( result ? normaliseRemainder(remainder) : remainder );\n\t}\n\n\treturn output.reverse().join(',');\n}","normaliseRemainder":{"Documentation":{"description":"","tags":[{"title":"deprecated","description":"Use commafy instead"}]},"Source":"var normaliseRemainder = function( remainder )\n\t{\n\t\tif( remainder < 100 )\n\t\t{\n\t\t\tif( remainder < 10 )\n\t\t\t{\n\t\t\t\tremainder = \"00\" + remainder;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tremainder = \"0\" + remainder;\n\t\t\t}\n\t\t}\n\n\t\treturn remainder;\n\t}"}},"commafy":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"value"}]},"Source":"PULSE.CLIENT.Util.commafy = function ( value )\n{\n\tif ( typeof value === 'undefined' )\n\t{\n\t\treturn '';\n\t}\n\treturn value.toString().replace( /.(?=(?:.{3})+$)/g, '$&,' );\n}"},"getArrayFromString":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"string"}]},"Source":"PULSE.CLIENT.Util.getArrayFromString = function( string )\n{\n\tif( !string )\n\t{\n\t\treturn [];\n\t}\n\n\tvar array = string.split(',');\n\tfor( var i = 0; i < array.length; i++ )\n\t{\n\t\tarray[i] = $.trim( array[i] );\n\t}\n\treturn array;\n}"},"prepareParams":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"params"}]},"Source":"PULSE.CLIENT.Util.prepareParams = function( params )\n{\n\tvar paramsArray = [];\n    $.each( params, function( key, value ) {\n    \t// only add param if its value exists\n    \t// if the value's an array, make sure it's not empty\n    \tif( typeof value !== 'undefined' && ( Object.prototype.toString.call( value ) !== '[object Array]' || value.length ) )\n    \t{\n    \t\tvalue = [].concat( value ).join(\",\");\n\t        var keyValuePair = [ key, encodeURIComponent( value ) ];\n\t        paramsArray.push( keyValuePair.join(\"=\") );\n    \t}\n    } );\n\n    return \"?\" + paramsArray.join( \"&\" );\n}"},"getSafeCssClass":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"teamAbbr"}]},"Source":"PULSE.CLIENT.Util.getSafeCssClass = function(teamAbbr) {\n\treturn teamAbbr.split('&').join('');\n}"},"getKeyValuesFromString":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"string"},{"title":"param","description":null,"type":null,"name":"delimiter"}]},"Source":"PULSE.CLIENT.Util.getKeyValuesFromString = function(string, delimiter)\n{\n\tvar parts = string.split(delimiter),\n\t\tretObj = {};\n\n\t for (var i=0, length = parts.length; i < length; i++)\n\t {\n\t \tvar thisPart = parts[i];\n\t \tvar keyVal = thisPart.split(':');\n\n\t \tretObj[keyVal[0]] = keyVal[1];\n\t }\n\n\treturn retObj;\n}"},"isScoringID":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"meta"}]},"Source":"PULSE.CLIENT.Util.isScoringID = function(meta)\n{\n\tif (meta.fileName && meta.fileName === 'scoring')\n\t{\n\t\treturn true;\n\t}\n}"},"isEmpty":{"Documentation":{"description":"Given a jQuery element, it establishes whether it's empty or not","tags":[{"title":"param","description":null,"type":{"type":"NameExpression","name":"Object"},"name":"$el"},{"title":"return","description":"true if the element is empty (or only has spaces), false otherwise","type":{"type":"NameExpression","name":"Boolean"}}]},"Source":"PULSE.CLIENT.Util.isEmpty = function( $el )\n{\n    return !$.trim( $el.html() );\n}"},"getFontSize":{"Documentation":{"description":"Gets the font size of the body; used to do em to px and vice versa conversions","tags":[{"title":"return","description":"the font size, or undefined, if somehow no font size","type":{"type":"NameExpression","name":"Number"}}]},"Source":"PULSE.CLIENT.Util.getFontSize = function()\n{\n\tvar size = parseFloat( $( 'body' ).css( 'font-size' ) );\n\n\tif( !isNaN( size ) )\n\t{\n\t\treturn size;\n\t}\n}"},"emToPx":{"Documentation":{"description":"Converts em to pixels based on the page's font size; it defaults\nto 16px per em if no font size can be detected","tags":[{"title":"param","description":"value in em to be converted","type":{"type":"NameExpression","name":"Number"},"name":"em"},{"title":"return","description":"value in pixels","type":{"type":"NameExpression","name":"Number"}}]},"Source":"PULSE.CLIENT.Util.emToPx = function( em )\n{\n\tvar fontSize = PULSE.CLIENT.Util.getFontSize() || 16;\n\treturn fontSize * em;\n}"},"pxToEm":{"Documentation":{"description":"Converts pixels to em based on the page's font size; it defaults\nto 16px per em if no font size can be detected","tags":[{"title":"param","description":"value in em to be converted","type":{"type":"NameExpression","name":"Number"},"name":"px"},{"title":"return","description":"value in em","type":{"type":"NameExpression","name":"Number"}}]},"Source":"PULSE.CLIENT.Util.pxToEm = function( px )\n{\n\tvar fontSize = PULSE.CLIENT.Util.getFontSize() || 16;\n\treturn px / fontSize;\n}"}},"VIDEOSCROLL":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"PULSE.CLIENT.VIDEOSCROLL"},{"title":"param","description":null,"type":null,"name":"container"}]},"Source":"PULSE.CLIENT.VIDEOSCROLL = function( container ) /*Container must be and ID*/\n{\n\tthis.container = container;\n\tthis.$container = $( container );\n\t// this.$tomove = $( container ).find('.video-to-move');\n\tthis.containerHeight = this.$container.outerHeight();\n\n\tthis.addListener();\n}","prototype":{"addListener":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.CLIENT.VIDEOSCROLL.prototype.addListener = function()\n{\n\tvar that = this;\n\tthis.$container.find('.video-scroll-trigger').waypoint(function(direction) {\n\t\tif( direction === 'up' )\n\t\t{\n\t\t\tthat.expand()\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthat.reduce();\n\t\t}\n\t});\n}"},"reduce":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.CLIENT.VIDEOSCROLL.prototype.reduce = function()\n{\n\tthis.$container.css( 'height',this.containerHeight );\n\n\tthis.$container.addClass('video-scroll-reduced');\n}"},"expand":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.CLIENT.VIDEOSCROLL.prototype.expand = function()\n{\n\tthis.$container.css( 'height','' );\n\n\tthis.$container.removeClass('video-scroll-reduced');\n}"}}},"XmlDataManager":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"PULSE.CLIENT.XmlDataManager"}]},"Source":"PULSE.CLIENT.XmlDataManager = function ()\r\n{\r\n\tthis.urls = {};\r\n}","prototype":{"addFeed":{"Documentation":{"description":"Note that the interval is in SECONDS, and will be multiplied by 1000 to derive a millisecond\r\nvalue.","tags":[]},"Source":"PULSE.CLIENT.XmlDataManager.prototype.addFeed = function ( id, url, interval, targets )\r\n{\r\n    var currentTargets = this.urls[url] && this.urls[url].savedTargets ? this.urls[url].savedTargets : [];\r\n    \r\n\t// Remove any existing feed with this ID\r\n\tthis.removeFeed( url );\r\n\r\n\t// Save the callback name\r\n\tthis.urls[url] = { id:id, url:url, interval:interval };\r\n    \r\n    // Add all the targets to the current targets\r\n    for ( var i = 0, limit = targets.length; i < limit; i++ )\r\n    {\r\n        var needToAdd = true;\r\n        for ( var j = 0, jLimit = currentTargets.length; j < jLimit; j++ )\r\n        {\r\n            if ( targets[ i ] === currentTargets[ j ] )\r\n            {\r\n                needToAdd = false;\r\n                break;\r\n            }\r\n        }\r\n        if ( needToAdd )\r\n        {\r\n            currentTargets.push( targets[ i ] );\r\n        }\r\n    }\r\n    \r\n    this.urls[url].savedTargets = currentTargets;\r\n\t\r\n\t// Dynamically create the callback method\r\n\tvar that = this;\r\n\tvar f = function ( jsonpData )\r\n\t{\r\n\t\tif ( jsonpData )\r\n\t\t{\r\n\t\t\tvar payload = jsonpData.rss ? jsonpData : $.parseJSON( jsonpData );\r\n\t\t\t\r\n\t\t\t// Serialise the payload\r\n\t\t\tvar serialised = jsonpData;\r\n\t\t    if ( that.urls[url] && that.urls[url].lastData !== serialised )\r\n\t\t    {\r\n\t\t    \t// Save the new data\r\n\t\t    \tthat.urls[url].lastData = serialised;\r\n\t\t\t\t// Pass the data to all of the targets...\r\n\t\t\t\tfor ( var t = 0, tlimit = currentTargets.length; t < tlimit; t++ )\r\n\t\t\t\t{\r\n\t\t\t\t\t// ...if they are valid\r\n\t\t\t\t\tvar target = currentTargets[t];\r\n\t\t\t\t\tif ( target && target.onData )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\ttry\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\ttarget.onData( payload, id );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcatch(e)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif( window.console && window.console.log ) console.log(e);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t    }\r\n\t\t}\r\n\t};\r\n\t\r\n\tvar e = function ( )\r\n\t{\r\n\t\tfor ( var t = 0, tlimit = currentTargets.length; t < tlimit; t++ )\r\n\t\t{\r\n\t\t\t// ...if they are valid\r\n\t\t\tvar target = currentTargets[t];\r\n\t\t\tif ( target && target.onError )\r\n\t\t\t{\r\n\t\t\t\ttarget.onError( id );\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\t\r\n\t// Create the timer\r\n\tthat.urls[url].timer = new PULSE.CLIENT.XmlTimer( this.urls[url], f, e );\r\n}","f":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"jsonpData"}]},"Source":"var f = function ( jsonpData )\r\n\t{\r\n\t\tif ( jsonpData )\r\n\t\t{\r\n\t\t\tvar payload = jsonpData.rss ? jsonpData : $.parseJSON( jsonpData );\r\n\t\t\t\r\n\t\t\t// Serialise the payload\r\n\t\t\tvar serialised = jsonpData;\r\n\t\t    if ( that.urls[url] && that.urls[url].lastData !== serialised )\r\n\t\t    {\r\n\t\t    \t// Save the new data\r\n\t\t    \tthat.urls[url].lastData = serialised;\r\n\t\t\t\t// Pass the data to all of the targets...\r\n\t\t\t\tfor ( var t = 0, tlimit = currentTargets.length; t < tlimit; t++ )\r\n\t\t\t\t{\r\n\t\t\t\t\t// ...if they are valid\r\n\t\t\t\t\tvar target = currentTargets[t];\r\n\t\t\t\t\tif ( target && target.onData )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\ttry\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\ttarget.onData( payload, id );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcatch(e)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif( window.console && window.console.log ) console.log(e);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t    }\r\n\t\t}\r\n\t}"},"e":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"var e = function ( )\r\n\t{\r\n\t\tfor ( var t = 0, tlimit = currentTargets.length; t < tlimit; t++ )\r\n\t\t{\r\n\t\t\t// ...if they are valid\r\n\t\t\tvar target = currentTargets[t];\r\n\t\t\tif ( target && target.onError )\r\n\t\t\t{\r\n\t\t\t\ttarget.onError( id );\r\n\t\t\t}\r\n\t\t}\r\n\t}"}},"startAll":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.CLIENT.XmlDataManager.prototype.startAll = function ()\r\n{\r\n\tfor ( var url in this.urls )\r\n\t{\r\n\t\tthis.start( url );\r\n\t}\r\n}"},"stopAll":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.CLIENT.XmlDataManager.prototype.stopAll = function ()\r\n{\r\n\tfor ( var url in this.urls )\r\n\t{\r\n\t\tthis.stop( url );\r\n\t}\r\n}"},"start":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"url"}]},"Source":"PULSE.CLIENT.XmlDataManager.prototype.start = function ( url )\r\n{\r\n\tif ( this.urls[url] && this.urls[url].timer )\r\n\t{\r\n\t\tthis.urls[url].timer.start();\r\n\t}\r\n}"},"stop":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"url"}]},"Source":"PULSE.CLIENT.XmlDataManager.prototype.stop = function ( url )\r\n{\r\n\tif ( this.urls[url] && this.urls[url].timer )\r\n\t{\r\n\t\tthis.urls[url].timer.stop();\r\n\t}\r\n}"},"removeFeed":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"url"}]},"Source":"PULSE.CLIENT.XmlDataManager.prototype.removeFeed = function ( url )\r\n{\r\n\tthis.stop( url );\r\n\t\r\n\tif ( this.urls[url] )\r\n\t{\r\n\t\tthis.urls[url] = undefined;\r\n\t}\r\n\t\r\n}"}}},"XmlTimer":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"PULSE.CLIENT.XmlTimer"},{"title":"param","description":null,"type":null,"name":"params"},{"title":"param","description":null,"type":null,"name":"f"},{"title":"param","description":null,"type":null,"name":"e"}]},"Source":"PULSE.CLIENT.XmlTimer = function( params, f, e )\n{\n\tthis.initialise( params || {}, f, e );\n\n\tthis.running = false;\n}","prototype":{"initialise":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"params"},{"title":"param","description":null,"type":null,"name":"f"},{"title":"param","description":null,"type":null,"name":"e"}]},"Source":"PULSE.CLIENT.XmlTimer.prototype.initialise = function( params, f, e )\n{\n\tthis.url = params.url || '';\n\tthis.interval = params.interval * 1000 || '';\n\tthis.params = params.params || {};\n\tthis.callbackName = params.callback || '';\n\tthis.callback = f;\n\tthis.errorCallback = e;\n\tthis.name = params.id || 'un-named';\n}"},"start":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.CLIENT.XmlTimer.prototype.start = function()\n{\n\tif ( !this.running )\n\t{\n\t\tthis.running = true;\n\t\tthis.fireTimer( );\n\t}\n}"},"stop":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.CLIENT.XmlTimer.prototype.stop = function()\n{\n\tif ( this.running )\n\t{\n\t\tthis.running = false;\n\t\tthis.cancelTimer( );\n\t}\n}"},"fireTimer":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.CLIENT.XmlTimer.prototype.fireTimer = function()\n{\n\tvar that = this;\n\n\t$.get(\n\t\tthat.url,\n\t\tfunction( data )\n\t\t{\n\t\t\tthat.cancelTimer( );\n\t\t\tif ( that.interval > 0 && that.running )\n\t\t\t{\n\t\t\t\tthat.timer = setTimeout( function()\n\t\t\t\t{\n\t\t\t\t\tthat.fireTimer( );\n\t\t\t\t}, that.interval );\n\t\t\t}\n\t\t\tthat.callback( $.xmlToJSON( data ) );\n\t\t}\n\t)\n\t.error( function()\n\t\t{\n\t\t\tthat.errorCallback( );\n\t\t\tif ( that.interval > 0 && that.running )\n\t\t\t{\n\t\t\t\tthat.timer = setTimeout( function()\n\t\t\t\t{\n\t\t\t\t\tthat.fireTimer( );\n\t\t\t\t}, that.interval );\n\t\t\t}\n\t\t}\n\t);\n}"},"cancelTimer":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.CLIENT.XmlTimer.prototype.cancelTimer = function()\n{\n\tif ( this.timer )\n\t{\n\t\tclearTimeout( this.timer );\n\t}\n}"}}},"Map":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"PULSE.CLIENT.Map"},{"title":"param","description":null,"type":null,"name":"options"}]},"Source":"PULSE.CLIENT.Map = function( options ){\n    \n    this.container = document.getElementById(options.id_container);\n    this.box_width = options.box_width\n    this.lat = options.lat || 0;\n    this.leng = options.leng || 0;\n    this.zoom = options.zoom || 1;\n    this.markers = [];\n\n    if(options.icon){\n    \tvar marker_icon = new google.maps.MarkerImage(options.icon, null, null, null, new google.maps.Size(30,42));\n    }\n    this.icon = marker_icon || undefined;\n\n\tthis.container.style.width = options.width || '100%';\n    this.container.style.height = options.height || '600px';\n\n    this.coordinates = new google.maps.LatLng(this.lat, this.leng);\n\n    this.myMapOptions = {\n       \tzoom: this.zoom,\n      \tcenter: this.coordinates,\n      \tmapTypeId: google.maps.MapTypeId.ROADMAP\n    };\n\n    this.map = new google.maps.Map(this.container, this.myMapOptions);\n    //console.log(options.list);\n    for (var i = 0; i < options.list.length; i++) {\n    \t//console.log(options.list[i]);\n    \tthis.createPins( options.list[i], i );\n    };\n\n}","prototype":{"createPins":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"item"},{"title":"param","description":null,"type":null,"name":"item_index"}]},"Source":"PULSE.CLIENT.Map.prototype.createPins = function( item, item_index ){\n\n\tconsole.log(item);\n\tvar that = this;\n\n\n\tvar marker = new google.maps.Marker({\n\t    map: this.map,\n\t    draggable: false,\n\t    raiseOnDrag: false,\n\t    icon: this.icon,\n\t    animation: google.maps.Animation.DROP,\n\t    position: new google.maps.LatLng(item.lat, item.leng)\n\t  });\n\n\tthis.markers.push(marker);\n\n  \tvar html = \n  \t\titem.html ||\n  \t\t'<div class=\"pin_arrow_box\" style=\"width:' + this.box_width + 'px;\"\">' +\n\t        '<div class=\"pin_header\">' + item.name + '</div>' +\n\t        '<div class=\"pin_content\">' +\n\t          \t'<div class=\"pin_img\" style=\"background-image: url(' + item.img + ');\"/>' +\n\t          \t'<div class=\"pin_txt\">' +\n                \t'<div class=\"pin_txt_h1\">' + item.h1 + '</div>' +\n                \t'<div class=\"pin_txt_h2\">' + item.h1 + '</div>' +\n                \t'<a href=' + item.link + ' class=\"pin_txt_button\">' + item.link_txt + '</a>' +\n              \t'</div>' +\n\t        '</div>' +\n      \t'</div>';\n\n  \tvar pin = document.createElement(\"div\");\n  \tpin.innerHTML = html;\n\n\tvar infoBox_options = {\n\t    content: pin,\n\t    disableAutoPan: false,\n\t    pixelOffset: new google.maps.Size(-(this.box_width/2), 18),\n\t    closeBoxMargin: \"10px 8px 2px 2px\",\n\t    closeBoxURL: \"../../../resources/target/i/1/map-assets/close.png\",\n\t    infoBoxClearance: new google.maps.Size(1, 1),\n\t    isHidden: false,\n\t    pane: \"floatPane\",\n\t    enableEventPropagation: false\n\t };\n\n  \tthis.markers[item_index].infoBox = new InfoBox(infoBox_options);\n\n\tgoogle.maps.event.addListener(marker, \"click\", (function (marker, i) {\n\t\treturn function () {\n\t\t    for (h = 0; h < that.markers.length; h++) {\n\t            that.markers[h].infoBox.close();\n\t        }\n\t        that.markers[i].infoBox.open(that.map, this);\n\t    };\n\t})(marker, item_index));\n}"}}},"PollController":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"PULSE.CLIENT.PollController"},{"title":"param","description":null,"type":null,"name":"target"},{"title":"param","description":null,"type":null,"name":"url"},{"title":"param","description":null,"type":null,"name":"interval"},{"title":"param","description":null,"type":null,"name":"params"}]},"Source":"PULSE.CLIENT.PollController = function( target, url, interval, params )\n{\n\tthis.PLAY2_URL = \"http://play2.pulselive.com/\";\n\tthis.pollModel = target;\n\tthis.lastData = \"\";\t\n\tthis.pollTimer = new PULSE.CLIENT.NewJSONPTimer( url, interval, params );\n\n\tthis.answeredQuestions = new PULSE.CLIENT.Set();\n\tvar ansCookieValue = PULSE.CLIENT.Cookie.getCookieByKey('pulseAnsCookie')\n\tif ( ansCookieValue.length > 0 )\n\t{\n\t\tthis.answeredQuestions = PULSE.CLIENT.Set.fromString(ansCookieValue);\n\t}\n\n\tvar that = this;\n\tPULSE.CLIENT.PollController.getInstance = function () { return that; };\n\t\n\tthis.pollTimer.start();\n}","getInstance":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.CLIENT.PollController.getInstance = function () { return that; }"},"prototype":{"onData":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"pollData"},{"title":"param","description":null,"type":null,"name":"id"}]},"Source":"PULSE.CLIENT.PollController.prototype.onData = function( pollData, id )\n{\t\n\tvar thisInstance = PULSE.CLIENT.PollController.getInstance();\n\t\n\tif ( pollData && pollData[0] )\n\t{\n\t\tvar payload = pollData[0];\n\t\t\n\t\t// Serialise the payload\n\t\tvar serialised = $.toJSON( payload );\n\t\t\n\t    if ( thisInstance.lastData !== serialised )\n\t    {\n\t    \t// Save the new data\n\t    \tthisInstance.lastData = serialised;\n\t    \tthisInstance.pollModel.modelChanged( pollData[0] );\n\t    }\n\t}\n}"},"answerQuestion":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"answerIndex"},{"title":"param","description":null,"type":null,"name":"id"}]},"Source":"PULSE.CLIENT.PollController.prototype.answerQuestion = function( answerIndex, id )\n{\n\tvar that = this;\n\t/* add this que id to answeredQuestions Set and store that Set in ever expiring cookie */\n\tthis.answeredQuestions.add( id );\t\n\tdocument.cookie = \n\t\t'pulseAnsCookie=' + this.answeredQuestions.toString() + ';expires=30/12/2051 00:00:00';\t\n\t/* inform CMS about this */\n\t$.ajax(\n\t{\n\t\tdataType: 'jsonp',\n\t    url: that.PLAY2_URL + 'cms/answerQuestion',  //?questionId=1&option=0',\n\t    data: { questionId: id, option: answerIndex }\t    \n\t} );\n}"}}},"PollModel":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"PULSE.CLIENT.PollModel"},{"title":"param","description":null,"type":null,"name":"parent"}]},"Source":"PULSE.CLIENT.PollModel = function( parent )\n{\t\t\n\tthis.pulse = parent;\n\tthis.popupTimestamp;\n}","prototype":{"modelChanged":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"data"}]},"Source":"PULSE.CLIENT.PollModel.prototype.modelChanged = function( data )\n{\n\tif ( this.pulse.pollView )\n\t{\n\t\tthis.pulse.pollView.opinion = data.results;\t\t\n\t\tthis.pulse.pollView.refreshData();\n\t\t\t\t\n\t\t// Further check for timestamp, if changed then only update/show pop-up box\n\t\tif ( data.popupQuestionId && data.timestamp && this.popupTimestamp !== data.timestamp )\n\t\t{\n\t\t\tthis.pulse.pollView.updatePulsePopup( data.popupQuestionId );\t\t\t\t\n\t\t\tthis.popupTimestamp = data.timestamp;\n\t\t}\t\t\n\t}\n}"}}},"PollView":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"PULSE.CLIENT.PollView"},{"title":"param","description":null,"type":null,"name":"target"},{"title":"param","description":null,"type":null,"name":"tabPulse"},{"title":"param","description":null,"type":null,"name":"popupSelector"},{"title":"param","description":null,"type":null,"name":"pulsePopupCookieName"},{"title":"param","description":null,"type":null,"name":"hiddenClassName"}]},"Source":"PULSE.CLIENT.PollView = function( target, tabPulse, popupSelector, pulsePopupCookieName,\n                                    hiddenClassName )\n{\n    // a dummy width which will be overridden by the css width property once the element is created\n    this.carouselWidth = 320;\n\n    this.pollController = target;\n    this.pulseTabSelector = tabPulse;\n    this.pollSelector = tabPulse + ' #pulse';\n    this.popupSelector = popupSelector;\n    this.pulsePopupCookieName = pulsePopupCookieName;\n    this.hiddenClass = hiddenClassName;\n\n    this.opinion = [];\n    //Array of all opinions(questions)\n    this.opinion = [];\n    this.selectedQuestion = -1;\n    this.queIdsArray = [];\n    this.showPopup = true;\n\n    var that = this;\n\n    $( this.pollSelector + ' .controls .question-prev' ).click(function()\n    {\n        var selectedIndex = that.queIdsArray.indexOf( that.selectedQuestion );\n        if( selectedIndex === 0 )\n        {\n            that.scrollToQuestion( that.queIdsArray[ that.queIdsArray.length - 1 ], true );\n        }\n        else\n        {\n            that.scrollToQuestion( that.queIdsArray[ selectedIndex - 1 ], true );\n        }\n    });\n\n    $( this.pollSelector + ' .controls .question-next' ).click(function()\n    {\n        var selectedIndex = that.queIdsArray.indexOf( that.selectedQuestion );\n        if( selectedIndex === that.queIdsArray.length - 1 )\n        {\n            that.scrollToQuestion( that.queIdsArray[ 0 ], true );\n        }\n        else\n        {\n            that.scrollToQuestion( that.queIdsArray[ selectedIndex + 1 ], true );\n        }\n    });\n\n    $( this.popupSelector + ' .modal-display input' ).click(function(){\n        that.onCheckboxClick( $(that.popupSelector + ' .modal-display input').is(':checked') );\n    });\n}","prototype":{"refreshData":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.CLIENT.PollView.prototype.refreshData = function()\n{\n    if ( this.selectedQuestion === -1 || this.hasLastViewedQuestionClosed() )\n    {\n        this.selectedQuestion = this.opinion[0].id;\n    }\n    this.updateQuestionCntr();\n    this.updateActiveQuestions();\n}"},"updateQuestionCntr":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.CLIENT.PollView.prototype.updateQuestionCntr = function()\n{\n    var that = this;\n    var queIds = [];\n    $(this.pollSelector + ' .carousel-wrap').empty();\n\n    for ( var i = 0; i < this.opinion.length; i++ )\n    {\n        var options = '';\n        var results = '';\n        var voteCount = '';\n        var optionsCntr = '';\n        var question = this.opinion[i].text;\n        var optionsData = this.opinion[i].options;\n\n        for ( var j=0; j < optionsData.length; j++ )\n        {\n            options += '<div class=\"option\">' + optionsData[j].option + '<span class=\"arrow\"></span></div>';\n        }\n\n        results = this.getResults( optionsData, this.opinion[i].id );\n\n        if ( this.pollController.answeredQuestions.contains( this.opinion[i].id ) )\n        {\n            optionsCntr = '<div class=\"options\"></div>' + '<div class=\"results\">' + results + '</div>';\n        }\n        else\n        {\n            optionsCntr = '<div class=\"options\">' + options + '</div>' + '<div class=\"results\"></div>';\n        }\n\n        $(this.pollSelector + ' .carousel-wrap')\n            .append('<div id=\"' + this.opinion[i].id + '\" class=\"carousel-item\">' +\n                      '<div class=\"question\">' + this.safeQuestion(question) + '</div>' +\n                      optionsCntr +\n                    '</div>');\n        queIds[i] = this.opinion[i].id;\n    }\n\n    this.queIdsArray = queIds;\n    this.carouselWidth = $(this.pulseTabSelector + ' .carousel-item').eq(0).outerWidth( true );\n    this.scrollToQuestion( this.selectedQuestion, false );\n\n    $( this.pollSelector + ' .carousel-wrap .option' ).click( function()\n    {\n        var index = $('#' + that.selectedQuestion + ' .option').index( this );\n        that.showResults( index );\n    });\n}"},"showResults":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"selectedOptionIndex"}]},"Source":"PULSE.CLIENT.PollView.prototype.showResults = function( selectedOptionIndex )\n{\n    $('#' + this.selectedQuestion + ' .options').empty();\n    $('#' + this.selectedQuestion + ' .results').html(\n        this.getResults( this.getOptionsById( this.selectedQuestion ), this.selectedQuestion ) );\n    this.pollController.answerQuestion( selectedOptionIndex, this.selectedQuestion );\n    this.animateBars();\n}"},"getOptionsById":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"queId"}]},"Source":"PULSE.CLIENT.PollView.prototype.getOptionsById = function( queId )\n{\n    for ( var i = 0; i < this.opinion.length; i++ )\n    {\n        var op = this.opinion[i];\n        if( op.id === queId )\n        {\n            return op.options;\n        }\n    }\n    //if you come to execute below line, that means the question you were viewing is closed now.\n    this.refreshData();\n}"},"getResults":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"data"},{"title":"param","description":null,"type":null,"name":"id"}]},"Source":"PULSE.CLIENT.PollView.prototype.getResults = function( data, id )\n{\n    var results = '',\n        winnerIndex = this.getWinnerIndex( data );\n    for ( var i=0; i < data.length; i++ )\n    {\n        results += '<div class=\"result\">';\n\n        if ( this.pollController.answeredQuestions.contains( id ) )\n        {\n            results += '<div class=\"bar ' + (winnerIndex === i ? 'winner' : '') + '\" style=\"width:' + data[i].percentage + '\"></div>';\n        }\n        else\n        {\n            results += '<div class=\"bar '+ (winnerIndex === i ? 'winner' : '') + '\" style=\"width:0%\"></div>';\n        }\n\n        results += '<div class=\"option\">' + data[i].option.replace(/ /g, '&nbsp;') + '</div> <div class=\"percentage\">' + data[i].percentage + '</div> </div>';\n    }\n    return results;\n}"},"getWinnerIndex":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"data"},{"title":"param","description":null,"type":null,"name":"id"}]},"Source":"PULSE.CLIENT.PollView.prototype.getWinnerIndex = function( data, id )\n{\n    var winnerIndex = 0,\n        winnerScore = 0;\n\n    for( var i = 0; i < data.length; i++ )\n    {\n        var string = data[ i ].percentage,\n            number = parseInt( string.slice( 0, (string.length -1) ), undefined );\n\n        if( number > winnerScore )\n        {\n            winnerScore = number;\n            winnerIndex = i;\n        }\n    }\n\n    return winnerIndex;\n}"},"animateBars":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.CLIENT.PollView.prototype.animateBars = function()\n{\n    var index = this.queIdsArray.indexOf( this.selectedQuestion );\n    if( index >= 0 && this.pollController.answeredQuestions.contains( this.selectedQuestion ) )\n    {\n        var that = this;\n        for ( var i=0; i < this.opinion[index].options.length; i++ )\n        {\n            $('#' + this.selectedQuestion + ' .bar').eq(i).css( 'width', that.opinion[index].options[i].percentage );\n\n            // $('#' + this.selectedQuestion + ' .bar').eq(i).animate(\n            // {\n            //     width: that.opinion[index].options[i].percentage\n            // }, '1000');\n        }\n    }\n}"},"scrollToQuestion":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"id"},{"title":"param","description":null,"type":null,"name":"animateBar"}]},"Source":"PULSE.CLIENT.PollView.prototype.scrollToQuestion = function( id, animateBar )\n{\n    this.carouselWidth = $(this.pulseTabSelector + ' .carousel-item').outerWidth( true );\n    this.selectedQuestion = id;\n    var index = this.queIdsArray.indexOf( id );\n\n    if ( index >= 0 )\n    {\n        var amount = this.carouselWidth * ( index ) * -1;\n        var that = this;\n\n        this.applyActiveClass();\n\n        if ( animateBar )\n        {\n            this.resetWidth();\n        }\n\n        $(this.pollSelector + ' .carousel-wrap').animate( { left: amount }, 'slow', function()\n        {\n            if( animateBar )\n            {\n                that.animateBars();\n            }\n        });\n    }\n}"},"resetWidth":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.CLIENT.PollView.prototype.resetWidth = function()\n{\n    $('#' + this.selectedQuestion + ' .resultsBar').css('width', '0%');\n}"},"applyActiveClass":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.CLIENT.PollView.prototype.applyActiveClass = function()\n{\n    PULSE.CLIENT.Util.applyActiveClass( this.pollSelector + ' .active-questions ul li',\n        this.queIdsArray.indexOf(this.selectedQuestion), 'active' )\n}"},"updateActiveQuestions":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.CLIENT.PollView.prototype.updateActiveQuestions = function()\n{\n    var that = this;\n    var className = 'active';\n    $(this.pollSelector + ' .active-questions ul').empty();\n    for ( var i = 0; i < this.opinion.length; i++ )\n    {\n        var row = this.opinion[i];\n\n        if ( this.selectedQuestion === row.id )\n        {\n            className = 'active';\n        }\n        else\n        {\n            className = '';\n        }\n\n        $(this.pollSelector + ' .active-questions ul')\n            .append('<li id=' + row.id + '><a>' + row.text + '</a></li>');\n    }\n\n    this.applyActiveClass();\n\n    $(this.pollSelector + ' .active-questions ul li').click(function(){\n        that.scrollToQuestion( parseInt( this.id ), true );\n    });\n}"},"safeQuestion":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"question"}]},"Source":"PULSE.CLIENT.PollView.prototype.safeQuestion = function(question)\n{\n    if ( question.indexOf('#') === 0 )\n    {\n        return question.substr(1);\n    }\n    else\n    {\n        return question;\n    }\n}"},"updatePulsePopup":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"popupQueId"}]},"Source":"PULSE.CLIENT.PollView.prototype.updatePulsePopup = function( popupQueId )\n{\n    var that = this;\n    var popupOpinion = this.getOpinionById( popupQueId );\n    if ( popupOpinion )\n    {\n        var showCookieValue = this.getShowPopupCookieValue();\n        // show/hide pulse popup based on following conditions\n        if ( ( ! this.showPopup ) || ( ! $(this.pulseTabSelector).hasClass(this.hiddenClass) ) ||\n            ( showCookieValue !== null && showCookieValue.indexOf(':No:') !== -1 ) ||\n            this.pollController.answeredQuestions.contains( popupOpinion.id ) )\n        {\n            $(this.popupSelector).css('display', 'none');\n        }\n        else\n        {\n            var options = '';\n            for ( var i = 0; i < popupOpinion.options.length; i++ )\n            {\n                options = options + '<div class=\"option\">' +\n                                      '<input type=\"radio\" class=\"inputradio\">' +\n                                        '<label>' + popupOpinion.options[i].option + '</label>' +\n                                    '</div>';\n            }\n\n            $('.pulse-popup .question').text( popupOpinion.text );\n            $('.pulse-popup .options').empty();\n            $('.pulse-popup .options').append( options );\n            $('.pulse-popup .options .option').click(function()\n            {\n                var index = $('.pulse-popup .options .option').index(this);\n                $(that.popupSelector).css('display', 'none');\n                that.pollController.answerQuestion(index, popupOpinion.id);\n                that.refreshData();\n            });\n\n            $(this.popupSelector).css('display', 'block');\n        }\n    }\n}"},"getOpinionById":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"queId"}]},"Source":"PULSE.CLIENT.PollView.prototype.getOpinionById = function( queId )\n{\n    for ( var i = 0; i < this.opinion.length; i++ )\n    {\n        if ( this.opinion[i] && this.opinion[i].id === queId )\n        {\n            return this.opinion[i];\n        }\n    }\n\n    return undefined;\n}"},"onCheckboxClick":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"checked"}]},"Source":"PULSE.CLIENT.PollView.prototype.onCheckboxClick = function( checked )\n{\n    var c_expiry = this.getShowPopupCookieExpiryDate();\n    if ( checked )\n    {\n        this.showPopup = true;\n        document.cookie = this.pulsePopupCookieName + '=:Yes:|' + c_expiry + ';expires=' + c_expiry;\n    }\n    else\n    {\n        this.showPopup = false;\n        document.cookie = this.pulsePopupCookieName + '=:No:|' + c_expiry + ';expires=' + c_expiry;\n    }\n}"},"hasLastViewedQuestionClosed":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.CLIENT.PollView.prototype.hasLastViewedQuestionClosed = function()\n{\n    for ( var i = 0; i < this.opinion.length; i++ )\n    {\n        var op = this.opinion[i];\n        if ( op.id === this.selectedQuestion )\n        {\n            return false;\n        }\n    }\n    return true;\n}"},"getShowPopupCookieValue":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.CLIENT.PollView.prototype.getShowPopupCookieValue = function()\n{\n    var val = PULSE.CLIENT.Cookie.getCookieByKey( this.pulsePopupCookieName );\n\n    // if this cookie doesn't exist then set it with Yes & expiry date: 2 weeks from now\n    if ( val.length === 0 )\n    {\n        var exdate = new Date();\n        exdate.setDate( exdate.getDate() + 14 );\n        var expiryDate = exdate.toUTCString();\n        document.cookie = this.pulsePopupCookieName + '=:Yes:|' + expiryDate + ';expires=' +\n            expiryDate;\n        return \":Yes:|\" + expiryDate;\n    }\n\n    return val;\n}"},"getShowPopupCookieExpiryDate":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.CLIENT.PollView.prototype.getShowPopupCookieExpiryDate = function()\n{\n    var c_val = this.getShowPopupCookieValue();\n\n    if ( c_val.indexOf('|') !== -1 )\n    {\n        return c_val.substr( c_val.indexOf('|') + 1 );\n    }\n\n    return '';\n}"}}},"TENNIS":{"makePlayerLabel":{"Documentation":{"description":"Utility method to make a participant string.","tags":[]},"Source":"PULSE.CLIENT.TENNIS.makePlayerLabel = function ( match, index )\n{\n    var label = '';\n    for ( var i = 0, ilimit = match.names[ index ].length; i < ilimit; i++ )\n    {\n        label += match.names[ index ][ i ];\n\n        if ( match.nationalities && match.nationalities[ index ][ i ] )\n        {\n            label += ' (' + match.nationalities[ index ][ i ] + ')';\n        }\n\n        if ( i < ilimit - 1 )\n        {\n            label += '/';\n        }\n    }\n\n    if ( match.seedings && match.seedings[ index ] )\n    {\n        label += ' [' + match.seedings[ index ] + ']';\n    }\n\n    return label;\n}"},"DrawCanvas":{"Documentation":{"description":"Constructor.","tags":[{"title":"param","description":"the ID of the div that the canvas should go in","type":null,"name":"divId"},{"title":"param","description":"configuration parameters for the canvas","type":null,"name":"config"}]},"Source":"PULSE.CLIENT.TENNIS.DrawCanvas = function ( divId, config )\n{\n\tvar that = this;\n\t\n\t// Create drawing context\n\tthis.r = Raphael( divId, config.width, config.height );\n\t\n    // Set up mouse listeners\n\tvar div = document.getElementById( divId );\n    div.onselectstart = function() { return false; }\n    div.onmousedown = function( e ) { \n    \tthat.anchor = PULSE.Utils.getXY( e );\n    }\n    div.onmouseup = function() { that.anchor = undefined; }\n    div.onmousemove = function ( e ) {\n    \tif ( that.anchor )\n    \t{\n\t    \tvar pos = PULSE.Utils.getXY( e );\n\t    \tvar diff = { x: that.anchor.x - pos.x, y: that.anchor.y - pos.y };\n\t    \t\n        \t$(div).css( 'left', diff.x + 'px' );\n        \t$(div).css( 'top', diff.x + 'px' );\n\t    \t\n\t    \tthat.anchor = pos;\n    \t}\n    }\n\t\n\t// Save the configuration\n\tthis.config = config;\n}","prototype":{"setData":{"Documentation":{"description":"Sets the data that this canvas will be showing.","tags":[{"title":"param","description":"the data, consisting of draws for all events","type":null,"name":"data"}]},"Source":"PULSE.CLIENT.TENNIS.DrawCanvas.prototype.setData = function ( data )\n{\n\t// Build event-keyed data\n\tthis.events = {};\n    for ( var i = 0, ilimit = data.events.length; i < ilimit; i++ )\n    {\n        var event = data.events[i];\n        this.events[ event.name ] = event;\n    }\n\n    // Reset data\n\tthis.data = this.events[ this.eventName ];\n    \n    // Render\n\tthis.render();\n}"},"setEvent":{"Documentation":{"description":"Sets the event to show.","tags":[{"title":"param","description":"the event name","type":null,"name":"event"}]},"Source":"PULSE.CLIENT.TENNIS.DrawCanvas.prototype.setEvent = function ( event )\n{\n\tthis.eventName = event;\n\tthis.data = this.events[ this.eventName ];\n\tthis.render();\n}"},"render":{"Documentation":{"description":"Performs the rendering of the data.","tags":[]},"Source":"PULSE.CLIENT.TENNIS.DrawCanvas.prototype.render = function ()\n{\n\tif ( this.data )\n\t{\n\t\t// First do some calculation on the size of the panel\n\t\tvar maxMatches = this.data.rounds[0].matches.length;\n\t\tvar height = maxMatches * this.config.distance;\n\t\t\n\t\tif ( this.config.doubleEnded )\n\t\t{\n\t\t\theight /= 2;\n\t\t}\n\t\t\n\t\tthis.r.height = height;\n\t\t\n\t\tthis.r.clear();\n\t\tvar off = 0;\n\t\tfor ( var round = 0, rounds = this.data.rounds.length; round < rounds; round++ )\n\t\t{\n\t\t\tthis.renderRound( this.data.rounds[round], 200 * ( round + 1 ) - 100, \n\t\t\t\t\t\t      30 + ( off * this.config.distance ),\n\t\t\t\t\t\t      this.config.distance * ( Math.pow( 2, round ) ),\n\t\t\t\t\t\t      round >= rounds - 2 );\n\t\t\t\n\t\t\toff += ( round === 0 ? 0.5 : Math.pow( 2, round - 1 ) );\n\t\t}\n\t}\n}"},"renderRound":{"Documentation":{"description":"Renders a single round's data vertically.","tags":[]},"Source":"PULSE.CLIENT.TENNIS.DrawCanvas.prototype.renderRound = function ( round, x, y, dy, end )\n{\n\tfor ( var m = 0, mlimit = round.matches.length; m < mlimit; m++ )\n\t{\n\t\tvar rhs = this.config.doubleEnded && m >= ( mlimit / 2 );\n\t\tvar index = m;\n\t\tif ( rhs )\n\t\t{\n\t\t\tindex -= ( mlimit / 2 );\n\t\t}\n\t\t\n\t\tthis.renderMatch( round.matches[m], x, y + ( index * dy ), dy, m % 2 === 0, end, rhs );\n\t}\n}"},"renderMatch":{"Documentation":{"description":"Renders a single match's data vertically.","tags":[]},"Source":"PULSE.CLIENT.TENNIS.DrawCanvas.prototype.renderMatch = function ( match, x, y, separation, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  upper, end, rhs )\n{\n\t// If we are in a RHS mode, modify the x and y\n\tvar dx = 100;\n\tif ( rhs )\n\t{\n\t\tx = 2400 - x;\n\t\tdx *= -1;\n\t}\n\t\n\t// Connector, if not at the end\n\tif ( !end )\n\t{\n\t\tvar target = y;\n\t\tif ( upper )\n\t\t{\n\t\t\ttarget += ( separation / 2 )\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttarget -= ( separation / 2 );\n\t\t}\n\t\t\n\t\tvar path = 'M' + x + ' ' + y +\n\t\t           'L' + ( x + dx ) + ' ' + y +\n\t\t           'L' + ( x + dx ) + ' ' + target;\n\t\t\n\t\tif ( upper )\n\t\t{\n\t\t\tpath += 'L' + ( x + ( 2 * dx ) ) + ' ' + ( y + ( separation / 2 ) );\n\t\t}\n\t\t\n\t\tthis.r.path( path ).attr( { stroke:'black' } );\n\t}\n\t\n\t// Container\n\tthis.r.rect( x - 80, y - 23, 160, 46, 0 ).attr( { fill:'#eee', stroke:'#000' } );\n\t\n\t// Text\n\tvar texts = [ this.r.text( x, y - 12, PULSE.CLIENT.TENNIS.makePlayerLabel( match, 0 ) ), \n\t              this.r.text( x, y + 12, PULSE.CLIENT.TENNIS.makePlayerLabel( match, 1 ) ) ]; \n\n\tif ( match.winnerIndex !== undefined && match.winnerIndex !== -1 )\n\t{\n\t\ttexts[match.winnerIndex].attr( { fill:'blue' } );\n\t}\n\t\n\tif ( match.outcomeString )\n\t{\n\t\tthis.r.text( x, y, \n\t\t\t\tmatch.outcomeString.replace( /\\<span\\>/g, '(' ).replace( /\\<\\/span\\>/g, ')' ) );\n\t}\n}"}}},"NormalisePosition":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"PULSE.CLIENT.TENNIS.NormalisePosition"},{"title":"param","description":null,"type":null,"name":"world"}]},"Source":"PULSE.CLIENT.TENNIS.NormalisePosition = function ( world )\n{\n\tif ( world.x < 0 )\n\t{\n\t\tworld.x = -world.x;\n\t\tworld.y = -world.y;\n\t}\n\treturn world;\n}"},"ShotDataGraph":{"Documentation":{"description":"Constructor.","tags":[{"title":"param","description":"the number of graphs to display (1 or 2)","type":null,"name":"count"},{"title":"param","description":"the prefix of the divs holding the background image","type":null,"name":"bgDivId"},{"title":"param","description":"the prefix of the divs prepared for drawing output","type":null,"name":"fgDivId"},{"title":"param","description":"configuration parameters for the graph","type":null,"name":"config"},{"title":"param","description":"the prefix of the divs prepared for displaying the player names (optional,\n       as it is not driven if we are in single graph mode)","type":null,"name":"nameDivId"}]},"Source":"PULSE.CLIENT.TENNIS.ShotDataGraph = function ( count, bgDivId, fgDivId, config, nameDivId )\n{\n    this.bg = [];\n    this.name = [];\n    this.r = [];\n\n    for ( var i = 0; i < count; i++ )\n    {\n        // Obtain background div reference\n        this.bg[i] = document.getElementById( bgDivId + ( i + 1 ) );\n\n        // Obtain name div reference\n        this.name[i] = document.getElementById( nameDivId + ( i + 1 ) );\n\n        // Create drawing context\n        this.r[i] = Raphael( fgDivId + ( i + 1 ), config.width, config.height );\n    }\n\n    // Save the configuration\n    this.config = config;\n\n    // Initialise filter and data to empty objects\n    this.filter = {};\n    this.data = {};\n\n    // Set the default graph\n    this.setGraph( 'sp' );\n}","prototype":{"setData":{"Documentation":{"description":"Sets the data that this graph will be showing.","tags":[{"title":"param","description":"the data, consisting of all shot data for both players in the whole match","type":null,"name":"data"}]},"Source":"PULSE.CLIENT.TENNIS.ShotDataGraph.prototype.setData = function ( data )\n{\n    // Save P1 name\n    this.p1Name = data.names[0];\n\n    // Update name divs\n    for ( var i = 0, ilimit = this.name.length; i < ilimit; i++ )\n    {\n        if ( this.name[i] )\n        {\n            this.name[i].innerHTML = data.names[i];\n        }\n    }\n\n    // Derive and render data\n    this.data = data;\n    this.generateData();\n    this.draw();\n}"},"setFilter":{"Documentation":{"description":"Sets the filter, determining what data is actually rendered.","tags":[{"title":"param","description":"the filter to set","type":null,"name":"filter"}]},"Source":"PULSE.CLIENT.TENNIS.ShotDataGraph.prototype.setFilter = function ( filter )\n{\n    this.filter = filter;\n    this.generateData();\n    this.draw();\n}"},"setGraph":{"Documentation":{"description":"Displays the given specific shot data graph.","tags":[{"title":"param","description":"the name of the graph to switch to (sp, rsp, p, rhp)","type":null,"name":"graph"}]},"Source":"PULSE.CLIENT.TENNIS.ShotDataGraph.prototype.setGraph = function ( graph )\n{\n    if ( this.config.projections[ graph ] )\n    {\n        // Save graph name\n        this.graph = graph;\n\n        // Set new projection\n        this.projector = new PULSE.Projector( this.config.projections[ graph ] );\n\n        // Set new background\n        this.setBackground( this.config.backgrounds[ graph ] );\n\n        this.generateData();\n        this.draw();\n    }\n}"},"setBackground":{"Documentation":{"description":"Sets the background images for this graph.","tags":[]},"Source":"PULSE.CLIENT.TENNIS.ShotDataGraph.prototype.setBackground = function ( bg )\n{\n    for ( var i = 0, ilimit = this.bg.length; i < ilimit; i++ )\n    {\n        var div = this.bg[i];\n\n        if ( this.config.backgroundMethod === 'image' )\n        {\n            var img = new Image();\n            img.src = bg;\n            while ( div.firstChild )\n            {\n                div.removeChild( div.firstChild );\n            }\n            div.appendChild( img );\n        }\n        else\n        {\n            div.setAttribute( 'class', bg );\n            div.setAttribute( 'className', bg );\n        }\n    }\n}"},"generateData":{"Documentation":{"description":"Private method to regenerate the two data buckets depending on the current complete data set,\nthe current filter, and the current graph.","tags":[]},"Source":"PULSE.CLIENT.TENNIS.ShotDataGraph.prototype.generateData = function ()\n{\n    // Create the stereo data containers\n    this.stereoData = [ [], [] ];\n\n    // Iterate over all data in the complete data set\n    for ( var pp in this.data.data )\n    {\n        var thisSet = +pp.split( '.' )[0];\n\n        // First check for set filtering\n        if ( !this.filter.set || this.filter.set == thisSet )\n        {\n            var ppData = this.data.data[pp];\n            var world;\n\n            // Now filter depending on the graph\n            if ( 'sp' === this.graph && ppData.servePlacement )\n            {\n                if ( !this.filter.shot || this.filter.shot.indexOf( ppData.serveType ) != -1 )\n                {\n                    world = ppData.servePlacement;\n                    world.z = PULSE.CLIENT.TENNIS.BALL_RADIUS;\n                    world.fill = this.config.ballFills[ ppData.serveType ];\n                    this.stereoData[ ppData.serverIndex ].push(\n                            PULSE.CLIENT.TENNIS.NormalisePosition( world ) );\n                }\n            }\n            else if ( 'rsp' === this.graph && ppData.returnStrike )\n            {\n                if ( !this.filter.shot || this.filter.shot.indexOf( ppData.serveType ) != -1 )\n                {\n                    world = ppData.returnStrike;\n                    world.fill = this.config.ballFills[ ppData.serveType ];\n                    this.stereoData[ 1 - ppData.serverIndex ].push(\n                            PULSE.CLIENT.TENNIS.NormalisePosition( world ) );\n                }\n            }\n            else if ( 'p' === this.graph && ppData.placements )\n            {\n                for ( var p = 0; p < 2; p++ )\n                {\n                    if ( ppData.placements[p] )\n                    {\n                        for ( var i = 0, ilimit = ppData.placements[p].length; i < ilimit; i++ )\n                        {\n                            world = ppData.placements[p][i];\n                            world.z = PULSE.CLIENT.TENNIS.BALL_RADIUS;\n                            this.stereoData[p].push(\n                                    PULSE.CLIENT.TENNIS.NormalisePosition( world ) );\n                        }\n                    }\n                }\n            }\n            else if ( 'rhp' === this.graph && ppData.strikes )\n            {\n                for ( var p = 0; p < 2; p++ )\n                {\n                    if ( ppData.strikes[p] )\n                    {\n                        for ( var i = 0, ilimit = ppData.strikes[p].length; i < ilimit; i++ )\n                        {\n                            world = ppData.strikes[p][i];\n                            this.stereoData[p].push(\n                                    PULSE.CLIENT.TENNIS.NormalisePosition( world ) );\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    // Finally, order the items in each data bucket by their x-value\n    var sorter = function ( a, b )\n    {\n        return a.x - b.x;\n    };\n    this.stereoData[0].sort( sorter );\n    this.stereoData[1].sort( sorter );\n\n    // If we are in single-graph mode, ensure stereoData[0] contains the correct data\n    if ( this.name.length === 1 )\n    {\n        if ( this.filter.player && this.filter.player !== this.p1Name )\n        {\n            this.stereoData[0] = this.stereoData[1];\n        }\n    }\n}","sorter":{"Documentation":{"description":"Private method to regenerate the two data buckets depending on the current complete data set,\nthe current filter, and the current graph.","tags":[]},"Source":"var sorter = function ( a, b )\n    {\n        return a.x - b.x;\n    }"}},"draw":{"Documentation":{"description":"Private method to update the scene to show the current balls (based on the filter) using the\ncurrent projection.","tags":[]},"Source":"PULSE.CLIENT.TENNIS.ShotDataGraph.prototype.draw = function ()\n{\n    this.drawPlayerData( this.r[0], 0 );\n    this.drawPlayerData( this.r[1], 1 );\n}"},"drawPlayerData":{"Documentation":{"description":"Private method to draw a single player's data.","tags":[]},"Source":"PULSE.CLIENT.TENNIS.ShotDataGraph.prototype.drawPlayerData = function ( r, index )\n{\n    if ( r )\n    {\n        r.clear();\n\n        // If this is an in-the-air graph, draw stalks first\n        if ( 'rsp' === this.graph || 'rhp' === this.graph )\n        {\n            for ( var i = 0, ilimit = this.stereoData[index].length; i < ilimit; i++ )\n            {\n                var point = this.stereoData[index][i];\n\n                // Do not show balls in the serve box for rsp graph\n                if( 'rsp' === this.graph && point.x < 7 ) continue;\n\n                var floor = { x:point.x, y:point.y, z:PULSE.CLIENT.TENNIS.BALL_RADIUS };\n                var floorScreen = this.projector.project( floor );\n\n                // In-the-air graph, so draw stalks\n                var pointScreen = this.projector.project( point );\n\n                r.path( 'M' + pointScreen.x + ' ' + pointScreen.y +\n                        'L' + floorScreen.x + ' ' + floorScreen.y ).attr(\n                                     { stroke:this.config.stalkStroke } );\n            }\n        }\n\n        var easing = '';\n        var t0 = 0;\n        var t1 = 0;\n        if ( this.config.easing && this.config.easing[ this.graph ] )\n        {\n            easing = this.config.easing[ this.graph ][0];\n            t0 = this.config.easing[ this.graph ][1];\n            t1 = this.config.easing[ this.graph ][2];\n        }\n\n        var fallHeight = 1;\n        if ( this.config.fallHeights && this.config.fallHeights[ this.graph ] )\n        {\n            fallHeight = this.config.fallHeights[ this.graph ];\n        }\n\n        for ( var i = 0, ilimit = this.stereoData[index].length; i < ilimit; i++ )\n        {\n            var point = this.stereoData[index][i];\n\n            // Do not show balls in the serve box for rsp graph\n            if( 'rsp' === this.graph && point.x < 7 ) continue;\n\n            var before = { x:point.x, y:point.y, z:fallHeight };\n            var beforeScreen = this.projector.project( before );\n            var afterScreen = this.projector.project( point );\n            var time = t0 + ( t1 * Math.random() );\n\n            // If this is a ground shot graph, draw and animate shadow\n            if ( 'p' === this.graph || 'sp' == this.graph )\n            {\n                var e = r.ellipse( afterScreen.x, afterScreen.y + 3, 0, 0 ).attr(\n                                { fill:this.config.shadowFill, stroke:'none' } );\n                e.animate( { rx:this.config.ballSize, ry:this.config.ballSize * 0.6 }, time, easing );\n            }\n\n            // Work out the ball fill\n            var ballFill = point.fill ? point.fill : this.config.ballFills.def;\n\n            // Now animate the ball, from the heavens to their final position\n            var c = r.circle( beforeScreen.x, beforeScreen.y, this.config.ballSize ).attr(\n                    { fill:ballFill, stroke:'none' } );\n            c.animate( { cx:afterScreen.x, cy:afterScreen.y }, time, easing );\n        }\n    }\n}"}}},"StereoShotDataGraph":{"Documentation":{"description":"Constructor.","tags":[{"title":"param","description":"the prefix of the divs holding the background image","type":null,"name":"bgDivId"},{"title":"param","description":"the prefix of the divs prepared for drawing output","type":null,"name":"fgDivId"},{"title":"param","description":"the prefix of the divs prepared for displaying the player names","type":null,"name":"nameDivId"},{"title":"param","description":"configuration parameters for the graph","type":null,"name":"config"}]},"Source":"PULSE.CLIENT.TENNIS.StereoShotDataGraph = function ( bgDivId, fgDivId, nameDivId, config )\n{\n\t// Obtain background div references\n\tthis.bg1 = document.getElementById( bgDivId + '1' );\n\tthis.bg2 = document.getElementById( bgDivId + '2' );\n\t\n\t// Obtain name div references\n\tthis.name1 = document.getElementById( nameDivId + '1' );\n\tthis.name2 = document.getElementById( nameDivId + '2' );\n\t\n\t// Create drawing contexts\n\tthis.r1 = Raphael( fgDivId + '1', config.width, config.height );\n\tthis.r2 = Raphael( fgDivId + '2', config.width, config.height );\n\t\n\t// Save the configuration\n\tthis.config = config;\n\n\t// Initialise filter and data to empty objects\n\tthis.filter = {};\n\tthis.data = {};\n\t\n    // Set the default graph\n    this.setGraph( 'sp' );\n}","prototype":{"setData":{"Documentation":{"description":"Sets the data that this graph will be showing.","tags":[{"title":"param","description":"the data, consisting of all shot data for both players in the whole match","type":null,"name":"data"}]},"Source":"PULSE.CLIENT.TENNIS.StereoShotDataGraph.prototype.setData = function ( data )\n{\n\t// Update name divs\n\tthis.name1.innerHTML = data.names[0];\n\tthis.name2.innerHTML = data.names[1];\n\t\n\t// Derive and render data \n\tthis.data = data;\n\tthis.generateData();\n\tthis.draw();\n}"},"setFilter":{"Documentation":{"description":"Sets the filter, determining what data is actually rendered.","tags":[{"title":"param","description":"the filter to set","type":null,"name":"filter"}]},"Source":"PULSE.CLIENT.TENNIS.StereoShotDataGraph.prototype.setFilter = function ( filter )\n{\n\tthis.filter = filter;\n\tthis.generateData();\n\tthis.draw();\n}"},"setGraph":{"Documentation":{"description":"Displays the given specific shot data graph.","tags":[{"title":"param","description":"the name of the graph to switch to (sp, rsp, p, rhp)","type":null,"name":"graph"}]},"Source":"PULSE.CLIENT.TENNIS.StereoShotDataGraph.prototype.setGraph = function ( graph )\n{\n\t// Save graph name\n\tthis.graph = graph;\n\t\n\t// Set new projection\n\tthis.projector = new PULSE.Projector( this.config.projections[ graph ] );\n\n\t// Set new background\n\tthis.setBackground( this.config.backgrounds[ graph ] );\n\t\n\tthis.generateData();\n\tthis.draw();\n}"},"setBackground":{"Documentation":{"description":"Sets the background images for this graph.","tags":[]},"Source":"PULSE.CLIENT.TENNIS.StereoShotDataGraph.prototype.setBackground = function ( bg )\n{\n\tvar divs = [ this.bg1, this.bg2 ];\n\tfor ( var i = 0, ilimit = divs.length; i < ilimit; i++ )\n\t{\n\t\tvar div = divs[i];\n\t\t\n\t\tif ( this.config.backgroundMethod === 'image' )\n\t\t{\n\t\t\tvar img = new Image();\n\t\t    img.src = bg;\n\t\t\twhile ( div.firstChild )\n\t\t\t{\n\t\t\t\tdiv.removeChild( div.firstChild );\n\t\t\t}\n\t\t\tdiv.appendChild( img );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdiv.setAttribute( 'class', bg );\n\t\t\tdiv.setAttribute( 'className', bg );\n\t\t}\n\t}\n}"},"generateData":{"Documentation":{"description":"Private method to regenerate the two data buckets depending on the current complete data set,\nthe current filter, and the current graph.","tags":[]},"Source":"PULSE.CLIENT.TENNIS.StereoShotDataGraph.prototype.generateData = function ()\n{\n\t// Create the stereo data containers\n\tthis.stereoData = [ [], [] ];\n\n\t// Iterate over all data in the complete data set\n\tfor ( var pp in this.data.data )\n\t{\n        var thisSet = +pp.split( '.' )[0];\n        \n        // First check for set filtering\n        if ( !this.filter.set || this.filter.set == thisSet )\n        {\n        \tvar ppData = this.data.data[pp];\n        \tvar world;\n        \t\n        \t// Now filter depending on the graph\n        \tif ( 'sp' === this.graph && ppData.servePlacement )\n        \t{\n        \t\tif ( !this.filter.shot || this.filter.shot.indexOf( ppData.serveType ) != -1 )\n        \t\t{\n\t        \t\tworld = ppData.servePlacement;\n\t        \t\tworld.z = PULSE.CLIENT.TENNIS.BALL_RADIUS;\n\t        \t\tworld.fill = this.config.ballFills[ ppData.serveType ];\n\t        \t\tthis.stereoData[ ppData.serverIndex ].push( \n\t        \t\t\t\tPULSE.CLIENT.TENNIS.NormalisePosition( world ) );\n        \t\t}\n        \t}\n        \telse if ( 'rsp' === this.graph && ppData.returnStrike )\n        \t{\n        \t\tif ( !this.filter.shot || this.filter.shot.indexOf( ppData.serveType ) != -1 )\n        \t\t{\n\t        \t\tworld = ppData.returnStrike;\n\t        \t\tworld.fill = this.config.ballFills[ ppData.serveType ];\n\t        \t\tthis.stereoData[ 1 - ppData.serverIndex ].push( \n\t        \t\t\t\tPULSE.CLIENT.TENNIS.NormalisePosition( world ) );\n        \t\t}\n        \t}\n        \telse if ( 'p' === this.graph && ppData.placements )\n        \t{\n        \t\tfor ( var p = 0; p < 2; p++ )\n        \t\t{\n        \t\t\tif ( ppData.placements[p] )\n        \t\t\t{\n\t\t\t            for ( var i = 0, ilimit = ppData.placements[p].length; i < ilimit; i++ )\n\t\t\t            {\n\t\t\t            \tworld = ppData.placements[p][i];\n\t\t\t            \tworld.z = PULSE.CLIENT.TENNIS.BALL_RADIUS;\n\t\t\t            \tthis.stereoData[p].push( \n\t\t\t            \t\t\tPULSE.CLIENT.TENNIS.NormalisePosition( world ) );\n\t\t\t            }\n        \t\t\t}\n        \t\t}\n        \t}\n        \telse if ( 'rhp' === this.graph && ppData.strikes )\n        \t{\n        \t\tfor ( var p = 0; p < 2; p++ )\n        \t\t{\n        \t\t\tif ( ppData.strikes[p] )\n        \t\t\t{\n\t\t\t            for ( var i = 0, ilimit = ppData.strikes[p].length; i < ilimit; i++ )\n\t\t\t            {\n\t\t\t            \tworld = ppData.strikes[p][i];\n\t\t\t            \tthis.stereoData[p].push( \n\t\t\t            \t\t\tPULSE.CLIENT.TENNIS.NormalisePosition( world ) );\n\t\t\t            }\n\t\t            }\n        \t\t}\n        \t}\n        }\n\t}\n\t\n\t// Finally, order the items in each data bucket by their x-value\n\tvar sorter = function ( a, b )\n\t{\n\t\treturn a.x - b.x;\n\t};\n\t\n\tthis.stereoData[0].sort( sorter );\n\tthis.stereoData[1].sort( sorter );\n}","sorter":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"a"},{"title":"param","description":null,"type":null,"name":"b"}]},"Source":"var sorter = function ( a, b )\n\t{\n\t\treturn a.x - b.x;\n\t}"}},"draw":{"Documentation":{"description":"Private method to update the scene to show the current balls (based on the filter) using the\ncurrent projection.","tags":[]},"Source":"PULSE.CLIENT.TENNIS.StereoShotDataGraph.prototype.draw = function ()\n{\n\tthis.drawPlayerData( this.r1, 0 );\n\tthis.drawPlayerData( this.r2, 1 );\n}"},"drawPlayerData":{"Documentation":{"description":"Private method to draw a single player's data.","tags":[]},"Source":"PULSE.CLIENT.TENNIS.StereoShotDataGraph.prototype.drawPlayerData = function ( r, index )\n{\n\tr.clear();\n\t\n\t// If this is an in-the-air graph, draw stalks first\n\tif ( 'rsp' === this.graph || 'rhp' === this.graph )\n\t{\n\t\tfor ( var i = 0, ilimit = this.stereoData[index].length; i < ilimit; i++ )\n\t\t{\n\t\t\tvar point = this.stereoData[index][i];\n\t\t\t\n\t\t\tvar floor = { x:point.x, y:point.y, z:PULSE.CLIENT.TENNIS.BALL_RADIUS };\n\t\t\tvar floorScreen = this.projector.project( floor );\n\t\t\t\n\t\t\t// In-the-air graph, so draw stalks\n\t\t\tvar pointScreen = this.projector.project( point );\n\t\t\t\n\t\t\tr.path( 'M' + pointScreen.x + ' ' + pointScreen.y +\n\t\t\t        'L' + floorScreen.x + ' ' + floorScreen.y ).attr( \n\t\t\t\t\t    \t\t { stroke:this.config.stalkStroke } );\n\t\t}\n\t}\t\t\n\t\n\tvar easing = this.config.easing[ this.graph ][0];\n\tvar t0 = this.config.easing[ this.graph ][1];\n\tvar t1 = this.config.easing[ this.graph ][2];\n\t\n\tfor ( var i = 0, ilimit = this.stereoData[index].length; i < ilimit; i++ )\n\t{\n\t\tvar point = this.stereoData[index][i];\n\t\t\n\t\tvar before = { x:point.x, y:point.y, z:this.config.fallHeights[ this.graph ] };\n\t\tvar beforeScreen = this.projector.project( before );\n\t\tvar afterScreen = this.projector.project( point );\n\t\tvar time = t0 + ( t1 * Math.random() );\n\n\t\t// If this is a ground shot graph, draw and animate shadow\n\t\tif ( 'p' === this.graph || 'sp' == this.graph )\n\t\t{\n\t\t    var e = r.ellipse( afterScreen.x, afterScreen.y + 3, 0, 0 ).attr( \n\t\t\t\t\t\t\t{ fill:this.config.shadowFill, stroke:'none' } );\n\t\t\te.animate( { rx:this.config.ballSize, ry:this.config.ballSize * 0.6 }, time, easing );\n\t\t}\n\n\t\t// Work out the ball fill\n\t\tvar ballFill = point.fill ? point.fill : this.config.ballFills.def;\n\t\t\n\t\t// Now animate the ball, from the heavens to their final position\n\t\tvar c = r.circle( beforeScreen.x, beforeScreen.y, this.config.ballSize ).attr( \n\t\t\t\t{ fill:ballFill, stroke:'none' } );\n\t\tc.animate( { cx:afterScreen.x, cy:afterScreen.y }, time, easing );\n\t}\n}"}}},"TennisTimelineLabel":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"PULSE.CLIENT.TENNIS.TennisTimelineLabel"},{"title":"param","description":null,"type":null,"name":"r"},{"title":"param","description":null,"type":null,"name":"config"}]},"Source":"PULSE.CLIENT.TENNIS.TennisTimelineLabel = function ( r, config )\n{\n\tthis.r = r;\n\tthis.config = config;\n\t\n\t// Label background\n\tthis.bg = r.rect( 0, 0, config.label.width, config.label.height, config.label.rounding )\n\t           .attr( { stroke:config.label.stroke, fill:config.label.fill, 'stroke-width':0.5 } );\n\n\t// Pointer attributes\n\tthis.pattr = { stroke:'none', fill:config.label.fill, 'stroke-width':0.5 };\n\t\n\t// Speed text\n\tthis.textValue = r.text( 0, PULSE.IE78 ? 13 : 10, '' )\n                      .attr( { 'font-family':config.label['font-family'], \n                    \t       'font-size':config.label['font-size'],\n                \t           'font-weight':config.label['font-weight'], \n                \t           fill:config.label.text, stroke:'none' } );\n\t\n\t// Speed text label\n\tthis.textLabel = r.text( 0, PULSE.IE78 ? 24 : 21, 'mph' )\n                      .attr( { 'font-family':config.label.label['font-family'], \n                    \t       'font-size':config.label.label['font-size'],\n                \t           'font-weight':config.label.label['font-weight'], \n                \t           fill:config.label.text, stroke:'none' } );\n\t\n\tthis.set = r.set();\n\tthis.set.push( this.textValue );\n\tthis.set.push( this.textLabel );\n\tthis.set.push( this.bg );\n\tthis.set.attr( { opacity:0 } );\n}","prototype":{"show":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"text"},{"title":"param","description":null,"type":null,"name":"x"}]},"Source":"PULSE.CLIENT.TENNIS.TennisTimelineLabel.prototype.show = function ( text, x )\n{\n\tif ( !isNaN( text ) && text > 0 )\n\t{\n//\t\tthis.x = x;\n//\t\t\n//\t\t// Check whether we are off the page\n//\t\tvar displayX = x;\n//\t\tvar pointerDisplayX = x + 1;\n//\t\tvar normalisation = 0;\n//\t\tvar hw = this.config.label.width / 2;\n//\t\t\n//\t\tif ( x <= hw )\n//\t\t{\n//\t\t\tdisplayX = hw + 1;\n//\t\t\tnormalisation = -2;\n//\t\t\tpointerDisplayX = this.config.slider.width / 2 + 2;\n//\t\t}\n//\t\telse if ( x >= this.config.width - hw )\n//\t\t{\n//\t\t\tdisplayX = this.config.width - hw - 1;\n//\t\t\tpointerDisplayX = this.config.width - ( this.config.slider.width / 2 ) - 2;\n//\t\t}\n//\t\t\n//\t\tthis.textValue.attr( { text:text, x:displayX + normalisation } );\n//\t\tthis.textLabel.attr( { x:displayX + normalisation } );\n//\t\t\n//\t\tthis.bg.attr( { x: displayX - hw } );\n//\n//\t\t// Build a new pointer\n//\t\tif ( this.pointer )\n//\t\t{\n//\t\t\tthis.pointer.remove();\n//\t\t}\n//\t\tthis.pointer = this.r.path( 'M' + pointerDisplayX + ' 36L' + (pointerDisplayX-5) + \n//\t\t\t\t                    ' 27L' + (pointerDisplayX+5) + ' 27z' )\n//        \t\t\t     \t .attr( this.pattr );\n//\t\t\n//\t\t// Show and then fade the set\n//\t\tthis.set.attr( { opacity:1 } );\n//\t\t\n//\t\tvar fader = { opacity:0 };\n//\t\tthis.set.animate( fader, 5000 );\n//\t\tthis.pointer.animate( fader, 5000 );\n\t}\n}"}}},"TennisTimeline":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"divId"},{"title":"param","description":null,"type":null,"name":"config"}]},"Source":"PULSE.CLIENT.TENNIS.TennisTimeline = function ( divId, config )\n{\n\tthis.config = config;\n\t\n\t// Create drawing context\n\tthis.r = Raphael( divId, config.width, config.height );\n\n\t// Disclosure bar\n\tthis.disclosure = this.r.rect( 0, config.bar.offset, config.width, config.bar.height )\n\t                        .attr( { fill:config.disclosure.fill, stroke:'none' } );\n\n\t// Slider button\n\tthis.slider = this.r.rect( 0, config.bar.offset, config.slider.width, config.slider.height ) \n\t\t.attr( { stroke:config.slider.stroke, fill:config.slider.fill, 'stroke-width':0.5 } );\n\n\t// Speed label\n\tthis.label = new PULSE.CLIENT.TENNIS.TennisTimelineLabel( this.r, config );\n\t\n\t// No shader bars yet\n\tthis.shaders = [];\n\n\t// Over the top, place a transparent element to capture mouse events\n\tvar that = this;\n\tthis.focuser = this.r.rect( 0, config.bar.offset, config.width, config.bar.height )\n    \t\t\t\t\t .attr( { fill:'#fff', stroke:'none', opacity:0 } );\n\t$(this.focuser.node)\n\t\t\t\t   .mouseover( function ( e ) { that.focus( true ); } )\n\t   \t\t \t   .mouseout(  function ( e ) { that.focus( false ); } )\n\t   \t\t \t   .click(     function ( e ) { that.jumpTo( e ); } )\n\t   \t\t \t   .mousedown( function ( e ) { that.mouse( 'down', Utils.getXY( e ).x );\n\t   \t\t \t   \t\t\t\t\t\t\t\treturn false; } )\n\t   \t\t \t   .mouseup(   function ( e ) { that.mouse( 'up',   Utils.getXY( e ).x ); } )\n\t   \t\t \t   .mousemove( function ( e ) { that.mouse( 'move', Utils.getXY( e ).x ); } );\n}","prototype":{"focus":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"focused"}]},"Source":"PULSE.CLIENT.TENNIS.TennisTimeline.prototype.focus = function ( focused )\n{\n\tif ( focused )\n\t{\n    \tthis.vr.isAnimationPaused = true;\n    \t$(this.focuser.node).css('cursor','pointer');\n\t}\n\telse\n\t{\n    \t$(this.focuser.node).css('cursor','default');\n    \tthis.vr.isAnimationPaused = false;\n        this.vr.increment();\n        this.mouseGrab = false;\n\t}\t\t\n}"},"jumpTo":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"event"}]},"Source":"PULSE.CLIENT.TENNIS.TennisTimeline.prototype.jumpTo = function ( event )\n{\n\tvar xy = Utils.getXY( event );\n\tvar clientCallback = window.setToAnimationMode;\n\tthis.vr.jumpToTime( this.xToTime( xy.x ) ); \n\tif ( clientCallback )\n\t{\n\t\tclientCallback();\n\t}\n}"},"mouse":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"op"},{"title":"param","description":null,"type":null,"name":"x"}]},"Source":"PULSE.CLIENT.TENNIS.TennisTimeline.prototype.mouse = function ( op, x )\n{\n\tvar inSlider = x > ( this.x - ( this.config.slider.width / 2 ) ) &&\n    \t\t\t   x < ( this.x + ( this.config.slider.width / 2 ) ); \n\t\n\tif ( 'down' === op )\n\t{\n\t\tif ( inSlider )\n\t\t{\n\t\t\tthis.mouseGrab = true;\n\t\t}\n\t}\n\telse if ( 'up' === op )\n\t{\n\t\tthis.mouseGrab = false;\n\t}\n\telse if ( 'move' === op )\n\t{\n\t\tif ( this.mouseGrab )\n\t\t{\n\t\t\tthis.vr.jumpToTime( this.xToTime( x ) );\n\t\t}\n\t}\n}"},"setTrajectory":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"traj"},{"title":"param","description":null,"type":null,"name":"resetDisclosure"}]},"Source":"PULSE.CLIENT.TENNIS.TennisTimeline.prototype.setTrajectory = function ( traj, resetDisclosure )\n{\n\t// Save the start/end\n\tthis.meta = traj.getRange();\n\t\n\t// Clear out any current shaders\n\tfor ( var s = 0, slimit = this.shaders.length; s < slimit; s++ )\n\t{\n\t\t// Remove from DOM\n\t\tthis.shaders[s].remove();\n\t}\n\t// Reset array\n\tthis.shaders = [];\n\t\n\t// Reset disclosure enablement\n\tif ( resetDisclosure )\n\t{\n\t\tthis.disclosureActive = true;\n\t}\n\t\n\t// Reset data\n\tthis.setData( this.meta.start, 0, 0, true );\n\t\n\t// Now build shaders\n\tthis.boundaries = [];\n\n\tvar lastEndX = 0;\n\tvar playerIndex = traj.serverIndex;\n\tvar lastDirection;\n\tfor ( var a = 0, alimit = traj.getNumArcs(); a < alimit; a++ )\n\t{\n\t\tvar change = false;\n\t\tvar arc = traj.getArc( a );\n\t\tif ( a === 0 )\n\t\t{\n\t\t\tlastDirection = arc.dx < 0 ? -1 : 1;\n\t\t\tchange = true;\n\t\t}\n\t\telse if ( arc.dx !== 0 )\n\t\t{\n\t\t\tvar direction = arc.dx < 0 ? -1 : 1;\n\t\t\tif ( direction !== lastDirection )\n\t\t\t{\n\t\t\t\tplayerIndex = 1 - playerIndex;\n\t\t\t\tlastDirection = direction;\n\t\t\t\t\n\t\t\t\tchange = true;\n\t\t\t}\n\t\t}\t\t\n\t\t\n\t\tvar startX = a === 0 ? 0 : this.timeToX( arc.time.start );\n\t\tvar endX = a === alimit - 1 ? this.config.width : this.timeToX( arc.time.end );\n\t\t\n\t\t// Ensure we close any gaps from the last end\n\t\tif ( startX >= lastEndX )\n\t\t{\n\t\t\tstartX = lastEndX - 1;\n\t\t}\n\n\t\tif ( change )\n\t\t{\n\t\t\tthis.boundaries.push( startX );\n\t\t}\n\t\t\n \t\tvar c1 = this.config.bar.colors[playerIndex][0];\n\t\tvar c2 = this.config.bar.colors[playerIndex][1];\n\t\tvar fill = '270-rgba(' + c1 + ',0.8)-rgba(' + c2 + ',0.8)';\n\t\t\n\t\tvar shader = this.r.rect( startX, this.config.bar.offset, endX - startX, this.config.bar.height )\n\t\t                   .attr( { stroke:'none', fill:fill } );\n\t\t\n\t\tshader.toBack();\n\t\tthis.shaders.push( shader );\n\t\t\n\t\t// Save the endX\n\t\tlastEndX = endX;\n\t}\n}"},"setData":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"time"},{"title":"param","description":null,"type":null,"name":"speed"},{"title":"param","description":null,"type":null,"name":"dx"},{"title":"param","description":null,"type":null,"name":"immediate"}]},"Source":"PULSE.CLIENT.TENNIS.TennisTimeline.prototype.setData = function ( time, speed, dx, immediate )\n{\n\tif ( immediate )\n\t{\n\t\tdelete this.xdirection;\n\t}\n\n\tthis.setTime( time, immediate );\n\t\n\tif ( dx !== 0 )\n\t{\n\t\tvar dir = dx < 0 ? -1 : 1;\n\t\tif ( this.xdirection !== dir )\n\t\t{\n\t\t\tthis.xdirection = dir;\n\t\t    this.showSpeed( time, speed );\n\t\t}\n\t}\n}"},"timeToX":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"time"}]},"Source":"PULSE.CLIENT.TENNIS.TennisTimeline.prototype.timeToX = function ( time )\n{\n\tvar fraction = ( time - this.meta.start ) / ( this.meta.end - this.meta.start );\n\tvar x = Math.round( ( this.config.slider.width / 2 ) + \n\t        ( fraction * ( this.config.width - this.config.slider.width ) ) );\n\n\tif ( x < this.config.slider.width / 2 )\n\t{\n\t\tx = this.config.slider.width / 2;\n\t}\n\t\n\treturn Math.round( x );\n}"},"xToTime":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"x"}]},"Source":"PULSE.CLIENT.TENNIS.TennisTimeline.prototype.xToTime = function ( x )\n{\n\tvar period = this.meta.end - this.meta.start;\n\tvar fraction = ( x - ( this.config.slider.width / 2 ) ) / ( this.config.width - this.config.slider.width );\n\t\n\tvar t = this.meta.start + ( period * fraction );\n\t\n\treturn t;\n}"},"setTime":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"time"},{"title":"param","description":null,"type":null,"name":"immediate"}]},"Source":"PULSE.CLIENT.TENNIS.TennisTimeline.prototype.setTime = function ( time, immediate )\n{\t\n\tthis.x = this.timeToX( time );\n\tvar attr = { x: this.x - ( this.config.slider.width / 2 ) };\n\t\n\tvar dattr = { x: attr.x, width: this.config.width - attr.x };\n\t\n\tvar animate = false;\n\tif ( animate && !immediate && attr.x > 0 )\n\t{\n\t\tthis.slider.animate( attr, immediate ? 0 : 50 );\n\t\tif ( this.disclosureActive )\n\t\t{\n\t\t\tthis.disclosure.animate( dattr, immediate ? 0 : 50 );\n\t\t}\n\t}\n\telse\n\t{\n\t\tthis.slider.attr( attr );\n\t\tif ( this.disclosureActive )\n\t\t{\n\t\t\tthis.disclosure.attr( dattr );\n\t\t}\n\t}\n}"},"showSpeed":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"time"},{"title":"param","description":null,"type":null,"name":"speed"}]},"Source":"PULSE.CLIENT.TENNIS.TennisTimeline.prototype.showSpeed = function ( time, speed )\n{\n\t// Find real x value\n\tvar realX = this.timeToX( time );\n\tvar x = realX;\n\t\n\t// Now snap to the nearest value in the boundaries array\n\tif ( this.boundaries )\n\t{\n\t\tvar dist = undefined;\n\t\tfor ( var b = 0, blimit = this.boundaries.length; b < blimit; b++ )\n\t\t{\n\t\t\tvar thisDist = Math.abs( realX - this.boundaries[b] );\n\t\t\tif ( dist !== undefined && thisDist > dist )\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tdist = thisDist;\n\t\t\tx = this.boundaries[b];\n\t\t}\n\t}\n\t\n\tif ( x === 0 )\n\t{\n\t\tx = realX + 2;\n\t}\n\t\n\tthis.label.show( speed, x );\n}"},"disableDisclosure":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.CLIENT.TENNIS.TennisTimeline.prototype.disableDisclosure = function ()\n{\n\tthis.disclosureActive = false;\n\tthis.disclosure.attr( { width:0 } );\n}"}}},"VirtualReplayGraph":{"Documentation":{"description":"Constructor.","tags":[{"title":"param","description":"the name of the div holding the background image","type":null,"name":"bgDivId"},{"title":"param","description":"the name of the div prepared for drawing output","type":null,"name":"fgDivId"},{"title":"param","description":"configuration parameters for the graph","type":null,"name":"config"},{"title":"param","description":"the timeline, if one exists","type":null,"name":"timeline"}]},"Source":"PULSE.CLIENT.TENNIS.VirtualReplayGraph = function ( bgDivId, fgDivId, config, timeline )\n{\n    // Save timeline, and reverse reference\n    this.timeline = timeline;\n    if ( this.timeline )\n    {\n        this.timeline.vr = this;\n    }\n\n    // Obtain background div reference\n    this.bg = document.getElementById( bgDivId )\n\n    // Create drawing context\n    this.r = Raphael( fgDivId, config.width, config.height );\n\n    // Save the configuration\n    this.config = config;\n\n    // Calculate number of positions to accommodate tail\n    this.maxPositions = this.config.tailLength / this.config.interval;\n\n    // Flag that identifies if the animation has to be paused\n    this.isAnimationPaused = false;\n\n    // Flag that identifies if animation should loop\n    this.continueLooping = true;\n\n    // Create UI components\n    this.shadow = this.r.ellipse( 0, 0, 0, 0 ).attr( { fill:'rgba(0,0,0,0.5)', stroke:'none' } );\n    this.path = this.r.path();\n    this.ball = this.r.circle( 0, 0, 0 ).attr( { fill:'90-#aa0-#ff0', stroke:'none' } );\n\n\n    this.labelContainers = [ this.r.rect().attr( this.config.labelcontainerattr ),\n                             this.r.rect().attr( this.config.labelcontainerattr ) ];\n    this.config.labelattr.text = ' ';\n    this.labels = [ this.r.text().attr( this.config.labelattr ),\n                    this.r.text().attr( this.config.labelattr ) ];\n\n    // Set the default view\n    this.setView( 1 );\n}","prototype":{"setData":{"Documentation":{"description":"Sets the data that this graph will be showing.","tags":[{"title":"param","description":"the data, as a Base64 encoded arc coefficients string","type":null,"name":"data"}]},"Source":"PULSE.CLIENT.TENNIS.VirtualReplayGraph.prototype.setData = function ( data )\n{\n    this.traj = PULSE.TENNIS.parseTrajectory( data );\n\n    if ( this.timeline )\n    {\n        this.timeline.setTrajectory( this.traj, true );\n    }\n    this.reset();\n    this.refreshLabels();\n}"},"setNames":{"Documentation":{"description":"Sets the names that the graph will be showing.","tags":[{"title":"param","description":"a 2-element names array","type":null,"name":"names"}]},"Source":"PULSE.CLIENT.TENNIS.VirtualReplayGraph.prototype.setNames = function ( names )\n{\n    this.names = names;\n    this.refreshLabels();\n}"},"reset":{"Documentation":{"description":"Resets the animation.","tags":[]},"Source":"PULSE.CLIENT.TENNIS.VirtualReplayGraph.prototype.reset = function ()\n{\n    var range = this.traj.getRange();\n    this.range = { start : range.start - ( this.config.timeMargin / 4000 ),\n                   end   : range.end   + ( this.config.timeMargin / 1000 ) };\n\n    this.time = this.range.start;\n    this.balls = [];\n    this.shadows = [];\n    this.positionIndex = -1;\n    this.startDirection = undefined;\n\n    if ( this.timerId )\n    {\n        clearTimeout( this.timerId );\n    }\n\n    this.increment();\n}"},"setView":{"Documentation":{"description":"Sets the view to the given view.","tags":[{"title":"param","description":"the name of the view to switch to","type":null,"name":"viewName"}]},"Source":"PULSE.CLIENT.TENNIS.VirtualReplayGraph.prototype.setView = function ( viewName )\n{\n    // Set new projection\n    this.projector = new PULSE.Projector( this.config.projections[ viewName ] );\n\n    // Save ball scale\n    this.ballScale = this.config.ballscales[ viewName ];\n\n    // Set new background\n    var bg = this.config.backgrounds[ viewName ];\n\n    if ( this.config.backgroundMethod === 'image' )\n    {\n        var img = new Image();\n        img.src = bg;\n        while ( this.bg.firstChild )\n        {\n            this.bg.removeChild( this.bg.firstChild );\n        }\n        this.bg.appendChild( img );\n    }\n    else\n    {\n        this.bg.setAttribute( 'class', bg );\n        this.bg.setAttribute( 'className', bg );\n    }\n\n    // Reset animation, if we have an active traj\n    if ( this.traj )\n    {\n        this.reset();\n\n        // Reset the timeline too\n        if ( this.timeline )\n        {\n            this.timeline.setTrajectory( this.traj, false );\n        }\n    }\n\n    // Move the labels\n    this.moveLabels( this.config.labelpositions[ viewName ] );\n}"},"moveLabels":{"Documentation":{"description":"Sets the label positions.","tags":[]},"Source":"PULSE.CLIENT.TENNIS.VirtualReplayGraph.prototype.moveLabels = function ( positions )\n{\n    this.labelPositions = positions;\n    this.refreshLabels();\n}"},"refreshLabels":{"Documentation":{"description":"Resizes and positions the labels.","tags":[]},"Source":"PULSE.CLIENT.TENNIS.VirtualReplayGraph.prototype.refreshLabels = function ()\n{\n    if ( this.traj && this.names && this.names.length >= 2 )\n    {\n        var colorSwitch = 0;\n        if ( ( this.traj.serverIndex === 1 && this.traj.getInitialX() < 0 ) ||\n             ( this.traj.serverIndex === 0 && this.traj.getInitialX() > 0 ) )\n        {\n            colorSwitch = 1;\n        }\n\n        for ( var p = 0; p < 2; p++ )\n        {\n            var colorIdx = Math.abs( p - colorSwitch );\n\n            this.labels[p].attr( { text: decodeURI( this.names[colorIdx] ) } );\n\n            var label = this.labels[p];\n            var container = this.labelContainers[p];\n\n            // Flip label positions to match the kludge we did to fix the Hawk-Eye kludge that\n            // flipped VR ends\n            var pos = this.labelPositions[1 - p];\n\n            // Get size of label and container\n            var bb = label.getBBox();\n            var width = bb.width + ( 2 * this.config.labelcontainerattr.hmargin );\n            var height = bb.height + ( 2 * this.config.labelcontainerattr.vmargin );\n\n            var labelattr = {};\n            var containerattr = { width:width, height:height, r:5,\n                                  fill:'rgb(' + this.config.colors[colorIdx] + ')' };\n\n            if ( pos.anchor.indexOf('e') !== -1 )\n            {\n                labelattr.x = pos.x - ( width / 2 );\n                containerattr.x = pos.x - width;\n            }\n            else if ( pos.anchor.indexOf('w') !== -1 )\n            {\n                labelattr.x = pos.x + ( width / 2 );\n                containerattr.x = pos.x;\n            }\n            else\n            {\n                labelattr.x = pos.x;\n                containerattr.x = pos.x - ( width / 2 );\n            }\n\n            if ( pos.anchor.indexOf('n') !== -1 )\n            {\n                labelattr.y = pos.y + ( height / 2 );\n                containerattr.y = pos.y;\n            }\n            else if ( pos.anchor.indexOf('s') !== -1 )\n            {\n                labelattr.y = pos.y - ( height / 2 );\n                containerattr.y = pos.y - height;\n            }\n            else\n            {\n                labelattr.y = pos.y;\n                containerattr.y = pos.y - ( height / 2 );\n            }\n\n            label.attr( labelattr );\n            container.attr( containerattr );\n        }\n    }\n}"},"jumpToTime":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"PULSE.CLIENT.TENNIS.VirtualReplayGraph.prototype.jumpToTime"},{"title":"param","description":null,"type":null,"name":"time"}]},"Source":"PULSE.CLIENT.TENNIS.VirtualReplayGraph.prototype.jumpToTime = function ( time )\n{\n    this.balls = [];\n    this.shadows = [];\n    this.positionIndex = -1;\n\n    // Ensure we snap to a proper increment\n    this.time = this.range.start + ( ( this.config.interval / 1000 ) *\n        Math.round( ( time - this.range.start ) / ( this.config.interval / 1000 ) ) );\n\n    // Do a one-off increment\n    this.increment( true );\n}"},"increment":{"Documentation":{"description":"Private method to increment the VR time, with looping back to start.","tags":[]},"Source":"PULSE.CLIENT.TENNIS.VirtualReplayGraph.prototype.increment = function ( jumped )\n{\n    if ( !this.isAnimationPaused || jumped )\n    {\n        this.positionIndex++;\n        if ( this.positionIndex >= this.maxPositions )\n        {\n            this.positionIndex = 0;\n        }\n\n        var pos = this.traj.getPositionAtTime( this.time );\n\n        if ( pos )\n        {\n            // Apply this hack until we understand how Hawk-Eye tennis VR reverses the x-value\n            pos.x *= -1.0;\n            pos.y *= -1.0;\n\n            if ( !this.startDirection )\n            {\n                this.startDirection = ( pos.dx < 0 ? -1 : 1 );\n            }\n\n            this.balls[ this.positionIndex ] = this.projector.project( pos );\n\n            var gpos = { x: pos.x, y: pos.y, z: 0 };\n            this.shadows[ this.positionIndex ] = this.projector.project( gpos );\n\n            // Work out the color direction\n            var server = this.traj.serverIndex;\n            var other = false;\n\n            if ( pos.dx !== 0 )\n            {\n                var dir = pos.dx < 0 ? -1 : 1;\n                other = this.startDirection !== dir;\n            }\n\n            var colorIndex = Math.abs( server - ( other ? 1 : 0 ) );\n\n            this.cometColor = 'rgba(';\n            this.cometColor += this.config.colors[colorIndex];\n            this.cometColor += ',0.8)';\n\n            if ( this.timeline )\n            {\n                this.timeline.setData( this.time, jumped ? 0 :\n                        Math.round( PULSE.TENNIS.linearMph( this.traj.getSpeedAtTime( this.time ) ) ),\n                        pos.dx );\n            }\n        }\n        else\n        {\n            this.balls[ this.positionIndex ] = null;\n        }\n\n        this.time += ( this.config.interval / 1000 );\n\n        if ( this.time >= this.range.end )\n        {\n            if ( this.timeline )\n            {\n                this.timeline.disableDisclosure();\n            }\n\n            if ( this.continueLooping )\n            {\n                this.time = this.range.start;\n\n                if ( this.timeline )\n                {\n                    this.timeline.setData( this.time, jumped ? 0 :\n                            Math.round( PULSE.TENNIS.linearMph( this.traj.getSpeedAtTime( this.time ) ) ),\n                            0, true );\n                }\n            }\n            else if ( !this.continueLooping && window.animationEndsCallback )\n            {\n                this.isAnimationPaused = true;\n                window.animationEndsCallback();\n            }\n        }\n\n        this.draw( jumped );\n\n        if ( !jumped )\n        {\n            var that = this;\n            if ( this.timerId )\n            {\n                clearTimeout( this.timerId );\n            }\n            this.timerId = setTimeout( function() { that.increment() }, this.config.interval );\n//          requestAnimFrame( function() { that.increment() } );\n        }\n    }\n}"},"draw":{"Documentation":{"description":"Private method to update the scene to show the current ball position and comet tail.","tags":[]},"Source":"PULSE.CLIENT.TENNIS.VirtualReplayGraph.prototype.draw = function ( jumped )\n{\n    var path = '';\n\n    var startIdx = this.positionIndex - this.maxPositions + 1;\n    if ( startIdx < 0 )\n    {\n        startIdx += this.maxPositions;\n    }\n\n    if ( jumped )\n    {\n        startIdx--;\n    }\n\n    // Draw the comet tail as a line\n    var lastBall;\n    var lastShadow;\n    var moved = false;\n\n    for ( var idx = startIdx, i = 1; i < this.maxPositions; idx++, i++ )\n    {\n        if ( idx >= this.maxPositions )\n        {\n            idx = 0;\n        }\n\n        var pos = this.balls[idx];\n\n        if ( pos )\n        {\n            if ( !moved )\n            {\n                path += 'M';\n                moved = true;\n            }\n            else\n            {\n                path += 'L';\n            }\n\n            path += pos.x + ' ' + pos.y;\n\n            lastBall = pos;\n            lastShadow = this.shadows[idx];\n        }\n    }\n\n    // Set comet path\n    this.path.attr( { path:path, stroke:this.cometColor, 'stroke-width':3 } );\n\n    if ( lastBall )\n    {\n        var dist = Math.sqrt( lastBall.dsquared );\n        var size = 3 + ( 2 * ( 30 - dist ) / 30 );\n\n        while ( size < 0 )\n        {\n            size += 2;\n        }\n\n        if ( this.ballScale )\n        {\n            size *= this.ballScale;\n        }\n\n        this.ball.attr( { cx:lastBall.x, cy:lastBall.y, r:size } );\n        this.shadow.attr( { cx:lastShadow.x, cy:lastShadow.y, rx:size, ry:size*0.6 } );\n    }\n    else\n    {\n        this.ball.attr( { r:0 } );\n        this.shadow.attr( { rx:0, ry:0 } );\n    }\n}"}}}}},"GraphProvider":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"PULSE.GraphProvider"}]},"Source":"PULSE.GraphProvider = function ()\n{\n    this.dbType = 'UdsHawkeyeDatabase';\n    this.resync();\n}","prototype":{"setEnvironment":{"Documentation":{"description":"Sets the match type and DB type for this provider to use.","tags":[]},"Source":"PULSE.GraphProvider.prototype.setEnvironment = function ( matchType, dbType )\n{\n    PULSE.Tracer.info( 'setEnvironment matchType=' + matchType + ' dbType=' + dbType );\n    \n    if ( this.matchType !== matchType || this.dbType !== dbType )\n    {\n        this.matchType = matchType;\n        this.dbType = dbType;\n        this.resync();\n    }\n}"},"getAvailableGraphs":{"Documentation":{"description":"Gets all available graph names for the current environment.","tags":[]},"Source":"PULSE.GraphProvider.prototype.getAvailableGraphs = function ()\n{\n    return this.graphNames;\n}"},"current":{"Documentation":{"description":"Returns the currently selected graph.","tags":[]},"Source":"PULSE.GraphProvider.prototype.current = function ()\n{\n    if ( this.index >= this.graphNames.length || this.index < 0 )\n    {\n        return undefined;\n    }\n    else\n    {\n        return this.graphNames[ this.index ];\n    }\n}"},"next":{"Documentation":{"description":"Returns the next graph in the list of graph names. Can be undefined if there are no\navailable graphs.","tags":[]},"Source":"PULSE.GraphProvider.prototype.next = function ()\n{\n    this.index++;\n    if ( this.index >= this.graphNames.length )\n    {\n        this.index = 0;\n    }\n    return this.current();\n}"},"previous":{"Documentation":{"description":"Returns the previous graph in the list of graph names. Can be undefined if there are no\navailable graphs.","tags":[]},"Source":"PULSE.GraphProvider.prototype.previous = function ()\n{\n    this.index--;\n    if ( this.index < 0 )\n    {\n        this.index = this.graphNames.length - 1;\n    }\n    return this.current();\n}"},"currentGraphIdx":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.GraphProvider.prototype.currentGraphIdx = function() {\n\n\tvar current \t= this.current();\n\tvar available \t= this.getAvailableGraphs();\n\t\n\tfor(var i = 0; i < available.length; i++) {\n\t\t\n\t\tvar graph = available[i];\n\t\t\n\t\tif(graph === current)\n\t\t{\n\t\t\treturn i;\n\t\t}\n\t}\n\t\n\treturn -1;\n\t\n}"},"graphIdxByName":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"graphName"}]},"Source":"PULSE.GraphProvider.prototype.graphIdxByName = function( graphName )\n{\n    for( var i = 0; i < this.graphNames.length; i++ )\n    {\n        var graph = this.graphNames[i];\n\n        if( graphName === graph )\n        {\n            return i;\n        }\n    }\n\n    return -1;\n}"},"resync":{"Documentation":{"description":"Resync the list of available graph names supported in the current environment.","tags":[]},"Source":"PULSE.GraphProvider.prototype.resync = function ()\n{\n    this.graphNames = [];\n    \n    this.graphNames.push( 'Trajectory Viewer' );\n    this.index = this.graphNames.length - 1;\n\n    // Those also supported in limited overs\n    if ( CricketMatchType.TEST !== this.matchType )\n    {\n        this.graphNames.push( 'Runs Per Over' );\n        this.graphNames.push( 'Worms' );\n    }\n\n    // Graphs always supported\n    \n    this.graphNames.push( 'Speed Pitch Map' );\n    this.graphNames.push( 'Bowl Speeds' );\n        \n    this.graphNames.push( 'Wagon Wheel' );\n    this.graphNames.push( 'Pitch Map' );\n    this.graphNames.push( 'Beehive Placement' );\n    this.graphNames.push( 'Pitch Map Mountain' );\n\n    // Those also supported in UDS environments\n    if ( 'UdsHawkeyeDatabase' === this.dbType )\n    {\n        this.graphNames.push( 'Win Likelihood' );\n    }\n    \n    this.graphNames.push( 'Partnerships' );\n    this.graphNames.push( 'Variable Bounce' );\n    this.graphNames.push( 'Run Rate' );\n    \n    // Iterate over array, removing graphs that have browser-specific exclusions\n    if ( PULSE.Browser && PULSE.Browser.getExcludedGraphs )\n    {\n        var exclusions = PULSE.Browser.getExcludedGraphs();\n        var newGraphs = [];\n        for ( var i = 0, ilimit = this.graphNames.length; i < ilimit; i++ )\n        {\n            if ( !Utils.isInArray( exclusions, this.graphNames[i] ) )\n            {\n                newGraphs.push( this.graphNames[i] );\n            }\n        }\n        this.graphNames = newGraphs;\n    }\n    \n    PULSE.Tracer.info( 'Available graphs are now: ' + this.graphNames );\n}"},"syncTo":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"name"}]},"Source":"PULSE.GraphProvider.prototype.syncTo = function ( name )\n{\n    for ( var i = 0, j = this.graphNames.length; i < j; i++ )\n    {\n        if ( name === this.graphNames[i] )\n        {\n            this.index = i;\n            break;\n        }\n    }\n}"},"getBestMatch":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"graphName"}]},"Source":"PULSE.GraphProvider.prototype.getBestMatch = function( graphName )\n{\n\tvar graphList = this.getAvailableGraphs();\n\tvar name = PULSE.Levenshtein.bestMatch( graphList, graphName );\n\n\treturn name;\n}"},"graphNameByIdx":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"idx"}]},"Source":"PULSE.GraphProvider.prototype.graphNameByIdx = function( idx )\n{\n    return this.graphNames[idx];\n}"}}},"RaphaelPitchMapRenderer":{"Documentation":{"description":"*********","tags":[]},"Source":"PULSE.RaphaelPitchMapRenderer = function ( config ) \n{\n\tthis.config = config;\n}","isSameCategory":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"PULSE.RaphaelPitchMapRenderer.isSameCategory"},{"title":"param","description":null,"type":null,"name":"a"},{"title":"param","description":null,"type":null,"name":"b"}]},"Source":"PULSE.RaphaelPitchMapRenderer.isSameCategory = function ( a, b )\n{\n\treturn ( a === b || ( a >= 1 && a <= 3 && b >= 1 && b <= 3 ) || ( a >= 4 && b >= 4 ) );\n}"},"prototype":{"isValid":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"row"}]},"Source":"PULSE.RaphaelPitchMapRenderer.prototype.isValid = function ( row )\n{\n\treturn true;\n}"},"render":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"db"},{"title":"param","description":null,"type":null,"name":"data"},{"title":"param","description":null,"type":null,"name":"ctx"}]},"Source":"PULSE.RaphaelPitchMapRenderer.prototype.render = function ( db, data, ctx )\n{\n\tthis.db = db;\n\tthis.data = this.prepareData( data );\n\tthis.ctx = ctx;\n\t\n\tthis.tooltipData = undefined;\n\tthis.draw();\n}"},"getColorKey":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"row"}]},"Source":"PULSE.RaphaelPitchMapRenderer.prototype.getColorKey = function ( row )\n{\n\treturn row.get( CricketField.IS_WICKET ) ? 'w' : row.get( CricketField.DEBIT );\n}"},"compare":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"a"},{"title":"param","description":null,"type":null,"name":"b"}]},"Source":"PULSE.RaphaelPitchMapRenderer.prototype.compare = function ( a, b )\n{\n\tvar aw = a.get( CricketField.IS_WICKET );\n\tvar bw = b.get( CricketField.IS_WICKET );\n\t\n\tif ( aw && !bw )\n\t{\n\t\treturn 1;\n\t}\n\telse if ( !aw && bw )\n\t{\n\t\treturn -1;\n\t}\n\telse\n\t{\n\t\tvar ar = +a.get( CricketField.DEBIT );\n\t\tvar br = +b.get( CricketField.DEBIT );\n\n\t\tif ( PULSE.RaphaelPitchMapRenderer.isSameCategory( ar, br ) )\n\t\t{\n\t\t\tif ( a.get( CricketField.PITCHED ) !== undefined && b.get( CricketField.PITCHED ) !== undefined )\n\t\t\t{\n\t\t\t\treturn ( +a.get( CricketField.PITCHED ).x ) - ( +b.get( CricketField.PITCHED ).x );\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn ar - br;\n\t\t}\n\t}\n\treturn 0;\n}"},"prepareData":{"Documentation":{"description":"This function sorts and projects the balls passed in. It results in an array\nof objects that each have a ball.x/y, a shadow.x/y and a color. It also sets the background image\nappropriately.","tags":[]},"Source":"PULSE.RaphaelPitchMapRenderer.prototype.prepareData = function ( data )\n{\n\tthis.tooltipDataCache = {};\n\n\t// Need to clone the array, so we can sort on BounceX\n\tvar dataArray = Utils.cloneArray( data );\n\t\n\t// Sort the array; also track handedness so we don't need to iterate again\n\tvar hasRight = false;\n\tvar hasLeft = false;\n\tvar that = this;\n\t\n\t// if records are more than 1 then sort them based on handedness\n\tif ( dataArray.length === 1 )\n\t{\n\t\tvar handedness = dataArray[0].get( CricketField.HANDEDNESS );\n\t\tif ( !hasRight && CricketHandedness.RIGHT === handedness )\n\t\t{\n\t\t\thasRight = true;\n\t\t}\n\t\tif ( !hasLeft && CricketHandedness.LEFT === handedness )\n\t\t{\n\t\t\thasLeft = true;\n\t\t}\n\t}\n\telse \n\t{\n\t\tdataArray.sort( function ( a, b ) \n\t\t{\n\t\t\tvar handedness = a.get( CricketField.HANDEDNESS );\n\t\t\tif ( !hasRight && CricketHandedness.RIGHT === handedness )\n\t\t\t{\n\t\t\t\thasRight = true;\n\t\t\t}\n\t\t\tif ( !hasLeft && CricketHandedness.LEFT === handedness )\n\t\t\t{\n\t\t\t\thasLeft = true;\n\t\t\t}\n\t\t\t\n\t\t\treturn that.compare( a, b );\n\t\t} );\n\t}\n\t\n\t// Set background based upon hasLeft/hasRight\n\tif ( hasLeft && hasRight )\n\t{\n\t\tthis.controller.setBackground( this.config.variants.mix.background );\n\t}\n\telse if ( hasLeft )\n\t{\n\t\tthis.controller.setBackground( this.config.variants.lh.background );\n\t}\n\telse if ( hasRight )\n\t{\n\t\tthis.controller.setBackground( this.config.variants.rh.background );\n\t}\n\t\n\t// Iterate through sorted balls\n\tvar preparedData = [];\n\tfor ( var i = 0, j = dataArray.length; i < j; i++ )\n\t{\n\t\tvar row = dataArray[i];\n\t\tvar xyz = row.get( CricketField.PITCHED );\n\t\tif ( xyz !== undefined )\n\t\t{\n\t\t\txyz = this.db.normalise( xyz );\n\t\t\t\n\t\t\tif ( xyz.x > -999 && xyz.y > -999 && this.isValid( row ) )\n\t\t\t{\n\t\t\t\tvar shadow = this.config.projection.project( xyz );\n\t\t\t\txyz.z = 0.036;\n\t\t\t\tvar ball = this.config.projection.project( xyz );\n\t\t\t\t\t\t\t\t\n\t\t\t\tif ( hasLeft && hasRight )\n\t\t\t\t{\n\t\t\t\t\tif ( CricketHandedness.LEFT === row.get( CricketField.HANDEDNESS ) )\n\t\t\t\t\t{\n\t\t\t\t\t\tshadow.x += this.config.variants.lh.offset;\n\t\t\t\t\t\tball.x += this.config.variants.lh.offset;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tshadow.x += this.config.variants.rh.offset;\n\t\t\t\t\t\tball.x += this.config.variants.rh.offset;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tshadow.x -= 3;\n\t\t\t\tshadow.y += 1;\n\t\t\t\t\n\t\t\t\tvar colorKey = this.getColorKey( row );\n\t\t\t\tpreparedData.push( { ball:ball, shadow:shadow, color:this.config.colors[ colorKey ] } );\n\n\t\t\t\tthis.updateTooltipCache( ball, row );\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn preparedData;\n}"},"updateTooltipCache":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"ball"},{"title":"param","description":null,"type":null,"name":"row"}]},"Source":"PULSE.RaphaelPitchMapRenderer.prototype.updateTooltipCache = function ( ball, row )\n{\n\t// Update tooltip cache\n\tvar ix = Math.round( ball.x );\n\tvar iy = Math.round( ball.y );\t\t\t\t\n\tvar tx = this.tooltipDataCache[ ix ];\n\tif ( tx === undefined )\n\t{\n\t\ttx = {};\n\t\tthis.tooltipDataCache[ ix ] = tx;\n\t}\n\t\n\tvar lines = [];\n\tlines.push( '<c:#bbb>Ball </c>' + row.get( CricketField.INNINGS ) + '.' + \n\t\t\t( +row.get( CricketField.OVER ) - 1 ) + '.' +\n\t\t\trow.get( CricketField.COUNTING_BALL ) );\n\tlines.push( row.get( CricketField.BOWLER ) + \n\t\t\t' <c:#bbb>to </c>' + row.get( CricketField.BATSMAN ) );\n\t\n\tvar line3 = '';\n\t\n\tvar bs = row.get( CricketField.BOWL_SPEED );\n\tif ( !Utils.isNullish( bs ) && +bs >= 40 )\n\t{\n\t\tline3 += +bs.toFixed(1) + 'mph';\n\t}\n\t\n\tvar summary = row.generateSummary();\n\tif ( !Utils.isNullish( summary ) )\n\t{\n\t\tif ( line3.length > 0 )\n\t\t{\n\t\t\tline3 += ' <c:#bbb>resulting in </c>';\n\t\t}\n\t\tline3 += summary;\n\t}\n\t\n\tif ( !Utils.isNullish( line3 ) )\n\t{\n\t\tlines.push( line3 );\n\t}\n\t\n\tlines.push( '<c:#888>Click to view trajectory</c>' );\n\t\n\tvar ttd = { lines:lines, x:ix, y:iy, bp:row.get( CricketField.ID ) };\n\tthis.tooltipDataCache[ ix ][ iy ] = ttd;\n}"},"draw":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.RaphaelPitchMapRenderer.prototype.draw = function () \n{\n\t// Parse ball size\n\tvar sz = this.config.ballSize;\n\tvar idx = this.config.ballSize.indexOf('px');\n\tif ( idx !== -1 )\n\t{\n\t\tsz = +( this.config.ballSize.substr( 0, idx ) );\n\t}\n\tsz /= 2;\n\t\n\t// Clear paper\n\tthis.ctx.r.clear();\n\n\t// Add all shadows (pushing them to the back) and balls\n\tfor ( var i = 0, j = this.data.length; i < j; i++ )\n    {\n\t    this.ctx.r.ellipse( this.data[i].shadow.x, this.data[i].shadow.y, sz, sz * 0.6 )\n                  .attr( { fill:'black', opacity:0.3, stroke:'none' } ); \n    }\n\tfor ( var i = 0, j = this.data.length; i < j; i++ )\n\t{\n\t\tvar img = this.config.ballImagePath + this.config.ballSize + '/phe_' + this.data[i].color + '_ball.png';\n\t\tthis.ctx.r.image( img, this.data[i].ball.x - sz, this.data[i].ball.y - sz, sz * 2, sz * 2 );\n\t}\n}"},"updateTooltip":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.RaphaelPitchMapRenderer.prototype.updateTooltip = function ()\n{\n\tif ( this.tooltipData )\n\t{\n\t\t// Remove any current tooltip set\n\t\tif ( this.ttSet )\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tthis.ttSet.remove();\n\t\t\t}\n\t\t\tcatch ( exception )\n\t\t\t{\n\t\t\t\t// Potentially tries to remove an object already cleared\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar cfg = this.config.tooltip;\n\t\tvar anchorv = 'n';\n\t\tvar anchorh = 'w';\n\t\t\n\t\tif ( this.tooltipData.x > this.config.width / 2 )\n\t\t{\n\t\t\tanchorh = 'e';\n\t\t}\n\t\tif ( this.tooltipData.y > this.config.height / 2 )\n\t\t{\n\t\t\tanchorv = 's';\n\t\t}\n\t\t\n\t\tcfg.position = { x:this.tooltipData.x, y:this.tooltipData.y, anchor:anchorv + anchorh };\n\n\t\t// Create a new set and build Raphael object stack for a text field in it\n\t\tthis.ttSet = this.ctx.r.set();\n\t\tvar tf = new PULSE.RaphaelTextField( cfg );\n\t\ttf.setLines( this.tooltipData.lines );\n\t\ttf.render( this.ctx.r, this.ttSet );\n\t}\n\telse\n\t{\n\t\tthis.ttSet.animate( { opacity:0 }, 1000 );\n\t}\n}"},"onMouse":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"event"}]},"Source":"PULSE.RaphaelPitchMapRenderer.prototype.onMouse = function ( event )\n{\n\t// Get XY and then infer ball\n\tvar xy = Utils.getXY( event );\n\tif ( xy !== undefined )\n\t{\n\t\tvar tooltipData = this.findNearbyTooltip( xy );\n\t\tif ( 'mousedown' === event.type )\n\t\t{\n\t\t\tif ( tooltipData !== undefined )\n\t\t\t{\n\t\t\t\tthis.controller.showTrajectory( tooltipData.bp );\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif ( this.tooltipData !== tooltipData )\n\t{\n\t\tthis.tooltipData = tooltipData;\n\t\tthis.updateTooltip();\n\t}\n}"},"findNearbyTooltip":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"xy"}]},"Source":"PULSE.RaphaelPitchMapRenderer.prototype.findNearbyTooltip = function ( xy )\n{\n\tfor ( var s = 0; s < 10; s++ )\n\t{\n\t\tfor ( var x = xy.x - s; x <= xy.x + s; x++ )\n\t\t{\n\t\t\tfor ( var y = xy.y - s; y <= xy.y + s; y++ )\n\t\t\t{\n\t\t\t\tif ( this.tooltipDataCache[ x ] !== undefined &&\n\t\t\t\t\t this.tooltipDataCache[ x ][ y ] !== undefined )\n\t\t\t\t{\n\t\t\t\t\treturn this.tooltipDataCache[ x ][ y ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"}}},"RaphaelVariableBounceRenderer":{"Documentation":{"description":"***************","tags":[]},"Source":"PULSE.RaphaelVariableBounceRenderer = function ( config ) \n{\n\tthis.config = config;\n}","prototype":{"getColorKey":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"row"}]},"Source":"PULSE.RaphaelVariableBounceRenderer.prototype.getColorKey = function ( row )\n{\n\tvar stumps = row.get( CricketField.STUMPS );\n\tif ( row.get( CricketField.IS_WICKET ) )\n\t{\n\t\treturn 'w';\n\t}\n\telse if ( stumps.z > 0.745 )\n\t{\n\t\treturn 'a';\n\t}\n\telse\n\t{\n\t\treturn 's';\n\t}\n}"},"isValid":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"row"}]},"Source":"PULSE.RaphaelVariableBounceRenderer.prototype.isValid = function ( row )\n{\n\tvar pitched = row.get( CricketField.PITCHED );\n\tvar stumps = row.get( CricketField.STUMPS );\n\t\n\tif ( pitched !== undefined && stumps !== undefined )\n\t{\n\t\tvar xyz = { x:pitched.x, y:pitched.y, z:stumps.z };\n\t\txyz = this.db.normalise( xyz );\n\t\t\n\t\treturn xyz.x > -999 && xyz.y > -999 && xyz.z > -999;\n\t}\n\t\n\treturn false;\n}"},"compare":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"a"},{"title":"param","description":null,"type":null,"name":"b"}]},"Source":"PULSE.RaphaelVariableBounceRenderer.prototype.compare = function ( a, b )\n{\n\tvar aw = a.get( CricketField.IS_WICKET );\n\tvar bw = b.get( CricketField.IS_WICKET );\n\t\n\tif ( aw && !bw )\n\t{\n\t\treturn 1;\n\t}\n\telse if ( !aw && bw )\n\t{\n\t\treturn -1;\n\t}\n\telse\n\t{\n\t\tif ( a.get( CricketField.PITCHED ) !== undefined && b.get( CricketField.PITCHED ) !== undefined )\n\t\t{\n\t\t\treturn +a.get( CricketField.PITCHED ).x - +b.get( CricketField.PITCHED ).x;\n\t\t}\n\t}\n\treturn 0;\n}"}}},"RaphaelSpeedPitchMapRenderer":{"Documentation":{"description":"***************","tags":[]},"Source":"PULSE.RaphaelSpeedPitchMapRenderer = function ( config ) \n{\n\tthis.config = config;\n}","prototype":{"getColorKey":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"row"}]},"Source":"PULSE.RaphaelSpeedPitchMapRenderer.prototype.getColorKey = function ( row )\n{\n\tvar speed = +row.get( CricketField.BOWL_SPEED );\n\t\n\t// Convert the speed unit\n    if ( PULSE.SpeedModeController.mode === PULSE.SpeedModeController.MODE_KMH )\n    {\n    \tspeed = PULSE.SpeedModeController.mpsToKmh( speed );\n    }\n\t\n\tfor ( var b = 0, c = this.config.buckets.length; b < c; b++ )\n\t{\n\t\tif ( speed < this.config.buckets[b] )\n\t\t{\n\t\t\treturn b;\n\t\t}\n\t}\n\t\n\treturn this.config.buckets.length;\n}"},"isValid":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"row"}]},"Source":"PULSE.RaphaelSpeedPitchMapRenderer.prototype.isValid = function ( row )\n{\n\tvar bs = row.get( CricketField.BOWL_SPEED );\n\treturn !Utils.isNullish( bs ) && +bs >= 10;\n}"},"compare":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"a"},{"title":"param","description":null,"type":null,"name":"b"}]},"Source":"PULSE.RaphaelSpeedPitchMapRenderer.prototype.compare = function ( a, b )\n{\n\tif ( a.get( CricketField.PITCHED ) !== undefined && b.get( CricketField.PITCHED ) !== undefined )\n\t{\n\t\treturn ( +a.get( CricketField.PITCHED ).x ) - ( +b.get( CricketField.PITCHED ).x );\n\t}\n\treturn 0;\n}"}}},"RaphaelPitchMapMountainRenderer":{"Documentation":{"description":"******************","tags":[]},"Source":"PULSE.RaphaelPitchMapMountainRenderer = function ( config ) \n{\n\tthis.config = config;\n}","prototype":{"bucketise":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"x"},{"title":"param","description":null,"type":null,"name":"y"}]},"Source":"PULSE.RaphaelPitchMapMountainRenderer.prototype.bucketise = function ( x, y )\n{\n\tif ( x >= this.config.boundary.x.min && x <= this.config.boundary.x.max &&\n\t\t y >= this.config.boundary.y.min && y <= this.config.boundary.y.max )\n\t{\n\t\treturn { x : Math.floor( ( x - this.config.boundary.x.min ) / this.config.bucketSize ),\n\t\t\t     y : Math.floor( ( y - this.config.boundary.y.min ) / this.config.bucketSize ) };\n\t}\n}"},"render":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"db"},{"title":"param","description":null,"type":null,"name":"data"},{"title":"param","description":null,"type":null,"name":"ctx"}]},"Source":"PULSE.RaphaelPitchMapMountainRenderer.prototype.render = function ( db, data, ctx )\n{\n\tthis.projectedPoints = {};\n\n\tthis.ctx = ctx;\n\tthis.db = db;\n\t\n\tthis.controller.setBackground( this.config.background );\n\t\n\tctx.r.clear();\n\t\n\tvar bubble1 = Math.sqrt( 8 ) / 3;\n\tvar bubble2 = Math.sqrt( 7 ) / 3;\n\tvar bubble3 = Math.sqrt( 5 ) / 3;\n\tvar bubble4 = 2 / 3;\n\tvar bubble5 = 1 / 3;\n\t\n\t// Bucketise the data\n\tvar heights = {};\n\tvar total = 0;\n\tfor ( var i = 0, j = data.length; i < j; i++ )\n\t{\n\t\tvar row = data[i];\n\t\tvar xyz = row.get( CricketField.PITCHED );\n\t\t\n\t\tif ( xyz !== undefined )\n\t\t{\n\t\t\tvar bucket = this.bucketise( xyz.x, xyz.y );\n\t\t\tif ( bucket !== undefined )\n\t\t\t{\n\t\t\t\tvar x = bucket.x;\n\t\t\t\tvar y = bucket.y;\n\t\t\t\t// Centre point\n\t\t\t\tthis.incrementBucket( heights, x, y, 1 );\n\t\t\t\t// Points one unit away\n\t\t\t\tthis.incrementBucket( heights, x - 1, y, bubble1 );\n\t\t\t\tthis.incrementBucket( heights, x + 1, y, bubble1 );\n\t\t\t\tthis.incrementBucket( heights, x, y - 1, bubble1 );\n\t\t\t\tthis.incrementBucket( heights, x, y + 1, bubble1 );\n\t\t\t\t// Points two steps away (diagonally)\n\t\t\t\tthis.incrementBucket( heights, x - 1, y - 1, bubble2 );\n\t\t\t\tthis.incrementBucket( heights, x - 1, y + 1, bubble2 );\n\t\t\t\tthis.incrementBucket( heights, x + 1, y - 1, bubble2 );\n\t\t\t\tthis.incrementBucket( heights, x + 1, y + 1, bubble2 );\n\t\t\t\t// Points two steps away (linearly)\n\t\t\t\tthis.incrementBucket( heights, x - 2, y, bubble3 );\n\t\t\t\tthis.incrementBucket( heights, x + 2, y, bubble3 );\n\t\t\t\tthis.incrementBucket( heights, x, y - 2, bubble3 );\n\t\t\t\tthis.incrementBucket( heights, x, y + 2, bubble3 );\n\t\t\t\t// Points three steps away\n\t\t\t\tthis.incrementBucket( heights, x - 2, y + 1, bubble4 );\n\t\t\t\tthis.incrementBucket( heights, x - 2, y - 1, bubble4 );\n\t\t\t\tthis.incrementBucket( heights, x + 2, y + 1, bubble4 );\n\t\t\t\tthis.incrementBucket( heights, x + 2, y - 1, bubble4 );\n\t\t\t\tthis.incrementBucket( heights, x - 1, y + 2, bubble4 );\n\t\t\t\tthis.incrementBucket( heights, x + 1, y + 2, bubble4 );\n\t\t\t\tthis.incrementBucket( heights, x - 1, y - 2, bubble4 );\n\t\t\t\tthis.incrementBucket( heights, x + 1, y - 2, bubble4 );\n\t\t\t\t// Points four steps away\n\t\t\t\tthis.incrementBucket( heights, x - 2, y - 2, bubble5 );\n\t\t\t\tthis.incrementBucket( heights, x - 2, y + 2, bubble5 );\n\t\t\t\tthis.incrementBucket( heights, x + 2, y - 2, bubble5 );\n\t\t\t\tthis.incrementBucket( heights, x + 2, y + 2, bubble5 );\n\n\t\t\t\ttotal++;\n\t\t\t}\n\t\t}\n\t}\n\n\tvar triangles = [];\n\t\n\tif ( total > 0 )\n\t{\n\t\tvar xs = ( this.config.boundary.x.max - this.config.boundary.x.min ) / this.config.bucketSize;\n\t\tvar ys = ( this.config.boundary.y.max - this.config.boundary.y.min ) / this.config.bucketSize;\n\t\t\n\t\t// Quickly loop over all the points and work out the max height\n\t\tvar maxHeight = 0;\n\t\tfor ( var x = 0; x <= xs; x++ )\n\t\t{\n\t\t\tfor ( var y = 0; y <= ys; y++ )\n\t\t\t{\n\t\t\t\tmaxHeight = Math.max( maxHeight, this.getHeight( heights, x, y ) );\n\t\t\t}\n\t\t}\n\t\tif ( maxHeight == 0 )\n\t\t{\n\t\t\tmaxHeight = 1;\n\t\t}\n\t\t\n\t\tmaxHeight /= this.config.maxHeight;\n\t\t\n\t\tfor ( var x = 0; x <= xs; x++ )\n\t\t{\n\t\t\tvar xpos1 = this.config.boundary.x.min + ( x * this.config.bucketSize );\n\t\t\tvar xpos2 = xpos1 + this.config.bucketSize;\n\t\t\tfor ( var y = 0; y <= ys; y++ )\n\t\t\t{\n\t\t\t\tvar ypos1 = this.config.boundary.y.min + ( y * this.config.bucketSize );\n\t\t\t\tvar ypos2 = ypos1 + this.config.bucketSize;\n\t\t\t\t\n\t\t\t\t// Get the height at the four corners\n\t\t\t\tvar height1 = this.getHeight( heights, x, y ) / maxHeight;\n\t\t\t\tvar height2 = this.getHeight( heights, x + 1, y ) / maxHeight;\n\t\t\t\tvar height3 = this.getHeight( heights, x, y + 1 ) / maxHeight;\n\t\t\t\tvar height4 = this.getHeight( heights, x + 1, y + 1 ) / maxHeight;\n\t\t\t\t\n\t\t\t\t// Triangle 1\n\t\t\t\tif ( height2 > 0 || height3 > 0 || height4 > 0 )\n\t\t\t\t{\n\t\t\t\t\ttriangles.push( {\n\t\t\t\t\t\tp1 : { x: xpos2, y: ypos1, z: height2 },\n\t\t\t\t\t\tp2 : { x: xpos2, y: ypos2, z: height4 },\n\t\t\t\t\t\tp3 : { x: xpos1, y: ypos2, z: height3 }\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Triangle 2\n\t\t\t\tif ( height1 > 0 || height2 > 0 || height3 > 0 )\n\t\t\t\t{\n\t\t\t\t\ttriangles.push( {\n\t\t\t\t\t\tp1 : { x: xpos1, y: ypos1, z: height1 },\n\t\t\t\t\t\tp2 : { x: xpos2, y: ypos1, z: height2 },\n\t\t\t\t\t\tp3 : { x: xpos1, y: ypos2, z: height3 }\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tthis.renderMesh( triangles );\n\t}\n}"},"incrementBucket":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"heights"},{"title":"param","description":null,"type":null,"name":"x"},{"title":"param","description":null,"type":null,"name":"y"},{"title":"param","description":null,"type":null,"name":"amount"}]},"Source":"PULSE.RaphaelPitchMapMountainRenderer.prototype.incrementBucket = function ( heights, x, y, amount )\n{\n\tif ( heights[ x ] === undefined )\n\t{\n\t\theights[ x ] = {};\n\t}\n\tif ( heights[ x ][ y ] === undefined )\n\t{\n\t\theights[ x ][ y ] = 0;\n\t}\n\n\theights[ x ][ y ] += amount;\n}"},"getHeight":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"heights"},{"title":"param","description":null,"type":null,"name":"x"},{"title":"param","description":null,"type":null,"name":"y"}]},"Source":"PULSE.RaphaelPitchMapMountainRenderer.prototype.getHeight = function ( heights, x, y )\n{\n\tvar height = 0;\n\tif ( heights[ x ] !== undefined && heights[ x ][ y ] !== undefined )\n\t{\n\t\theight = heights[ x ][ y ];\n\t}\n\treturn height;\n}"},"renderMesh":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"triangles"}]},"Source":"PULSE.RaphaelPitchMapMountainRenderer.prototype.renderMesh = function ( triangles )\n{\n\tfor ( var i = 0, limit = triangles.length; i < limit; i++ )\n\t{\n\t\tvar triangle = triangles[ i ];\n\t\t\n\t\tvar p1 = this.db.normalise( { x:triangle.p1.x, y:triangle.p1.y, z:triangle.p1.z } );\n\t\tvar p2 = this.db.normalise( { x:triangle.p2.x, y:triangle.p2.y, z:triangle.p2.z } );\n\t\tvar p3 = this.db.normalise( { x:triangle.p3.x, y:triangle.p3.y, z:triangle.p3.z } );\n\t\t\n\t\tvar d1 = { x: p2.x - p1.x, y: p2.y - p1.y, z: p2.z - p1.z };\n\t\tvar d2 = { x: p3.x - p2.x, y: p3.y - p2.y, z: p3.z - p2.z };\n\t\t\n\t\t// Calculate the normal vector for the triangle using the cross product\n\t\tvar crossProduct = { x: d1.y * d2.z - d1.z * d2.y,\n\t\t\t\t             y: d1.z * d2.x - d1.x * d2.z,\n\t\t\t\t             z: d1.x * d2.y - d1.y * d2.x };\n\t\t// Work out the length of the vector\n\t\tvar crossProductSize = Math.sqrt( crossProduct.x * crossProduct.x + \n\t\t\t\tcrossProduct.y * crossProduct.y + crossProduct.z * crossProduct.z );\n\t\t// Normalise the cross product vector\n\t\tcrossProduct.x /= crossProductSize;\n\t\tcrossProduct.y /= crossProductSize;\n\t\tcrossProduct.z /= crossProductSize;\n\t\t\n\t\t// Work out the dot product of the normal and light vector to work out the angle between them\n\t\tvar dotProduct = crossProduct.x * this.config.light.x + \n\t\t                 crossProduct.y * this.config.light.y +\n\t\t                 crossProduct.z * this.config.light.z;\n\t\t\n\t\tif ( dotProduct < 0 )\n\t\t{\n\t\t\t// The triangle is facing away from the camera, so skip this one\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tdotProduct = dotProduct * this.config.lightStrength + 1 - this.config.lightStrength;\n\t\t\n\t\tvar color = { r : dotProduct * this.config.color.r,\n\t\t\t\t      g : dotProduct * this.config.color.g,\n\t\t\t\t      b : dotProduct * this.config.color.b };\n\t\t\n\t\tvar colorString = 'rgb(' + +Math.round( color.r * 255 ) + ',' + +Math.round( color.g * 255 ) + ',' + +Math.round( color.b * 255 ) + ')';\n\t\tvar pos1 = this.project( p1 );\n\t\tvar pos2 = this.project( p2 );\n\t\tvar pos3 = this.project( p3 );\n\n\t\tvar pathString = 'M' + pos1.x + ' ' + pos1.y +\n\t\t\t\t\t\t 'L' + pos2.x + ' ' + pos2.y +\n\t\t\t\t\t\t 'L' + pos3.x + ' ' + pos3.y + 'z';\n\t\t\n\t\tthis.ctx.r.path( pathString ).attr( { fill:colorString, stroke:colorString } );\n\t}\n}"},"project":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"xyz"}]},"Source":"PULSE.RaphaelPitchMapMountainRenderer.prototype.project = function ( xyz )\n{\n\t// This projects a world point to a screen point, but caches the result so that subsequent\n\t// invocations are quicker\n\n\tvar key = xyz.x + ',' + xyz.y + ',' + xyz.z;\n\tvar projected = this.projectedPoints[ key ];\n\t\n\tif ( !projected )\n\t{\n\t\tprojected = this.config.projection.project( xyz );\n\t\tthis.projectedPoints[ key ] = projected;\n\t}\n\t\n\treturn projected;\n}"}}},"RaphaelWagonWheelRenderer":{"Documentation":{"description":"***********","tags":[]},"Source":"PULSE.RaphaelWagonWheelRenderer = function ( config )\n{\n\tthis.config = config;\n\tthis.selected = -1;\n}","prototype":{"render":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"PULSE.RaphaelWagonWheelRenderer.prototype.render"},{"title":"param","description":null,"type":null,"name":"db"},{"title":"param","description":null,"type":null,"name":"data"},{"title":"param","description":null,"type":null,"name":"ctx"}]},"Source":"PULSE.RaphaelWagonWheelRenderer.prototype.render = function ( db, data, ctx )\n{\n\tctx.r.clear();\n\tthis.sets = [ ctx.r.set(), ctx.r.set(), ctx.r.set(), ctx.r.set() ];\n\tthis.selected = -1;\n\n\t// Get the scales\n\tvar yscale = this.config.scale.y;\n\tvar xscale = this.config.scale.x;\n\n\tvar screenOrigin = this.config.transform( 0, 0, 1 );\n\n\tvar sign = db.getParameter( 'ww-sign' );\n\tvar origin = this.config.transform( db.getParameter( 'ww-origin-x' ), 0, sign );\n\n\tthis.controller.setBackground( this.config.background, this.config.selector );\n\n\t// Stats object which is used to populate the annotated key\n\tvar stats = { runs:0, balls:0, scoring:0, runsleg:0, runsoff:0 };\n\n\tvar keyStats = { singles:0, twothrees:0, fours:0, sixes:0 };\n\n\t// Clone the data so we can sort on number of runs; singles are nearest the top, as other\n\t// shots will typically be longer and poke out from underneath; the exception is that 6s\n\t// should appear on top of 4/5s\n\tvar dataArray = Utils.cloneArray( data );\n\n\t// Sort the array\n\tdataArray.sort( function ( a, b )\n\t{\n\t\tvar ar = +a.get( CricketField.CREDIT );\n\t\tvar br = +b.get( CricketField.CREDIT );\n\n\t\tif ( ar === 6 && br >= 4 )\n\t\t{\n\t\t\treturn ar - br;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn br - ar;\n\t\t}\n\t} );\n\n\tfor ( var i = 0, ilimit = dataArray.length; i < ilimit; i++ )\n\t{\n\t\tvar row = dataArray[i];\n\t\tvar extraType = row.get( CricketField.EXTRA_TYPE );\n\t\t// ignore wide and wide-bye balls as they are not batsman-faced-balls\n\t\tif ( extraType !== \"Wd\" && extraType !== \"WdB\" )\n\t\t{\n\t\t\tstats.balls++;\n\t\t}\n\n\t\tvar landing = row.get( CricketField.WW );\n\t\t// if ( landing !== undefined && landing.x > -999 && landing.y > -999 )\n\t\t// if( true )\n\t\t// {\n\t\t\tvar runs = ( +row.get( CricketField.CREDIT ) );\n\t\t\tif ( runs > 0 )\n\t\t\t{\n\t\t\t\t// Update stats\n\t\t\t\tstats.scoring++;\n\t\t\t\tstats.runs += runs;\n\n\t\t\t\tswitch ( runs )\n\t\t\t\t{\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tkeyStats.singles++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tkeyStats.twothrees++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\tcase 5:\n\t\t\t\t\t\tkeyStats.fours++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 6:\n\t\t\t\t\t\tkeyStats.sixes++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tvar lh = ( row.get( CricketField.HANDEDNESS ) === CricketHandedness.LEFT );\n\n\t\t\t\tif( landing && landing.x > -999 && landing.y > -999 )\n\t\t\t\t{\n\t\t\t\t\tif ( ( lh && landing.y < 0 ) || ( !lh && landing.y >= 0 ) )\n\t\t\t\t\t{\n\t\t\t\t\t\tstats.runsleg += runs;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tstats.runsoff += runs;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Transform to screen position\n\t\t\t\t\tvar screenPos = this.config.transform( landing.x, landing.y, sign );\n\n\t\t\t\t\t// Scale to ensure 4+ runs go to the rope\n\t\t\t\t\tif ( runs >= 4 )\n\t\t\t\t\t{\n\t\t\t\t\t\tscreenPos = Utils.scaleLine( origin, screenPos, 200 );\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tvar len = this.config.scaleback ? this.config.scaleback.length : 170;\n\t\t\t\t\t\tvar amt = this.config.scaleback ? this.config.scaleback.amount : 0.8;\n\n\t\t\t\t\t\tscreenPos = Utils.scaleLineRel( origin, screenPos, len, amt );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check for intersection of the current line and the current clip.\n\t\t\t\t\t// This uses the 2D library from http://www.kevlindev.com/ (no obvious licensing issues)\n\t\t\t\t\tvar c = { x:screenOrigin.x, y:screenOrigin.y + 2 };\n\t\t\t\t    var rx = 184 * xscale;\n\t\t\t\t    var ry = 184 * yscale;\n\t\t\t\t    var a1 = new Point2D( origin.x, origin.y );\n\t\t\t\t    var a2 = new Point2D( screenPos.x, screenPos.y );\n\n\t\t\t\t\tvar inter = Intersection.intersectEllipseLine( c, rx, ry, a1, a2 );\n\t\t\t\t    if ( 'Intersection' === inter.status && inter.points.length > 0 )\n\t\t\t\t    {\n\t\t\t\t    \tscreenPos = { x:inter.points[0].x, y:inter.points[0].y };\n\t\t\t\t    }\n\n\t\t\t\t\tvar bucket = PULSE.RaphaelWagonWheelRenderer.BUCKETS[ runs ];\n\t\t\t\t\tvar line = ctx.r.path( 'M' + origin.x + ' ' + origin.y +\n\t\t\t\t\t\t\t               'L' + screenPos.x + ' ' + screenPos.y )\n\t\t\t\t\t\t\t        .attr( { stroke:this.config.colors[ runs ][1],\n\t\t\t\t\t\t\t       \t        'stroke-width':this.config.lineWidth } );\n\n\t\t\t\t\tthis.sets[bucket].push( line );\n\t\t\t\t}\n\n\t\t\t}\n\t\t// }\n\t}\n\n\t// Convert runs to leg/off to percentages\n\tvar tot = stats.runsleg + stats.runsoff;\n\tif ( tot > 0 )\n\t{\n\t\tstats.runsleg = ( Math.round( 100 * stats.runsleg / tot ) );\n\t\tstats.runsoff = ( 100 - stats.runsleg ) + '%';\n\t\tstats.runsleg += '%';\n\t}\n\telse\n\t{\n\t\tstats.runsleg = '';\n\t\tstats.runsoff = '';\n\t}\n\n\t// Write stats annotations\n\tvar attrs = this.config.font;\n\tfor ( var key in stats )\n\t{\n\t\tif ( key !== 'x' )\n\t\t{\n\t\t\tvar cfg = this.config.key[ key ];\n\n            if( !cfg )\n            {\n                continue;\n            }\n\n\t\t\tvar color = cfg.color;\n\t\t\tvar color2 = cfg.lcolor || cfg.color;\n            var offset = cfg.x || [ 0, 0 ];\n\n\t\t\tif ( this.config.keyDisplayMode === 'values' )\n\t\t\t{\n\t\t\t}\n\t\t\telse if ( this.config.keyDisplayMode === 'labelsandvalues' )\n            {\n                attrs['text-anchor'] = 'start';\n                attrs['fill'] = color2;\n                ctx.r.text( this.config.key.x[0] + offset[0], PULSE.Browser.y( cfg.y ), cfg.label ).attr( attrs );\n\n                attrs['text-anchor'] = 'end';\n                attrs['fill'] = color;\n                ctx.r.text( this.config.key.x[1] + offset[1], PULSE.Browser.y( cfg.y ), stats[ key ] ).attr( attrs );\n            }\n\t\t}\n\t}\n\n\t// Now write any freetext\n\tif ( this.config.freetext && this.config.freetext.text )\n\t{\n\t\tvar tf = new PULSE.RaphaelTextField( this.config.freetext );\n\t\ttf.addLine( this.config.freetext.text );\n\t\ttf.render( ctx.r, ctx.r.set() );\n\t}\n\n\t// tell the controll to update WW key values if setWWKeyValues exists\n\tif( PULSE.GraphController.setWWKeyValues )\n\t{\n\t\tPULSE.GraphController.setWWKeyValues( keyStats );\n\t}\n\telse\n\t{\n\t\t// Write stats annotations\n\t\tvar attrs = this.config.font;\n\t\tfor ( var key in keyStats )\n\t\t{\n\t\t\tif ( key !== 'x' )\n\t\t\t{\n\t\t\t\tvar cfg = this.config.key[ key ];\n\n                if( !cfg )\n                {\n                    continue;\n                }\n\n\t\t\t\tvar color = cfg.color;\n\t\t\t\tvar color2 = cfg.lcolor || cfg.color;\n                var offset = cfg.x || [ 0, 0 ];\n\n\t\t\t\tif ( this.config.keyDisplayMode === 'values' )\n\t\t\t\t{\n\t\t\t\t}\n\t\t\t\telse if ( this.config.keyDisplayMode === 'labelsandvalues' )\n                {\n                    attrs['text-anchor'] = 'start';\n                    attrs['fill'] = color2;\n                    ctx.r.text( this.config.key.x[0] + offset[0], PULSE.Browser.y( cfg.y ), cfg.label ).attr( attrs );\n\n                    attrs['text-anchor'] = 'end';\n                    attrs['fill'] = color;\n                    ctx.r.text( this.config.key.x[1] + offset[1], PULSE.Browser.y( cfg.y ), keyStats[ key ] ).attr( attrs );\n                }\n\t\t\t}\n\t\t}\n\t}\n}"},"updateToSelection":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.RaphaelWagonWheelRenderer.prototype.updateToSelection = function ()\n{\n\tfor ( var s = 0, slimit = this.sets.length; s < slimit; s++ )\n\t{\n\t\tvar opacity = this.selected === s || this.selected === -1 ? 1 : 0;\n\t\tthis.sets[s].animate( { opacity:opacity }, 500 );\n\t}\n}"},"onMouse":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"event"}]},"Source":"PULSE.RaphaelWagonWheelRenderer.prototype.onMouse = function ( event )\n{\n\t// Get XY and then infer run class selection index\n\tvar xy = Utils.getXY( event );\n\tvar selection = -1;\n\t\n\tif ( xy !== undefined && xy.x >= this.config.keyLabelLeftLimit && xy.x <= this.config.keyLabelRightLimit\n\t\t\t&& xy.y >= this.config.keyLabelTopLimit && xy.y <= this.config.keyLabelBottomLimit )\n\t{\n\t\tselection = Math.floor( ( xy.y - this.config.keyLabelTopLimit ) / this.config.keyLabelWidth );\n\t}\n\t\n\tif ( selection !== this.selected )\n\t{\n\t\tthis.selected = selection;\n\t\tthis.updateToSelection();\n\t}\n}"}},"pointDownLine":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"start"},{"title":"param","description":null,"type":null,"name":"end"},{"title":"param","description":null,"type":null,"name":"amount"},{"title":"param","description":null,"type":null,"name":"isFraction"}]},"Source":"PULSE.RaphaelWagonWheelRenderer.pointDownLine = function ( start, end, amount, isFraction )\n{\n\tvar dx = end.x - start.x;\n\tvar dy = end.y - start.y;\n\n\tif ( isFraction )\n\t{\n\t\treturn { x: start.x + ( amount * dx ),\n\t\t\t     y: start.y + ( amount * dy ) };\n\t}\n\telse\n\t{\n\t\tvar theta = Math.atan2( dy, dx );\n\t\tif ( Math.sqrt( ( dx * dx ) + ( dy * dy ) ) <= amount )\n\t\t{\n\t\t\treturn { x: end.x + ( 3 * Math.cos( theta ) ),\n\t\t\t\t     y: end.y + ( 3 * Math.sin( theta ) ) };\n\t\t\t// Ignore, as the current length is smaller than the target\n\t\t\t//return end;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn { x: start.x + ( amount * Math.cos( theta ) ),\n\t\t\t\t\t y: start.y + ( amount * Math.sin( theta ) ) };\n\t\t}\n\t}\n}"}},"RaphaelBeehiveRenderer":{"Documentation":{"description":"*****************","tags":[]},"Source":"PULSE.RaphaelBeehiveRenderer = function ( config )\n{\n\tthis.config = config;\n}","prototype":{"render":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"db"},{"title":"param","description":null,"type":null,"name":"data"},{"title":"param","description":null,"type":null,"name":"ctx"}]},"Source":"PULSE.RaphaelBeehiveRenderer.prototype.render = function ( db, data, ctx )\n{\n\tvar that = this;\n\tctx.r.clear();\n\n\t// Need to clone the array, so we can sort on type of ball\n\tvar dataArray = Utils.cloneArray( data );\n\n\t// Sort the array\n\tdataArray.sort( function ( a, b )\n\t{\n\t\tvar aw = a.get( CricketField.IS_WICKET );\n\t\tvar bw = b.get( CricketField.IS_WICKET );\n\n\t\tif ( aw && !bw )\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse if ( !aw && bw )\n\t\t{\n\t\t\treturn -1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar ar = a.get( CricketField.CREDIT );\n\t\t\tvar br = b.get( CricketField.CREDIT );\n\t\t\treturn ar - br;\n\t\t}\n\t\treturn 0;\n\t} );\n\n\t// Determine what variant of graph this is: left only, right only or mix\n\tvar hasRight = false;\n\tvar hasLeft = false;\n\tfor ( var i = 0, j = dataArray.length; i < j; i++ )\n\t{\n\t\tvar row = dataArray[i];\n\t\tvar handedness = row.get( CricketField.HANDEDNESS );\n\n\t\tif ( CricketHandedness.RIGHT === handedness )\n\t\t{\n\t\t\thasRight = true;\n\t\t}\n\t\telse if ( CricketHandedness.LEFT === handedness )\n\t\t{\n\t\t\thasLeft = true;\n\t\t}\n\n\t\tif ( hasLeft && hasRight )\n\t\t{\n\t\t\t// Early exit, as we now know this is a mix graph\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Set background based upon hasLeft/hasRight\n\tif ( hasLeft && hasRight )\n\t{\n\t\tthis.controller.setBackground( this.config.variants.mix.background );\n\t}\n\telse if ( hasLeft )\n\t{\n\t\tthis.controller.setBackground( this.config.variants.lh.background );\n\t}\n\telse if ( hasRight )\n\t{\n\t\tthis.controller.setBackground( this.config.variants.rh.background );\n\t}\n\n\t// Parse ball size\n\tvar sz = this.config.ballSize;\n\tvar idx = this.config.ballSize.indexOf('px');\n\tif ( idx !== -1 )\n\t{\n\t\tsz = +( this.config.ballSize.substr( 0, idx ) );\n\t}\n\tsz /= 2;\n\n\t// Render all the balls\n\tfor ( var i = 0, j = dataArray.length; i < j; i++ )\n\t{\n\t\tvar row = dataArray[i];\n\t\tvar xyz = row.get( CricketField.STUMPS );\n\n\t\tif ( xyz !== undefined )\n\t\t{\n\t\t\txyz = db.normalise( xyz );\n\n\t\t\tif ( xyz.x > -999 && xyz.y > -999 && xyz.z > -999 )\n\t\t\t{\n\t\t\t\t// Flip data for lefties\n\t\t\t\tif ( ( CricketHandedness.LEFT === row.get( CricketField.HANDEDNESS ) ) && hasRight )\n\t\t\t\t{\n\t\t\t\t\txyz.y = -xyz.y;\n\t\t\t\t}\n\n\t\t\t\tvar runs = row.get( CricketField.CREDIT );\n\t\t\t\tvar screenPos = this.config.projection.project( xyz );\n\n\t\t\t\tvar colorKey;\n\t\t\t\tif ( row.get( CricketField.IS_WICKET ) )\n\t\t\t\t{\n\t\t\t\t\tcolorKey = 'w';\n\t\t\t\t}\n\t\t\t\telse if ( runs == 0 )\n\t\t\t\t{\n\t\t\t\t\tcolorKey = 'd';\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar ww = row.get( CricketField.WW );\n\t\t\t\t\tif ( ww !== undefined )\n\t\t\t\t\t{\n\t\t\t\t\t\tvar ly = ww.y;\n\t\t\t\t\t\tif ( ly > -999 )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar leg = ly > 0;\n\t\t\t\t\t\t\tif ( CricketHandedness.LEFT === row.get( CricketField.HANDEDNESS ) )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tleg = !leg;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( runs >= 4 )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcolorKey = leg ? 'lb' : 'ob';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcolorKey = leg ? 'l' : 'o';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar img = this.config.ballImagePath + this.config.ballSize + '/phe_' + this.config.colors[ colorKey ] + '_ball.png';\n\t\t\t\tctx.r.image( img, screenPos.x - sz, screenPos.y - sz, sz * 2, sz * 2 );\n\t\t\t}\n\t\t}\n\t}\n}"}}},"RaphaelBowlSpeedsRenderer":{"Documentation":{"description":"***********","tags":[]},"Source":"PULSE.RaphaelBowlSpeedsRenderer = function ( config )\n{\n\tthis.config = config;\n\tthis.selected = -1;\n\tthis.stickies = [];\n}","prototype":{"render":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"db"},{"title":"param","description":null,"type":null,"name":"data"},{"title":"param","description":null,"type":null,"name":"ctx"}]},"Source":"PULSE.RaphaelBowlSpeedsRenderer.prototype.render = function ( db, data, ctx )\n{\n\tthis.db = db;\n\tthis.data = data;\n\tthis.ctx = ctx;\n\tthis.selected = -1;\n\tthis.stickies = [];\n\n\t// Prepare the data\n\t// Place balls into bowler buckets\n\tthis.bowlerData = {};\n\tthis.wicketData = {};\n\tthis.maxPoints = 20;\n\n\tfor ( var i = 0, j = this.data.length; i < j; i++ )\n\t{\n\t\tvar row = this.data[i];\n\t\tvar bowler = this.db.lookupPlayer( row.get( CricketField.BOWLER ) );\n\t\tvar speed = row.get( CricketField.BOWL_SPEED );\n\n\t\tif ( !Utils.isNullish( bowler ) && speed >= 10 )\n\t\t{\n\t\t\t// Convert speed to units currently in use\n\t        if ( PULSE.SpeedModeController.mode === PULSE.SpeedModeController.MODE_KMH )\n\t        {\n\t        \tspeed = PULSE.SpeedModeController.mpsToKmh( speed );\n\t        }\n\n\t\t\t// Handle speed data for this bowler\n\t\t\tvar bd = this.bowlerData[ bowler ];\n\t\t\tif ( bd === undefined )\n\t\t\t{\n\t\t\t\tbd = [];\n\t\t\t\tthis.bowlerData[ bowler ] = bd;\n\t\t\t}\n\t\t\tbd.push( speed );\n\n\t\t\t// Ensure we keep track of the lengthiest series\n\t\t\tif ( bd.length > this.maxPoints )\n\t\t\t{\n\t\t\t\tthis.maxPoints = bd.length;\n\t\t\t}\n\n\t\t\t// Handle a wicket fall\n\t\t\tif ( row.get( CricketField.IS_WICKET ) )\n\t\t\t{\n\t\t\t\tvar wf = this.wicketData[ bowler ];\n\t\t\t\tif ( wf === undefined )\n\t\t\t\t{\n\t\t\t\t\twf = [];\n\t\t\t\t\tthis.wicketData[ bowler ] = wf;\n\t\t\t\t}\n\t\t\t\twf.push( { x:bd.length, y:speed } );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Get the maximum bowler name width, so we can adjust the key/graph width\n\tthis.maxWidth = 90;\n\tfor ( var bowler in this.bowlerData )\n\t{\n\t\tvar temp = this.ctx.r.text( 0, 0, bowler ).attr( this.config.font );\n\t\tvar size = temp.getBBox();\n\t\tif ( size.width > this.maxWidth )\n\t\t{\n\t\t\tthis.maxWidth = size.width;\n\t\t}\n\t\ttemp.remove();\n\t}\n\n\tthis.draw();\n}"},"draw":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.RaphaelBowlSpeedsRenderer.prototype.draw = function ()\n{\n\tthis.ctx.r.clear();\n\tthis.bowlerObjects = [];\n\n\t// Draw key shading box\n\tvar keyMarginR = this.config.keyMarginR ? this.config.keyMarginR : this.config.keyMargin;\n\tvar boxWidth = this.maxWidth + this.config.keyMargin + keyMarginR;\n\n\tthis.ctx.r.rect( this.config.width - boxWidth, 0, boxWidth, this.config.height )\n\t          .attr( { fill:this.config.keyFill.color, opacity:this.config.keyFill.opacity,\n\t        \t       stroke:'none' } );\n\n\t// And size the x-axis\n\tthis.config.xAxis.end = this.config.width - boxWidth - ( 2 * this.config.keyMargin );\n\n\t// Dynamically set the xAxis range\n\tthis.config.xAxis.max = this.maxPoints;\n\n\t// Draw the axes\n\tthis.config.xAxis.font = this.config.font;\n\tthis.config.yAxis.font = this.config.font;\n\tthis.config.xAxis.drawTo( this.ctx.r, true );\n\tthis.config.yAxis.drawTo( this.ctx.r, false );\n\n\t// Now create objects for each bowler's stats\n\tvar y = 20;\n\tvar i = 0;\n\tvar selectedBowler;\n\tfor ( var bowler in this.bowlerData )\n\t{\n\t\tvar bowlerObjects = {};\n\n\t\tvar speeds = this.bowlerData[ bowler ];\n\t\tvar falls = this.wicketData[ bowler ];\n\t\tvar stats = Utils.getStats( speeds );\n\n\t\t// Create name label\n\t\tbowlerObjects.name = this.ctx.r.text( this.config.width - keyMarginR, PULSE.Browser.y( y ), bowler )\n\t\t                               .attr( this.config.font )\n\t\t                               .attr( { 'text-anchor':'end', stroke:'none' } );\n\n\t\ty += 15;\n\n\t\t// Create speeds label\n\t\tbowlerObjects.speeds = this.ctx.r.text( this.config.width - keyMarginR, PULSE.Browser.y( y ),\n\t\t\t\t\t\t\t\t\t\t\t\tstats.mean.toFixed( 1 ) + ' / ' + stats.maximum.toFixed( 1 ) )\n\t\t\t\t\t\t\t\t\t\t .attr( this.config.font )\n\t\t\t\t\t\t\t\t\t\t .attr( { 'text-anchor':'end', stroke:'none' } );\n\n\t\ty += 27;\n\n\t\t// Create stickies background\n\t\tbowlerObjects.bg = this.ctx.r.rect( this.config.width - boxWidth + ( this.config.keyMargin / 2 ),\n\t\t\t\t\t\t\t\t\t\t    y - 52,\tboxWidth - keyMarginR, 37 )\n\t\t\t\t\t\t\t\t     .attr( { fill:'#fff', stroke:'none', opacity:0 } );\n\n\t\t// Create the line and wicket set, adding them to the container\n\t\tthis.renderSeries( bowlerObjects,\n\t\t\t\tthis.config.boxWhisker, this.ctx.r, bowler, speeds, falls, this.config.colors[i], i );\n\n\t\t// Add Raphael object container to list of containers\n\t\tthis.bowlerObjects.push( bowlerObjects );\n\n\t\t// Maximum of 8 bowlers\n\t\tif ( ++i > 7 )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tthis.bowlerCount = i;\n\n\t// Finally drive an initial updateToSelection to set colors and thicknesses\n\tthis.updateToSelection();\n\n\t//render background\n\tthis.controller.setBackground( this.config.background );\n}"},"updateToSelection":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.RaphaelBowlSpeedsRenderer.prototype.updateToSelection = function ()\n{\n\tfor ( var bowler = 0; bowler < this.bowlerCount; bowler++ )\n\t{\n\t\tvar color = this.getColor( this.config.colors[bowler], bowler, this.selected, this.stickies );\n\t\tvar bo = this.bowlerObjects[ bowler ];\n\t\tvar sticky = Utils.isInArray( this.stickies, bowler );\n\n\t\t// Calculate sizes, colours and focus\n\t\tvar width = 2;\n\t\tvar marker = 3;\n\t\tvar wicketStroke = '#000';\n\t\tvar front = false;\n\n\t\tif ( this.selected !== -1 )\n\t\t{\n\t\t\tif ( this.selected === bowler || sticky )\n\t\t\t{\n\t\t\t\twidth = 3;\n\t\t\t\tmarker = 4;\n\t\t\t\tfront = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\twidth = 1;\n\t\t\t\twicketStroke = '#444';\n\t\t\t}\n\t\t}\n\n\t\t// Update line rendering\n\t\tbo.line.animate( { stroke:color, 'stroke-width':width, opacity:1 },\n\t\t\t\t\t\t PULSE.RaphaelBowlSpeedsRenderer.ANIM_PERIOD );\n\n\t\t// Update wicket rendering\n\t\tif ( bo.wickets.length > 0 )\n\t\t{\n\t\t\tbo.wickets.animate( { stroke:wicketStroke, fill:color, r:marker },\n\t\t\t\t\t\t\t\tPULSE.RaphaelBowlSpeedsRenderer.ANIM_PERIOD );\n\t\t}\n\n\t\t// Bring to front if we need to\n\t\tif ( front )\n\t\t{\n\t\t\tbo.line.toFront();\n\t\t\tbo.wickets.toFront();\n\t\t}\n\n\t\t// Update label rendering\n\t\tvar color2 = this.getColor( '#fff', bowler, this.selected, this.stickies, '#bbb' );\n\t\tbo.name.animate( { fill:color }, PULSE.RaphaelBowlSpeedsRenderer.ANIM_PERIOD );\n\t\tbo.speeds.animate( { fill:color2 }, PULSE.RaphaelBowlSpeedsRenderer.ANIM_PERIOD );\n\n\t\t// Update sticky rendering\n\t\tbo.bg.animate( { opacity: sticky ? 0.1 : 0 }, PULSE.RaphaelBowlSpeedsRenderer.ANIM_PERIOD );\n\t}\n}"},"onMouse":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"event"}]},"Source":"PULSE.RaphaelBowlSpeedsRenderer.prototype.onMouse = function ( event )\n{\n\t// Get XY and then infer bowler selection index\n\tvar xy = Utils.getXY( event );\n\tvar selection = -1;\n\n\tif ( xy !== undefined && xy.x > 490 &&\n\t\t\t( !this.config.keyMarginR || xy.x < this.config.width - this.config.keyMarginR ) )\n\t{\n\t\tselection = Math.round( ( xy.y - 27 ) / 42 );\n\t\tif ( selection >= this.bowlerCount )\n\t\t{\n\t\t\tselection = -1;\n\t\t}\n\t}\n\n\tvar update = false;\n\tif ( 'mousemove' === event.type )\n\t{\n\t\tif ( this.selected !== selection )\n\t\t{\n\t\t\tthis.selected = selection;\n\t\t\tupdate = true;\n\t\t}\n\t}\n\telse if ( 'mousedown' === event.type )\n\t{\n\t\tthis.stickies = Utils.toggleExistence( this.stickies, selection );\n\t\tupdate = true;\n\t}\n\n\tif ( update )\n\t{\n\t\tthis.updateToSelection();\n\t}\n}"},"getColor":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"color"},{"title":"param","description":null,"type":null,"name":"index"},{"title":"param","description":null,"type":null,"name":"selection"},{"title":"param","description":null,"type":null,"name":"others"},{"title":"param","description":null,"type":null,"name":"alt"}]},"Source":"PULSE.RaphaelBowlSpeedsRenderer.prototype.getColor = function ( color, index, selection, others, alt )\n{\n\tif ( selection === -1 || selection === index || Utils.isInArray( others, index ) )\n\t{\n\t\treturn color;\n\t}\n\telse if ( alt !== undefined )\n\t{\n\t\treturn alt;\n\t}\n\telse\n\t{\n\t\treturn '#888';\n\t}\n}"},"renderSeries":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"container"},{"title":"param","description":null,"type":null,"name":"boxWhisker"},{"title":"param","description":null,"type":null,"name":"r"},{"title":"param","description":null,"type":null,"name":"bowler"},{"title":"param","description":null,"type":null,"name":"speeds"},{"title":"param","description":null,"type":null,"name":"falls"},{"title":"param","description":null,"type":null,"name":"color"},{"title":"param","description":null,"type":null,"name":"index"}]},"Source":"PULSE.RaphaelBowlSpeedsRenderer.prototype.renderSeries =\n\tfunction ( container, boxWhisker, r, bowler, speeds, falls, color, index )\n{\n\tif ( boxWhisker )\n\t{\n\t\tthis.renderSeriesBW( container, r, bowler, speeds, falls, color, index );\n\t}\n\telse\n\t{\n\t\tthis.renderSeriesLine( container, r, bowler, speeds, falls, color, index );\n\t}\n}"},"renderSeriesLine":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"container"},{"title":"param","description":null,"type":null,"name":"r"},{"title":"param","description":null,"type":null,"name":"bowler"},{"title":"param","description":null,"type":null,"name":"speeds"},{"title":"param","description":null,"type":null,"name":"falls"},{"title":"param","description":null,"type":null,"name":"color"},{"title":"param","description":null,"type":null,"name":"index"}]},"Source":"PULSE.RaphaelBowlSpeedsRenderer.prototype.renderSeriesLine =\n\tfunction ( container, r, bowler, speeds, falls, color, index )\n{\n\tvar path = 'M';\n\tfor ( var i = 0, j = speeds.length; i < j; i++ )\n\t{\n\t\tif ( i > 0 )\n\t\t{\n\t\t\tpath += 'L';\n\t\t}\n\n\t\tvar x = this.config.xAxis.project( i + 1 );\n\t\tvar y = this.config.yAxis.project( speeds[i] );\n\n\t\tpath += x + ' ' + y;\n\t}\n\tcontainer.line = r.path( path ).attr( { fill:'none', opacity:0 } );\n\tcontainer.wickets = r.set();\n\n\tif ( falls !== undefined )\n\t{\n\t\tfor ( var i = 0, j = falls.length; i < j; i++ )\n\t\t{\n\t\t\tvar point = falls[i];\n\t\t\tvar x = this.config.xAxis.project( point.x );\n\t\t\tvar y = this.config.yAxis.project( point.y );\n\n\t\t\tcontainer.wickets.push( r.circle( x, y, 0 ) );\n\t\t}\n\t}\n}"},"renderSeriesBW":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"ctx"},{"title":"param","description":null,"type":null,"name":"bowler"},{"title":"param","description":null,"type":null,"name":"speeds"},{"title":"param","description":null,"type":null,"name":"falls"},{"title":"param","description":null,"type":null,"name":"color"},{"title":"param","description":null,"type":null,"name":"index"}]},"Source":"PULSE.RaphaelBowlSpeedsRenderer.prototype.renderSeriesBW = function ( ctx, bowler, speeds, falls, color, index )\n{\n\tvar fns = Utils.getFiveNumberSummary( speeds );\n\tvar hw = 10;\n\n\tvar values = [ fns.min, fns.lq, fns.median, fns.uq, fns.max ];\n\tvar projected = [];\n\tfor ( var i = 0, ilimit = values.length; i < ilimit; i++ )\n\t{\n\t\tprojected.push( this.config.yAxis.project( values[i] ) );\n\t}\n\n\tvar x = this.config.xAxis.project( ( index + 1 ) * 10 );\n\n\tctx.beginPath();\n\tctx.moveTo( x - hw, projected[0] );\n\tctx.lineTo( x + hw, projected[0] );\n\tctx.moveTo( x - hw, projected[4] );\n\tctx.lineTo( x + hw, projected[4] );\n\tctx.moveTo( x, projected[0] );\n\tctx.lineTo( x, projected[4] );\n\tctx.stroke();\n\n\tctx.rect( x - hw, projected[3], hw * 2, projected[1] - projected[3] );\n\tctx.fillStyle = 'blue';\n\tctx.fill();\n\n\tctx.moveTo( x - hw, projected[2] );\n\tctx.lineTo( x + hw, projected[2] );\n\tctx.stroke();\n}"}}},"RaphaelPartnershipsRenderer":{"Documentation":{"description":"************","tags":[]},"Source":"PULSE.RaphaelPartnershipsRenderer = function ( config )\n{\n\tthis.config = config;\n}","prototype":{"render":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"db"},{"title":"param","description":null,"type":null,"name":"data"},{"title":"param","description":null,"type":null,"name":"ctx"}]},"Source":"PULSE.RaphaelPartnershipsRenderer.prototype.render = function ( db, data, ctx )\n{\n\tctx.r.clear();\n\n\tthis.controller.setBackground( this.config.background );\n\n\tvar stats = { b1name:null, b2name:null, b1runs:0, b2runs:0, pruns:0 };\n\tvar first = true;\n\tvar y = 0;\n\n\tfor ( var i = 0, j = data.length; i < j; i++ )\n\t{\n\t\tvar row = data[i];\n\n\t\tvar facing = db.lookupPlayer( row.get( CricketField.BATSMAN ) );\n\t\tvar nonfacing = db.lookupPlayer( row.get( CricketField.NF_BATSMAN ) );\n\n\t\tif ( Utils.isNullish( facing ) || Utils.isNullish( nonfacing ) )\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n        if ( ( facing !== stats.b1name && facing !== stats.b2name ) ||\n        \t ( nonfacing !== stats.b1name && nonfacing !== stats.b2name ) )\n        {\n         \tif ( first )\n         \t{\n         \t\tfirst = false;\n         \t}\n         \telse\n         \t{\n         \t\tthis.renderPartnership( ctx.r, stats, y++ );\n         \t}\n\n        \tif ( nonfacing === stats.b1name )\n        \t{\n        \t    stats.b1name = nonfacing;\n        \t    stats.b2name = facing;\n        \t}\n        \telse\n        \t{\n        \t\tstats.b1name = facing;\n        \t\tstats.b2name = nonfacing;\n        \t}\n\n        \tstats.b1runs = 0;\n        \tstats.b2runs = 0;\n        \tstats.pruns = 0;\n        }\n\n        var credit = +row.get( CricketField.CREDIT );\n        if ( stats.b1name === facing )\n        {\n            stats.b1runs += credit;\n        }\n        else\n        {\n        \tstats.b2runs += credit;\n        }\n\n        stats.pruns += ( +row.get( CricketField.RUNS ) );\n    }\n\n\tthis.renderPartnership( ctx.r, stats, y++ );\n}"},"renderPartnership":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"r"},{"title":"param","description":null,"type":null,"name":"stats"},{"title":"param","description":null,"type":null,"name":"pship"}]},"Source":"PULSE.RaphaelPartnershipsRenderer.prototype.renderPartnership = function ( r, stats, pship )\n{\n\tif ( pship < 10 )\n\t{\n\t\tvar y = this.config.ystart + ( pship * this.config.yspacing );\n\t\tvar x = this.config.width / 2;\n\n\t\t// Draw bars\n\t\tvar gradient = '270-' + this.config.bars.colorStops[0] + '-' + this.config.bars.colorStops[1];\n\t\tvar gradientSet = r.set();\n\n\t\tvar yshift = 0;\n\t\tif ( this.config.bars.yshift )\n\t\t{\n\t\t\tyshift = this.config.bars.yshift;\n\t\t}\n\n\t\tvar bl;\n\t\tif ( stats.b1runs > 0 )\n\t\t{\n\t\t\tbl = this.barLength( stats.b1runs );\n\n\t\t\tgradientSet.push( r.circle( x-this.config.tabs[1]-bl, y + yshift, this.config.bars.width / 2 ) );\n\t\t\tgradientSet.push( r.rect( x-this.config.tabs[1] - bl, y + yshift - (this.config.bars.width/2),\n\t\t\t\t\t\t\t  bl, this.config.bars.width ) );\n\t\t}\n\n\t\tif ( stats.b2runs > 0 )\n\t\t{\n\t\t\tbl = this.barLength( stats.b2runs );\n\n\t\t\tgradientSet.push( r.circle( x+this.config.tabs[1]+bl, y + yshift, this.config.bars.width / 2 ) );\n\t\t\tgradientSet.push( r.rect( x+this.config.tabs[1], y + yshift - (this.config.bars.width/2),\n\t\t\t\t\t\t\t  bl, this.config.bars.width ) );\n\t\t}\n\n\t\tgradientSet.attr( { fill:gradient, stroke:'none' } );\n\n\t\t// Draw text labels\n\t\tattr = this.config.otherText.font;\n\t\tattr.fill = this.config.otherText.style;\n\t\tattr.stroke = 'none';\n\t\tattr['text-anchor'] = 'start';\n\n\t\tr.text( x+this.config.tabs[0], PULSE.Browser.y( y ), stats.b2runs ).attr( attr );\n\t\tr.text( x+this.config.tabs[2], PULSE.Browser.y( y ), stats.b2name ).attr( attr );\n\n\t\tattr['text-anchor'] = 'end'\n\n\t\tr.text( x-this.config.tabs[0], PULSE.Browser.y( y ), stats.b1runs ).attr( attr );\n\t\tr.text( x-this.config.tabs[2], PULSE.Browser.y( y ), stats.b1name ).attr( attr );\n\n\t\tattr = this.config.pshipText.font;\n\t\tattr.fill = this.config.pshipText.style;\n\t\tattr['text-anchor'] = 'middle'\n\t\tr.text( x, PULSE.Browser.y( y ), stats.pruns ).attr( attr );\n\t}\n}"},"barLength":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"runs"}]},"Source":"PULSE.RaphaelPartnershipsRenderer.prototype.barLength = function ( runs )\n{\n\treturn Math.min( runs + this.config.bars.minLength, this.config.bars.maxLength );\n}"}}},"RaphaelRunsPerOverRenderer":{"Documentation":{"description":"*************","tags":[]},"Source":"PULSE.RaphaelRunsPerOverRenderer = function ( config )\n{\n\tthis.config = config;\n}","prototype":{"render":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"db"},{"title":"param","description":null,"type":null,"name":"data"},{"title":"param","description":null,"type":null,"name":"ctx"}]},"Source":"PULSE.RaphaelRunsPerOverRenderer.prototype.render = function ( db, data, ctx )\n{\n\tthis.db = db;\n\tthis.variant = obtainVariant( this.config, this.db );\n\tthis.data = this.prepareData( data );\n\tthis.r = ctx.r;\n\n\tthis.tooltipData = undefined;\n\tthis.draw();\n}"},"prepareData":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"data"}]},"Source":"PULSE.RaphaelRunsPerOverRenderer.prototype.prepareData = function ( data )\n{\n\tthis.tooltipDataCache = {};\n\n\tvar overStats = [];\n\n\tvar lastOver = 0;\n\tvar stats = { r:0, w:0, dismissed:[] };\n\tfor ( var i = 0, j = data.length; i < j; i++ )\n\t{\n\t\tvar row = data[i];\n\n\t\tvar over = +row.get( CricketField.OVER );\n\t\tif ( over !== lastOver )\n\t\t{\n\t\t\t// New over\n\t\t\t// If this isn't the first over, render the previous one\n\t\t\tif ( over !== 1 )\n\t\t\t{\n\t\t\t\toverStats.push( this.prepareRecord( lastOver, stats ) );\n\t\t\t}\n\n\t\t\tlastOver = over;\n\n\t\t\t// Reset stats\n\t\t\tstats.r = 0;\n\t\t\tstats.w = 0;\n\t\t\tstats.dismissed = [];\n\t\t}\n\n\t\tstats.r += ( +row.get( CricketField.RUNS ) );\n\t\tif ( row.get( CricketField.IS_WICKET ) )\n\t\t{\n\t\t\tstats.w++;\n\t\t\tstats.dismissed.push( row.get( CricketField.DISMISSED ) );\n\t\t}\n\t}\n\n\toverStats.push( this.prepareRecord( lastOver, stats ) );\n\treturn overStats;\n}"},"prepareRecord":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"over"},{"title":"param","description":null,"type":null,"name":"stats"}]},"Source":"PULSE.RaphaelRunsPerOverRenderer.prototype.prepareRecord = function ( over, stats )\n{\n\tvar x = this.variant.xAxis.project( over );\n\tvar y = this.variant.yAxis.project( stats.r );\n\n\t// Add to tooltip cache\n\tvar ix = Math.round( x );\n\tvar iy = Math.round( y );\n\tthis.tooltipDataCache[ ix ] = { x:ix, y:iy, dismissed:stats.dismissed };\n\n\treturn { x:x, y:y, w:stats.w };\n}"},"draw":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.RaphaelRunsPerOverRenderer.prototype.draw = function ()\n{\n\tthis.r.clear();\n\n\t// Draw axes\n\tthis.variant.xAxis.font = this.config.font;\n\tthis.variant.yAxis.font = this.config.font;\n\tthis.variant.xAxis.drawTo( this.r, true );\n\tthis.variant.yAxis.drawTo( this.r, false );\n\n\t// Iterate over bars\n\tvar y0 = this.variant.yAxis.project( 0 ) - 1;\n\tvar ymax = this.variant.yAxis.project( this.variant.yAxis.max );\n\n\tfor ( var i = 0, ilimit = this.data.length; i < ilimit; i++ )\n\t{\n\t\tvar record = this.data[i];\n\n\t\t// Calculate fraction of total y axis height\n\t\tvar fraction = ( record.y - y0 ) / ( ymax - y0 );\n\t\tif ( fraction > 1 )\n\t\t{\n\t\t\tfraction = 1;\n\t\t}\n\n\t\tvar color = Utils.intermediateColor( this.variant.bars.colorStops[0],\n\t\t\t\t\t\t\t\t\t\t\t this.variant.bars.colorStops[1], fraction );\n\t\tvar fill = '90-' + this.variant.bars.colorStops[0] + '-' + color;\n\n\t\tif ( y0 - record.y > 0 )\n\t\t{\n\t\t\tthis.r.rect( record.x - ( this.variant.bars.width / 2 ), record.y,\n\t\t\t\t\t     this.variant.bars.width, y0 - record.y )\n\t\t\t\t  .attr( { fill:fill, stroke:'none' } );\n\t\t}\n\n\t\tfor ( var j = 0, jlimit = record.w; j < jlimit; j++ )\n\t\t{\n\t\t\tthis.r.circle( record.x, record.y - ( j * this.variant.bars.fowsize ), this.variant.bars.fowsize / 2 )\n\t\t\t      .attr( { stroke:this.config.fow.stroke, fill:this.config.fow.fill, 'stroke-width':1 } );\n\t\t}\n\t}\n\t//render background\n\tthis.controller.setBackground( this.config.background );\n}"},"updateTooltip":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.RaphaelRunsPerOverRenderer.prototype.updateTooltip = function ()\n{\n\tif ( this.tooltipData )\n\t{\n\t\t// Remove any current tooltip set\n\t\tif ( this.ttSet )\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tthis.ttSet.remove();\n\t\t\t}\n\t\t\tcatch ( exception )\n\t\t\t{\n\t\t\t\t// Potentially tries to remove an object already cleared\n\t\t\t}\n\t\t}\n\n\t\tvar cfg = this.config.tooltip;\n\t\tvar anchorv = 'n';\n\t\tvar anchorh = 'w';\n\n\t\tif ( this.tooltipData.x > this.config.width / 2 )\n\t\t{\n\t\t\tanchorh = 'e';\n\t\t}\n\t\tif ( this.tooltipData.y > this.config.height / 2 )\n\t\t{\n\t\t\tanchorv = 's';\n\t\t}\n\n\t\tcfg.position = { x:this.tooltipData.x, y:this.tooltipData.y, anchor:anchorv + anchorh };\n\n\t\t// Create a new set and build Raphael object stack for a text field in it\n\t\tthis.ttSet = this.r.set();\n\t\tvar tf = new PULSE.RaphaelTextField( cfg );\n\t\ttf.setLines( this.tooltipData.dismissed );\n\t\ttf.render( this.r, this.ttSet );\n\t}\n\telse\n\t{\n\t\tthis.ttSet.animate( { opacity:0 }, 1000 );\n\t}\n}"},"onMouse":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"event"}]},"Source":"PULSE.RaphaelRunsPerOverRenderer.prototype.onMouse = function ( event )\n{\n\t// Get XY and then infer over bar\n\tvar xy = Utils.getXY( event );\n\tvar tt = this.findNearbyTooltip( xy );\n\n\tif ( tt !== this.tooltipData )\n\t{\n\t\tthis.tooltipData = tt;\n\t\tthis.updateTooltip();\n\t}\n}"},"findNearbyTooltip":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"xy"}]},"Source":"PULSE.RaphaelRunsPerOverRenderer.prototype.findNearbyTooltip = function ( xy )\n{\n\tif ( xy )\n\t{\n\t\tfor ( var x = xy.x - ( this.variant.bars.width / 2 );\n\t\t          x <= xy.x + ( this.variant.bars.width / 2 ); x++ )\n\t\t{\n\t\t\tvar tt = this.tooltipDataCache[ x ];\n\t\t\tif ( tt && tt.dismissed.length > 0 )\n\t\t\t{\n\t\t\t\treturn tt;\n\t\t\t}\n\t\t}\n\t}\n}"}}},"RaphaelRunRateRenderer":{"Documentation":{"description":"********","tags":[]},"Source":"PULSE.RaphaelRunRateRenderer = function ( config )\n{\n\tthis.config = config;\n}","prototype":{"render":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"db"},{"title":"param","description":null,"type":null,"name":"data"},{"title":"param","description":null,"type":null,"name":"ctx"}]},"Source":"PULSE.RaphaelRunRateRenderer.prototype.render = function ( db, data, ctx )\n{\n\tthis.db = db;\n\tthis.variant = obtainVariant( this.config, this.db );\n\tthis.data = this.prepareData( data );\n\tthis.ctx = ctx;\n\n\tctx.r.clear();\n\tthis.tooltipData = undefined;\n\tthis.tooltipLines = [ ctx.r.path(), ctx.r.path(), ctx.r.path(), ctx.r.path() ];\n\n\tthis.draw();\n}"},"prepareData":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"data"}]},"Source":"PULSE.RaphaelRunRateRenderer.prototype.prepareData = function ( data )\n{\n\tthis.tooltipDataCache = {};\n\n\tvar inningsSeries = {};\n\n\tif ( data.length > 0 )\n\t{\n\t\t// Place data into innings buckets (for performance reasons, we should look at combining\n\t\t// this bucketisation with the actual data series creation below)\n\t\tvar inningsData = {};\n\t\tfor ( var i = 0, ilimit = data.length; i < ilimit; i++ )\n\t\t{\n\t\t\tvar row = data[i];\n\t\t\tvar innings = +row.get( CricketField.INNINGS );\n\n\t\t\t// Obtain or create bucket\n\t\t\tvar inningsDataItem = inningsData[ innings ];\n\t\t\tif ( inningsDataItem === undefined )\n\t\t\t{\n\t\t\t\tinningsDataItem = [];\n\t\t\t\tinningsData[ innings ] = inningsDataItem;\n\t\t\t}\n\n\t\t\t// Add item to bucket\n\t\t\tinningsDataItem.push( row );\n\t\t}\n\n\t\t// Keep track of maximum number of overs (for Test cricket)\n\t\tvar maxOvers = 0;\n\n\t\t// Get the participants\n\t\tvar participants = this.db.getParticipants();\n\n\n\t\t// determine the max\n\t\tfor ( var innings = 1; innings <= 4; innings++ )\n\t\t{\n\t\t\tvar inningsRecords = inningsData[ innings ];\n\t\t\tif ( inningsRecords === undefined || inningsRecords.length === 0 )\n\t\t\t{\n\t\t\t\t// Break out\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tvar lastOver = 0;\n\n\t\t\tfor ( var i = 0, j = inningsRecords.length; i < j; i++ )\n\t\t\t{\n\t\t\t\tvar row = inningsRecords[ i ];\n\t\t\t\tvar over = +row.get( CricketField.OVER );\n\n\t\t\t\tif ( over !== lastOver )\n\t\t\t\t{\n\t\t\t\t\tlastOver = over;\n\t\t\t\t}\n\n\t\t\t\t// Update max overs\n\t\t\t\tif ( over > maxOvers )\n\t\t\t\t{\n\t\t\t\t\tmaxOvers = over;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Scale the xAxis if need be\n\t\tthis.variant.xAxis.max = this.variant.xAxis.configuredMax;\n\t\tif ( maxOvers > this.variant.xAxis.max )\n\t\t{\n\t\t\tthis.variant.xAxis.max = maxOvers;\n\t\t}\n\n\t\t// END - determine the max\n\n\t\t// Now iterate over all all balls in each innings bucket\n\t\tfor ( var innings = 1; innings <= 4; innings++ )\n\t\t{\n\t\t\t// Get the participant name\n\t\t\tvar pIndex = this.db.getBattingTeamIndex( innings );\n\t\t\tvar pName = participants[ pIndex ].abbreviation;\n\n\t\t\tinningsSeries[ innings ] = [];\n\n\t\t\tvar inningsRecords = inningsData[ innings ];\n\t\t\tif ( inningsRecords === undefined || inningsRecords.length === 0 )\n\t\t\t{\n\t\t\t\t// Break out\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tvar stats = { runs:0, wickets:0, over:0 };\n\t\t\tvar lastOver = 0;\n\n\t\t\tfor ( var i = 0, j = inningsRecords.length; i < j; i++ )\n\t\t\t{\n\t\t\t\tvar row = inningsRecords[ i ];\n\t\t\t\tvar over = +row.get( CricketField.OVER );\n\n\t\t\t\tif ( over !== lastOver )\n\t\t\t\t{\n\t\t\t\t\t// New over\n\t\t\t\t\t// If this isn't the first over, add the previous one\n\t\t\t\t\tif ( over !== 1 )\n\t\t\t\t\t{\n\t\t\t\t\t\tinningsSeries[ innings ].push( this.prepareRecord( stats, pName ) );\n\t\t\t\t\t}\n\n\t\t\t\t\tlastOver = over;\n\n\t\t\t\t\t// Reset stats\n\t\t\t\t\tstats.wickets = 0;\n\t\t\t\t\tstats.over = over;\n\t\t\t\t}\n\n\t\t\t\tstats.runs += ( +row.get( CricketField.RUNS ) );\n\t\t\t\tif ( row.get( CricketField.IS_WICKET ) )\n\t\t\t\t{\n\t\t\t\t\tstats.wickets++;\n\t\t\t\t}\n\n\t\t\t\t// Update max overs\n\t\t\t\tif ( over > maxOvers )\n\t\t\t\t{\n\t\t\t\t\tmaxOvers = over;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add final stats\n\t\t\tinningsSeries[ innings ].push( this.prepareRecord( stats, pName ) );\n\t\t}\n\n\t\t// Scale the xAxis if need be\n\t\tthis.variant.xAxis.max = this.variant.xAxis.configuredMax;\n\t\tif ( maxOvers > this.variant.xAxis.max )\n\t\t{\n\t\t\tthis.variant.xAxis.max = maxOvers;\n\t\t}\n\t}\n\n\treturn inningsSeries;\n}"},"prepareRecord":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"stats"},{"title":"param","description":null,"type":null,"name":"participant"}]},"Source":"PULSE.RaphaelRunRateRenderer.prototype.prepareRecord = function ( stats, participant )\n{\n\tvar yvalue = this.getYValue( stats );\n\tvar x = this.variant.xAxis.project( stats.over );\n\tvar y = this.variant.yAxis.project( yvalue );\n\n\t// Add to tooltip cache\n\tvar ix = Math.round( x );\n\tvar iy = Math.round( y );\n\tvar xcache = this.tooltipDataCache[ ix ];\n\tif ( !xcache )\n\t{\n\t\txcache = { x:ix, xvalue:stats.over };\n\t\tthis.tooltipDataCache[ ix ] = xcache;\n\t}\n\txcache[ iy ] = { y:iy, yvalue:yvalue, participant:participant };\n\n\treturn { x:x, y:y, w:stats.wickets };\n}"},"draw":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.RaphaelRunRateRenderer.prototype.draw = function ()\n{\n\tthis.variant.xAxis.font = this.config.font;\n\tthis.variant.yAxis.font = this.config.font;\n\n\tthis.variant.xAxis.drawTo( this.ctx.r, true );\n\tthis.variant.yAxis.drawTo( this.ctx.r, false );\n\n\t// Now render each series\n\tvar flexikey = new PULSE.RaphaelFlexikey( this.config.flexikey );\n\tvar participants = this.db.getParticipants();\n\n\tvar gt = this.db.getMatchType();\n\tvar suffix = '';\n\n\tfor ( var i = 1; i <= 4; i++ )\n\t{\n\t\tvar thisInningsSeries = this.data[ i ];\n\n\t\tif ( thisInningsSeries === undefined || thisInningsSeries.length < 1 )\n\t\t{\n\t\t\t// Early exit\n\t\t\tbreak;\n\t\t}\n\n\t\tvar pIndex = this.db.getBattingTeamIndex( i );\n\t\tvar color;\n\t\tif ( i <= 2 )\n\t\t{\n\t\t\tcolor = participants[ pIndex ].primaryColor;\n\t\t\tsuffix = ' 1st inns';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcolor = participants[ pIndex ].secondaryColor;\n\t\t\tsuffix = ' 2nd inns';\n\t\t}\n\n\t\tthis.renderSeries( this.ctx.r, thisInningsSeries, color );\n\n\t\tvar label = participants[ pIndex ].fullName;\n\t\tif ( CricketMatchType.TEST === gt )\n\t\t{\n\t\t\tlabel += suffix;\n\t\t}\n\n\t\tflexikey.addEntry( label, color );\n\t}\n\t//render background\n\tthis.controller.setBackground( this.config.background );\n\n\t// Finally render the Flexikey\n\tflexikey.render( this.ctx.r );\n}"},"renderSeries":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"r"},{"title":"param","description":null,"type":null,"name":"series"},{"title":"param","description":null,"type":null,"name":"color"}]},"Source":"PULSE.RaphaelRunRateRenderer.prototype.renderSeries = function ( r, series, color )\n{\n\t// Create the line\n\tvar path = '';\n\tfor ( var i = 0, ilimit = series.length; i < ilimit; i++ )\n\t{\n\t\tvar item = series[i];\n\t\tif ( i === 0 )\n\t\t{\n\t\t\tpath += 'M';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpath += 'L';\n\t\t}\n\t\tpath += item.x + ' ' + item.y;\n\t}\n\tr.path( path ).attr( { 'stroke-width':3, stroke:color, fill:'none' } );\n\n\t// Create the wicket falls\n\tfor ( var i = 0, ilimit = series.length; i < ilimit; i++ )\n\t{\n\t\tvar item = series[i];\n\t\tif ( item.w > 0 )\n\t\t{\n\t\t\tfor ( var k = 0, l = item.w; k < l; k++ )\n\t\t\t{\n\t\t\t\tr.circle( item.x, item.y - ( k * this.config.fow.size ), this.config.fow.size / 2 )\n\t\t\t\t .attr( { 'stroke-width':1, stroke:this.config.fow.stroke, fill:color } );\n\t\t\t}\n\t\t}\n\t}\n}"},"onMouse":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"event"}]},"Source":"PULSE.RaphaelRunRateRenderer.prototype.onMouse = function ( event )\n{\n\t// Get XY and then infer over bar\n\tvar xy = Utils.getXY( event );\n\tvar tooltipData = this.findNearbyTooltip( xy );\n\n\tif ( this.tooltipData !== tooltipData )\n\t{\n\t\tthis.tooltipData = tooltipData;\n\t\tthis.updateTooltip();\n\t}\n}"},"updateTooltip":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.RaphaelRunRateRenderer.prototype.updateTooltip = function ()\n{\n\t// Remove any current tooltip set\n\tif ( this.ttSet )\n\t{\n\t\ttry\n\t\t{\n\t\t\tthis.ttSet.remove();\n\t\t}\n\t\tcatch ( exception )\n\t\t{\n\t\t\t// Potentially tries to remove an object already cleared\n\t\t}\n\t}\n\n\tvar idx = 0;\n\tif ( this.tooltipData )\n\t{\n\t\tif ( this.config.textField )\n\t\t{\n\t\t\tthis.ttSet = this.ctx.r.set();\n\t\t\tthis.tf = new PULSE.RaphaelTextField( this.config.textField );\n\t\t\tthis.tf.addLine( '<c:#bbb>Over </c>' + this.tooltipData.xvalue );\n\t\t}\n\n\t\tvar line = '';\n\t\tfor ( var ttditem in this.tooltipData )\n\t\t{\n\t\t\tif ( ttditem !== 'x' && ttditem !== 'xvalue' )\n\t\t\t{\n\t\t\t\tvar t = this.tooltipData[ttditem];\n\n\t\t\t\tvar path = 'M' + this.variant.xAxis.start + ' ' + t.y +\n\t\t\t\t           'L' + this.tooltipData.x + ' ' + t.y +\n\t\t\t\t           'L' + this.tooltipData.x + ' ' + this.variant.yAxis.start;\n\n\t\t\t\tthis.tooltipLines[idx].attr( { stroke:'#fff', opacity:0.6, path:path,\n\t\t\t\t\t                           'stroke-width':2 } );\n\n\t\t\t\tline += '<c:#bbb>' + t.participant + ' </c>' + this.format( t.yvalue ) + ', ';\n\t\t\t\tidx++;\n\t\t\t}\n\t\t}\n\n\t\tif ( this.tf )\n\t\t{\n\t\t\tif ( line.length > 2 )\n\t\t\t{\n\t\t\t\tline = line.substr( 0, line.length - 2 );\n\t\t\t}\n\t\t\tthis.tf.addLine( line );\n\t\t\tthis.tf.render( this.ctx.r, this.ttSet );\n\t\t}\n\t}\n\n\t// Clear out unused lines\n\tfor ( var idx2 = idx; idx2 < this.tooltipLines.length; idx2++ )\n\t{\n\t\tthis.tooltipLines[idx2].attr( { path:'M0 0 L0 0' } );\n\t}\n}"},"findNearbyTooltip":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"xy"}]},"Source":"PULSE.RaphaelRunRateRenderer.prototype.findNearbyTooltip = function ( xy )\n{\n\tif ( xy )\n\t{\n\t\tif ( xy.x <= this.variant.xAxis.end && xy.x >= this.variant.xAxis.start &&\n\t\t     xy.y >= this.variant.yAxis.end && xy.y <= this.variant.yAxis.start )\n\t\t{\n\t\t\tvar search = xy.x;\n\n\t\t\twhile ( search >= this.variant.xAxis.start )\n\t\t\t{\n\t\t\t\tif ( this.tooltipDataCache[ search ] )\n\t\t\t\t{\n\t\t\t\t\treturn this.tooltipDataCache[ search ];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// If there was no data for this x value, try using one to the left\n\t\t\t\t\tsearch--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"},"getYValue":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"item"}]},"Source":"PULSE.RaphaelRunRateRenderer.prototype.getYValue = function ( item )\n{\n\treturn item.runs / item.over;\n}"},"format":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"value"}]},"Source":"PULSE.RaphaelRunRateRenderer.prototype.format = function ( value )\n{\n\treturn value.toFixed( 2 ) + ' <c:#bbb>rpo</c>';\n}"}}},"RaphaelWormsRenderer":{"Documentation":{"description":"*****","tags":[]},"Source":"PULSE.RaphaelWormsRenderer = function ( config )\n{\n\tthis.config = config;\n}","prototype":{"format":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"value"}]},"Source":"PULSE.RaphaelWormsRenderer.prototype.format = function ( value )\n{\n\treturn value + ' <c:#bbb>runs</c>';\n}"},"getYValue":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"item"}]},"Source":"PULSE.RaphaelWormsRenderer.prototype.getYValue = function ( item )\n{\n\treturn item.runs;\n}"}}},"RaphaelWinLikelihoodRenderer":{"Documentation":{"description":"**************","tags":[]},"Source":"PULSE.RaphaelWinLikelihoodRenderer = function ( config )\n{\n\tthis.config = config;\n\tthis.font = Utils.cloneObject( config.font );\n}","prototype":{"render":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"db"},{"title":"param","description":null,"type":null,"name":"data"},{"title":"param","description":null,"type":null,"name":"ctx"}]},"Source":"PULSE.RaphaelWinLikelihoodRenderer.prototype.render = function ( db, data, ctx )\n{\n\tthis.db = db;\n\tthis.data = data;\n\tthis.ctx = ctx;\n\n\tthis.ctx.r.clear();\n\n\tthis.tooltipData = undefined;\n\tthis.dismissalData = undefined;\n\tthis.tooltipDataCache = {};\n\tthis.draw();\n}"},"draw":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.RaphaelWinLikelihoodRenderer.prototype.draw = function ()\n{\n\tvar currentInnings = 0;\n\tvar currentOver = 0;\n\tvar dismissals = [];\n\tvar x = 1;\n\tvar battingIndex = 0;\n\tvar series = [ [], [], [] ];\n\n\tvar likelihoods;\n\tvar lastLikelihoods;\n\tfor ( var i = 0, j = this.data.length; i < j; i++ )\n\t{\n\t\tvar row = this.data[ i ];\n\n\t\tlikelihoods = row.get( CricketField.WIN_LIKELIHOODS );\n\t\tif ( likelihoods === undefined )\n\t\t{\n\t\t\t// No likelihoods for this record, so simply copy the last one\n\t\t\tlikelihoods = lastLikelihoods;\n\t\t}\n\n\t\tif ( likelihoods === undefined )\n\t\t{\n\t\t\t// No likelihoods yet, so break\n\t\t\tcontinue;\n\t\t}\n\n\t\tvar over = row.get( CricketField.OVER );\n\t\tif ( over !== currentOver )\n\t\t{\n\t\t\tif ( currentOver != 0 )\t// Allow coercion\n\t\t\t{\n\t\t\t\tthis.addData( series, x, likelihoods, battingIndex, dismissals );\n\t\t\t}\n\n\t\t\tdismissals = [];\n\t\t\tcurrentOver = over;\n\t\t\tx++;\n\t\t}\n\n\t\tvar innings = row.get( CricketField.INNINGS );\n\t\tif ( innings !== currentInnings )\n\t\t{\n\t\t\tcurrentInnings = innings;\n\t\t\tbattingIndex = this.db.getBattingTeamIndex( innings );\n\t\t}\n\n\t\tif ( row.get( CricketField.IS_WICKET ) )\n\t\t{\n\t\t\tdismissals.push( row.get( CricketField.DISMISSED ) );\n\t\t}\n\n\t\tlastLikelihoods = likelihoods;\n\t}\n\n\tif ( likelihoods !== undefined )\n\t{\n\t\tthis.addData( series, x, likelihoods, battingIndex, dismissals );\n\t}\n\n\t// Scale the x-axis if necessary\n\tthis.config.xAxis.max = this.config.xAxis.configuredMax;\n\tif ( x > this.config.xAxis.max )\n\t{\n\t\tthis.config.xAxis.max = x;\n\t}\n\n\t// Also scale back the y-axis if there will be 3 items in the key\n\tthis.config.yAxis.end = this.config.yAxis.configuredEnd;\n\tvar testMatch = ( CricketMatchType.TEST === this.db.getMatchType() );\n\tif ( testMatch )\n\t{\n\t\t// Shift y-axis down to allow for larger key\n\t\tthis.config.yAxis.end += 30;\n\t}\n\n\t// Draw the axes\n\tthis.config.xAxis.font = this.font;\n\tthis.config.yAxis.font = this.font;\n\tthis.config.xAxis.drawTo( this.ctx.r, true );\n\tthis.config.yAxis.drawTo( this.ctx.r, false );\n\n\t// Create flexikey\n\tvar flexikey = new PULSE.RaphaelFlexikey( this.config.flexikey );\n\n\t// Render the draw series first, if we need to\n\tif ( testMatch )\n\t{\n\t\tthis.renderSeries( this.ctx.r, series[1], this.config.drawColor, 'Draw' );\n\t}\n\n\t// Now draw the team series\n\tvar participants = this.db.getParticipants();\n\tfor ( var team = 0; team < 2; team++ )\n\t{\n\t\tvar color = participants[ team ].primaryColor;\n\t\tthis.renderSeries( this.ctx.r, series[ 2 * team ], color, participants[ team ].fullName );\n\t\tflexikey.addEntry( participants[ team ].fullName, color );\n\n\t\t// Add the draw item to the key now\n\t\tif ( team === 0 && testMatch )\n\t\t{\n\t\t\tflexikey.addEntry( 'Draw', this.config.drawColor );\n\t\t}\n\t}\n\n\t// Render the Flexikey\n\tflexikey.render( this.ctx.r );\n\n\t// Finally create tooltip objects\n\tvar bgAttr = { fill:this.config.tooltips.background.color, stroke:'none', opacity:0 };\n\n\tvar textAttr = this.config.font;\n\ttextAttr.fill = this.config.tooltips.foreground;\n\ttextAttr.stroke = 'none';\n\ttextAttr.opacity = 0;\n\n\tthis.tooltipObjects = { line          : this.ctx.r.path()\n\t\t\t                                          .attr( { stroke:this.config.tooltips.background.color,\n\t\t\t                                        \t       'stroke-width':2,\n\t\t\t                                        \t       fill:'none',\n\t\t\t                                        \t       opacity:0 } ),\n\t\t\t                bgs          : [ this.ctx.r.rect().attr( bgAttr ),\n\t\t\t                                 this.ctx.r.rect().attr( bgAttr ),\n\t\t\t                                 this.ctx.r.rect().attr( bgAttr ) ],\n\t\t\t                texts        : [ this.ctx.r.text().attr( textAttr ),\n\t\t\t                                 this.ctx.r.text().attr( textAttr ),\n\t\t\t                                 this.ctx.r.text().attr( textAttr ) ] };\n    this.dismissal = this.ctx.r.set();\n}"},"updateTooltip":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.RaphaelWinLikelihoodRenderer.prototype.updateTooltip = function ()\n{\n\t// Finally render the tooltip data\n\tif ( this.tooltipData )\n\t{\n\t\tvar path = 'M' + this.tooltipData.x + ' ' + ( this.config.yAxis.start - 1 ) +\n\t\t           'L' + this.tooltipData.x + ' ' + this.config.yAxis.end;\n\t\tthis.tooltipObjects.line.attr( {\n\t\t\t\tpath:path,\n\t\t\t\topacity:this.config.tooltips.background.opacity } );\n\n\t\tvar idx = 0;\n\t\tfor ( var labelName in this.tooltipData.labels )\n\t\t{\n\t\t\tvar label = this.tooltipData.labels[ labelName ];\n\n\t\t\t// If this label overlaps with another one that has a higher value, then simply\n\t\t\t// skip the rendering of this label\n\t\t\t// 1. Find all other labels within spitting distance of this one\n\t\t\tvar others = [];\n\t\t\tfor ( var labelCheck in this.tooltipData.labels )\n\t\t\t{\n\t\t\t\tif ( labelCheck === labelName )\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tvar other = this.tooltipData.labels[ labelCheck ];\n\t\t\t\tif ( Math.abs( other.y - label.y ) <= this.config.tooltips.height )\n\t\t\t\t{\n\t\t\t\t\tothers.push( other );\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 2. Find out if there is one bigger (i.e. lower y value)\n\t\t\tvar skip = false;\n\t\t\tfor ( var i = 0, j = others.length; i < j && !skip; i++ )\n\t\t\t{\n\t\t\t\tif ( others[i].y < label.y )\n\t\t\t\t{\n\t\t\t\t\tskip = true;\n\t\t\t\t}\n\t\t\t\telse if ( others[i].y === label.y )\n\t\t\t\t{\n\t\t\t\t\t// They are the same, so choose the one alphabetically first\n\t\t\t\t\tskip = others[i].string < label.string;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( !skip )\n\t\t\t{\n\t\t\t\t// Render this team label\n\t\t\t\tvar temp = this.ctx.r.text( -1000, -1000, label.string ).attr( this.config.font );\n\t\t\t\tvar size = temp.getBBox();\n\t\t\t\ttemp.remove();\n\n\t\t\t\tvar width = size.width + this.config.tooltips.border.left + this.config.tooltips.border.right;\n\t\t\t\tvar anchor = 'start';\n\t\t\t\tvar offset = 0;\n\t\t\t\tvar textOff = this.config.tooltips.border.left;\n\n\t\t\t\tif ( this.tooltipData.x + width > this.config.xAxis.end )\n\t\t\t\t{\n\t\t\t\t\toffset = -width;\n\t\t\t\t\tanchor = 'end';\n\t\t\t\t\ttextOff = -this.config.tooltips.border.right;\n\t\t\t\t}\n\n\t\t\t\tthis.tooltipObjects.bgs[idx].attr( { x:this.tooltipData.x + offset,\n\t\t\t\t\t\t\t\t\t\t\t\t\t y:label.y - this.config.tooltips.height / 2,\n\t\t\t\t\t\t\t\t\t\t\t\t\t width:width,\n\t\t\t\t\t\t\t\t\t\t\t\t\t height:this.config.tooltips.height,\n\t\t\t\t\t\t\t\t\t\t\t\t\t opacity:this.config.tooltips.background.opacity } );\n\n\t\t\t\tthis.tooltipObjects.texts[idx].attr( { x:this.tooltipData.x + textOff,\n\t\t\t\t\t \t\t\t\t\t\t\t\t   y:PULSE.Browser.y( label.y ),\n\t\t\t\t\t \t\t\t\t\t\t\t\t   text:label.string,\n\t\t\t\t\t \t\t\t\t\t\t\t\t   'text-anchor':anchor,\n\t\t\t\t\t \t\t\t\t\t\t\t\t   opacity:1 } );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.tooltipObjects.bgs[idx].attr( { opacity:0 } );\n\t\t\t\tthis.tooltipObjects.texts[idx].attr( { opacity:0 } );\n\t\t\t}\n\n\t\t\tidx++;\n\t\t}\n\n\t\t// If there were dismissals associated with this value, or one very close to it,\n\t\t// then display this information in the top-left corner\n\t\tthis.dismissal.remove();\n\t\tif ( this.dismissalData !== undefined )\n\t\t{\n\t\t\tvar d = '';\n\t\t\tfor ( dd = 0, ee = this.dismissalData.length; dd < ee; dd++ )\n\t\t\t{\n\t\t\t\tif ( dd !== 0 )\n\t\t\t\t{\n\t\t\t\t\tif ( dd === ee - 1 )\n\t\t\t\t\t{\n\t\t\t\t\t\td += ' and ';\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\td += ', ';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\td += this.dismissalData[dd];\n\t\t\t}\n\n\t\t\tvar tf = new PULSE.RaphaelTextField( this.config.dismissalTextField );\n\t\t\ttf.addLine( d + ' dismissed' );\n\t\t\ttf.render( this.ctx.r, this.dismissal );\n\t\t}\n\t}\n\telse\n\t{\n\t\t// Reset all components to 0 opacity to hide them\n\t\tfor ( var prop in this.tooltipObjects )\n\t\t{\n\t\t\tif ( this.tooltipObjects[prop].length )\n\t\t\t{\n\t\t\t\tfor ( var i = 0, ilimit = this.tooltipObjects[prop].length; i < ilimit; i++ )\n\t\t\t\t{\n\t\t\t\t\tthis.tooltipObjects[prop][i].attr( { opacity:0 } );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.tooltipObjects[prop].attr( { opacity:0 } );\n\t\t\t}\n\t\t}\n\t}\n}"},"renderSeries":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"r"},{"title":"param","description":null,"type":null,"name":"series"},{"title":"param","description":null,"type":null,"name":"color"},{"title":"param","description":null,"type":null,"name":"label"}]},"Source":"PULSE.RaphaelWinLikelihoodRenderer.prototype.renderSeries = function ( r, series, color, label )\n{\n\t// Create the line\n\tvar path = 'M';\n\tfor ( var i = 0, j = series.length; i < j; i++ )\n\t{\n\t\tif ( i > 0 )\n\t\t{\n\t\t\tpath += 'L';\n\t\t}\n\n\t\tvar item = series[i];\n\t\tvar x = this.config.xAxis.project( item.x );\n\t\tvar y = this.config.yAxis.project( item.y );\n\n\t\tpath += x + ' ' + y;\n\n\t\t// Retrieve or create the tooltip cache\n\t\tvar index = Math.round( x );\n\t\tvar cacheRecord = this.tooltipDataCache[ index ];\n\t\tif ( !cacheRecord )\n\t\t{\n\t\t\tcacheRecord = { x:x, labels:{} };\n\t\t\tthis.tooltipDataCache[ index ] = cacheRecord;\n\t\t}\n\n\t\t// Add a label into the record\n\t\tvar rec = { string:label + ': ' + Math.round( item.y ) + '%', y:y };\n\t\tif ( item.dismissals !== undefined )\n\t\t{\n\t\t\trec.z = item.dismissals.length;\n\t\t\tcacheRecord.dismissals = item.dismissals;\n\t\t}\n\t\tcacheRecord.labels[ label ] = rec;\n\t}\n\tr.path( path ).attr( { stroke:color, fill:'none', 'stroke-width':3 } );\n\n\t// Create the wicket falls\n\tfor ( var i = 0, j = series.length; i < j; i++ )\n\t{\n\t\tvar item = series[i];\n\t\tif ( item.z > 0 )\n\t\t{\n\t\t\tvar x = this.config.xAxis.project( item.x );\n\t\t\tvar y = this.config.yAxis.project( item.y );\n\n\t\t\tfor ( var k = 0, l = item.z; k < l; k++ )\n\t\t\t{\n\t\t\t\tr.circle( x, y - ( k * this.config.fow.size ), this.config.fow.size / 2 )\n\t\t\t\t .attr( { fill:color, stroke:this.config.fow.stroke , 'stroke-width':1 } );\n\t\t\t}\n\t\t}\n\t}\n}"},"addData":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"series"},{"title":"param","description":null,"type":null,"name":"x"},{"title":"param","description":null,"type":null,"name":"likelihoods"},{"title":"param","description":null,"type":null,"name":"battingIndex"},{"title":"param","description":null,"type":null,"name":"dismissals"}]},"Source":"PULSE.RaphaelWinLikelihoodRenderer.prototype.addData = function ( series, x, likelihoods, battingIndex, dismissals )\n{\n\t// Add the 3 values to the 3 series\n\tfor ( var k = 0; k < 3; k++ )\n\t{\n\t\t// Remember to normalise y value to 0-100 from 0-1000\n\t\tvar item = { x:x, y:likelihoods[k]/10, z:0 };\n\t\tif ( dismissals.length > 0 && k === battingIndex * 2 )\n\t\t{\n\t\t\titem.z = dismissals.length;\n\t\t\titem.dismissals = dismissals;\n\t\t}\n\n\t\tseries[k].push( item );\n\t}\n}"},"onMouse":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"event"}]},"Source":"PULSE.RaphaelWinLikelihoodRenderer.prototype.onMouse = function ( event )\n{\n\tvar xy = Utils.getXY( event );\n\tvar ttd = undefined;\n\n\tif ( xy !== undefined && xy.y >= this.config.yAxis.end && xy.y <= this.config.yAxis.start &&\n\t\t\txy.x >= this.config.xAxis.start && xy.x <= this.config.xAxis.end )\n\t{\n\t\tttd = this.tooltipDataCache[ xy.x ];\n\n\t\tvar search = xy.x;\n\t\twhile ( ttd === undefined && search >= this.config.xAxis.start )\n\t\t{\n\t\t\tsearch--;\n\t\t\t// If there was no data for this x value, try using one to the left\n\t\t\tttd = this.tooltipDataCache[ search ];\n\t\t}\n\n\t\t// Also search for dismissals close by, so the mouse doesn't have to be exactly on it\n\t\tif ( ttd === undefined || ttd.dismissals === undefined )\n\t\t{\n\t\t\tvar dismissalData = undefined;\n\t\t\tfor ( var offset = 1; offset <= 3; offset++ )\n\t\t\t{\n\t\t\t\tvar neighbour = this.tooltipDataCache[ xy.x - offset ];\n\t\t\t\tif ( neighbour !== undefined && neighbour.dismissals !== undefined )\n\t\t\t\t{\n\t\t\t\t\tdismissalData = neighbour.dismissals;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tneighbour = this.tooltipDataCache[ xy.x + offset ];\n\t\t\t\tif ( neighbour !== undefined && neighbour.dismissals !== undefined )\n\t\t\t\t{\n\t\t\t\t\tdismissalData = neighbour.dismissals;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdismissalData = ttd.dismissals;\n\t\t}\n\t}\n\n\tif ( ttd !== this.tooltipData || dismissalData !== this.dismissalData )\n\t{\n\t\tthis.tooltipData = ttd;\n\t\tthis.dismissalData = dismissalData;\n\n\t\tthis.updateTooltip();\n\t}\n}"}}},"RaphaelTrajectoryRenderer":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"PULSE.RaphaelTrajectoryRenderer"},{"title":"param","description":null,"type":null,"name":"config"}]},"Source":"PULSE.RaphaelTrajectoryRenderer = function ( config )\n{\n\tthis.config = config;\n\tthis.timerId = null;\n\tthis.animationPeriod = null;\n\tthis.time = null;\n\tthis.speed = config.speed;\n\tthis.viewIndex = 0;\n\t\n\t// Configurable properties of the renderer\n\tthis.defer = true;\n\tthis.renderBounce = true;\n\tthis.renderEnd = true;\n\n\tPULSE.RaphaelTrajectoryRenderer.prototype.augmentConfig = function ()\n\t{\n\t\tif ( this.viewIndex < this.config.views.length )\n\t\t{\n\t\t\tvar subconfig = this.config.views[ this.viewIndex ];\n\t\t\tfor ( var property in subconfig )\n\t\t\t{\n\t\t\t\tthis.config[ property ] = subconfig[ property ];\n\t\t\t}\n\t\t}\n\t};\n\n\tthis.augmentConfig();\n}","prototype":{"augmentConfig":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.RaphaelTrajectoryRenderer.prototype.augmentConfig = function ()\n\t{\n\t\tif ( this.viewIndex < this.config.views.length )\n\t\t{\n\t\t\tvar subconfig = this.config.views[ this.viewIndex ];\n\t\t\tfor ( var property in subconfig )\n\t\t\t{\n\t\t\t\tthis.config[ property ] = subconfig[ property ];\n\t\t\t}\n\t\t}\n\t}"},"setView":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"viewIndex"}]},"Source":"PULSE.RaphaelTrajectoryRenderer.prototype.setView = function ( viewIndex )\n{\n\tthis.resetRendering();\n\tthis.viewIndex = viewIndex;\n\tthis.augmentConfig();\n\tthis.controller.setBackground( this.config.background );\n\tthis.controller.setMask( this.config.mask, this.config.maskIsCss );\n}"},"nextView":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.RaphaelTrajectoryRenderer.prototype.nextView = function ()\n{\n\tvar viewIndex = this.viewIndex + 1;\n\tif ( viewIndex >= this.config.views.length )\n\t{\n\t\tviewIndex = 0;\n\t}\n\tthis.setView( viewIndex );\n}"},"setSpeed":{"Documentation":{"description":"This function augments the renderers configuration with the configuration contained in\nthe current view.","tags":[]},"Source":"PULSE.RaphaelTrajectoryRenderer.prototype.setSpeed = function ( speed )\n{\n\tthis.speed = speed;\n}"},"showDescription":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.RaphaelTrajectoryRenderer.prototype.showDescription = function ()\n{\n\tif ( this.data.length > this.activeBall )\n    {\n        PULSE.GraphController.setInfo( this.data[ this.activeBall ].generateDescription(), true ); \n    }\n}"},"render":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"db"},{"title":"param","description":null,"type":null,"name":"data"},{"title":"param","description":null,"type":null,"name":"ctx"},{"title":"param","description":null,"type":null,"name":"immediate"}]},"Source":"PULSE.RaphaelTrajectoryRenderer.prototype.render = function ( db, data, ctx, immediate )\n{\n\tctx.r.clear();\n\t\n\tPULSE.Tracer.info( 'TrajectoryRenderer.render called with immediate=' + immediate );\n\t\n\t// Ensure view is correctly set \n\tthis.augmentConfig();\n\tthis.controller.setBackground( this.config.background );\n\tthis.controller.setMask( this.config.mask );\n\t\n\tif ( this.defer && !immediate )\n\t{\n\t\t// If there is no data, return\n\t\tif ( data === undefined || data === null || data.length === 0 )\n\t\t{\n\t\t\tPULSE.Tracer.info( 'No data, returning' );\n\t\t\treturn;\n\t\t}\n\t\t// Never render this data immediately, unless this is the first render attempt, as it\n\t\t// will force the animation to restart.\n\t\telse if ( this.deferredRenderCall !== undefined )\n\t\t{\n\t\t\t// We have previously set data, so save the call as deferred and return. The deferred\n\t\t\t// data will be used once the current animation loop has ended.\n\t\t\tPULSE.Tracer.info( 'Deferring call' );\n\t\t\t\n\t\t\tthis.deferredRenderCall = { db:db, data:data, ctx:ctx };\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Otherwise continue, but give the deferred data a null value so that we know we\n\t\t\t// have now rendered\n\t\t\tPULSE.Tracer.info( 'Continuing' );\n\t\t\t\n\t\t\tthis.deferredRenderCall = null;\n\t\t}\n\t}\n\t\n\t// Save balls, up to the maximum\n\tif ( this.config.maxBalls !== undefined )\n\t{\n\t\tthis.data = data.slice( 0, this.config.maxBalls );\t\t\n\t}\n\telse\n\t{\n\t\tthis.data = data;\n\t}\n\n\t// Only use balls that have valid trajectories\n\tvar validData = [];\n\tfor ( var i = 0, j = this.data.length; i < j; i++ )\n\t{\n\t\tvar row = this.data[i];\n\t\tvar traj = row.get( CricketField.TRAJECTORY );\n\n\t\tif ( traj !== undefined && traj.trackApproved )\n\t\t{\n\t\t\tvalidData.push( row );\n\t\t}\n\t}\n\tthis.data = validData;\n\t\t\n\t// Save the context, as we need it in the timer callback\n\tthis.ctx = ctx;\n\t\n\t// Reset render/offset array\n\tthis.renderData = [];\n\tthis.activeBall = 0;\n\tthis.offsets = [0];\n\n\tthis.showDescription();\n\t\n\t// Iterate over balls to find start/end/offset times\n\tvar anim = { start:Number.MAX_VALUE, end:Number.MIN_VALUE };\n\t\n\tPULSE.Tracer.info( 'Rendering ' + this.data.length + ' trajectories' );\n\t\n\tvar total = 0;\n\tfor ( var i = 0, j = this.data.length; i < j; i++ )\n\t{\n\t\t// Obtain trajectory\n\t\tvar row = this.data[i];\n\t\tvar traj = row.get( CricketField.TRAJECTORY );\n\n\t\tPULSE.Tracer.info( 'Traj ' + i + ' period ' + Utils.toString( traj.period, true ) );\n\t\t\n\t\tif ( 'serial' === this.config.ordering )\n\t\t{\n\t\t\t// Update total\n\t\t\tvar length = traj.period.end - traj.period.start;\n\t\t\ttotal += length;\n\t\t\t\n\t\t\t// First traj\n\t\t\tif ( i === 0 )\n\t\t\t{\n\t\t\t\tanim.start = 0;\n\t\t\t}\n\t\t\t\n\t\t\t// Last traj (can also be the first!)\n\t\t\tif ( i === j-1 )\n\t\t\t{\n\t\t\t\tanim.end = total + this.config.timeMargin.end;\n\t\t\t}\n\t\t\t\n\t\t\tthis.offsets[ i+1 ] = total;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Parallel processing\n\t\t\tvar start = traj.period.start - this.config.timeMargin.start;\n\t\t\tvar end = traj.period.end + this.config.timeMargin.end;\n\t\t\t\n\t\t\tif ( start < anim.start )\n\t\t\t{\n\t\t\t\tanim.start = start;\n\t\t\t}\n\t\t\tif ( end > anim.end )\n\t\t\t{\n\t\t\t\tanim.end = end;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tPULSE.Tracer.info( 'Offsets: ' + Utils.toString( this.offsets, true ) );\n\t\n\t// Set up timing parameters\n\tthis.animationPeriod = anim;\n\tthis.time = this.animationPeriod.start;\n\t\n\tPULSE.Tracer.info( 'Animation period is ' + Utils.toString( anim, true ) ); \n\t\n\t// Start timer, stopping any previous one\n\tif ( this.timerId !== null )\n\t{\n\t\tclearInterval( this.timerId );\n\t}\n\t\n\tvar that = this;\n\tthis.timerId = setInterval( function() { that.increment(); }, this.config.refresh );\n}"},"unrender":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.RaphaelTrajectoryRenderer.prototype.unrender = function ()\n{\n\tthis.deferredRenderCall = undefined;\n\tif ( this.timerId !== null )\n\t{\n\t\tclearInterval( this.timerId );\n\t\tthis.timerId = null;\n\t}\n}"},"resetRendering":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.RaphaelTrajectoryRenderer.prototype.resetRendering = function ()\n{\n\tthis.time = this.animationPeriod.start;\n\tthis.renderData = [];\n\tthis.activeBall = 0;\n\tthis.showDescription();\n\t\n\tthis.ctx.r.clear();\n\n\tif ( this.deferredRenderCall )\n\t{\n\t\t// We have a deferred render call outstanding, so make that call now\n\t\tPULSE.Tracer.info( 'Making deferred rendering call' );\n\t\tthis.render( this.deferredRenderCall.db, this.deferredRenderCall.data, this.deferredRenderCall.ctx, true );\n\t\t\n\t\t// Reset the render call data\n\t\tthis.deferredRenderCall = null;\n\t}\n}"},"increment":{"Documentation":{"description":"Increments the point in time the animation is currently representing.","tags":[]},"Source":"PULSE.RaphaelTrajectoryRenderer.prototype.increment = function ()\n{\n\tthis.time += ( this.config.interval * this.speed );\n\t\n\tif ( this.time > this.animationPeriod.end )\n\t{\n\t\tthis.resetRendering();\n\t}\n\t\n\t// Move onto next active ball if we need to\n\tif ( this.time > this.offsets[ this.activeBall + 1 ] )\n\t{\n\t\tif ( this.renderEnd )\n\t\t{\n\t\t\t// Ensure we have rendered the last point for the current ball\n\t\t\tvar thisTraj = this.data[this.activeBall].get( CricketField.TRAJECTORY );\n\t\t\tvar thisRd = this.renderData[this.activeBall];\n\n\t\t\tPULSE.RaphaelTrajectoryRenderer.addRenderData( \n\t\t\t\t\tthis.activeBall, this.config, thisRd, thisTraj, thisTraj.period.end );\n\t\t}\n\t\t\n\t\tthis.activeBall++;\n\t\tthis.showDescription();\n\t}\n\t\n\t// Add render data for the active ball\n\tfor ( var i = 0, j = this.data.length; i < j; i++ )\n\t{\n\t\tif ( 'parallel' === this.config.ordering || i === this.activeBall )\n\t\t{\n\t\t\t// Obtain trajectory\n\t\t\tvar row = this.data[i];\n\t\t\tvar traj = row.get( CricketField.TRAJECTORY );\n\t\t\t\n\t\t\t// Create or obtain render data for this traj\n\t\t\tvar rd = this.renderData[i];\n\t\t\tif ( !rd )\n\t\t\t{\n\t\t\t\trd = {};\n\t\t\t\trd.shadowPath = '';\n\t\t\t\trd.trailPath = '';\n\t\t\t\trd.shadow = this.ctx.r.path();\n\t\t\t\trd.trail = this.ctx.r.path();\n\t\t\t\t\n\t\t\t\tvar img = this.config.ballImagePath + '12px/phe_red_ball.png';\n\t\t\t\trd.ball = this.ctx.r.image( img, 0, 0, 0, 0 );\n\t\t\t\t\n\t\t\t\tthis.renderData[i] = rd;\n\t\t\t}\n\t\n\t\t\tvar offset = this.offsets[i] === undefined ? 0 : this.offsets[i];\n\t\t\tvar t1 = this.time - offset + traj.period.start;\n\t\t\t\n\t\t\tPULSE.RaphaelTrajectoryRenderer.addRenderData( i, this.config, rd, traj, t1 );\n\t\t\t\n\t\t\t// Check to see if the next timing point is after the bounce time; if it is,\n\t\t\t// add the bounce time render point now\n\t\t\tif ( this.renderBounce )\n\t\t\t{\n\t\t\t\tvar t2 = t1 + ( this.config.interval * this.config.speed );\n\t\t\t\tif ( t1 < traj.bt && t2 > traj.bt )\n\t\t\t\t{\n\t\t\t\t\tPULSE.RaphaelTrajectoryRenderer.addRenderData( i, this.config, rd, traj, traj.bt );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"}},"addRenderData":{"Documentation":{"description":"Utility method to get render data for a given trajectory at a given point in time.","tags":[]},"Source":"PULSE.RaphaelTrajectoryRenderer.addRenderData = function ( i, config, rd, traj, time )\n{\n\t// Obtain ball-on-screen information\n\tvar bos = PULSE.RaphaelTrajectoryRenderer.getBallOnScreen( config, traj, time );\n\n\t// Add the data to the paths\n\tif ( !rd.shadowPath )\n\t{\n\t\trd.shadowPath = 'M';\n\t\trd.trailPath = 'M';\n\t}\n\telse\n\t{\n\t\trd.shadowPath += 'L';\n\t\trd.trailPath += 'L';\n\t}\n\t\t\n\trd.shadowPath += bos.shadow.x + ' ' + bos.shadow.y;\n\trd.trailPath += bos.ball.x + ' ' + bos.ball.y;\n\t\n\t// Obtain colours\n\tvar trailColor = config.trailColors[i % config.trailColors.length];\n\n\t// Update Raphael objects\n    rd.trail.attr( { path:rd.trailPath, stroke:trailColor, 'stroke-width':4, 'stroke-linejoin':'round', opacity:config.trailOpacity } ).toFront();\n    rd.shadow.attr( { path:rd.shadowPath, stroke:config.shadowStyle, 'stroke-width':4, opacity:config.shadowOpacity } ).toBack();\n    rd.ball.attr( { x:bos.ball.x - bos.size, y:bos.ball.y - bos.size, width:bos.size * 2, height:bos.size * 2 } ) \n           .toFront();\n}"},"getBallOnScreen":{"Documentation":{"description":"Gets screen-based ball information for a given time. Returns an object with properties:\n\nshadow   { x, y } - on-screen location of shadow\nball     { x, y } - on-screen location of ball\nsize              - on-screen ball radius","tags":[]},"Source":"PULSE.RaphaelTrajectoryRenderer.getBallOnScreen = function ( config, traj, time )\n{\n\t// Get ball position in real-world coordinates\n\tvar xyz;\n\t\n\tif ( time > traj.period.end )\n\t{\n\t\txyz = traj.getPositionAtTime( traj.period.end );\n\t}\n\telse if ( time < traj.period.start )\n\t{\n\t\txyz = traj.getPositionAtTime( traj.period.start );\n\t}\n\telse\n\t{\n\t\txyz = traj.getPositionAtTime( time );\n\t}\n\t\n\t// Approximate the ball size\n\tvar size = config.ballSize.max - ( xyz.x * ( ( config.ballSize.max - \n\t\t\t\t\t\t\t\t\t\tconfig.ballSize.min ) /\n\t\t\t\t\t\t\t\t\t\tconfig.releaseX ) );\n\n\t// Convert to VR coordinates\n\txyz.x -= 10.06;\n\n\t// Project shadow\n\tvar shadowScreen = config.projection.project( { x:xyz.x, y:xyz.y, z:0 } );\n\t\n\t// Project ball\n\tvar ballScreen = config.projection.project( xyz );\n\t\n\t// Return object\n\treturn { shadow:shadowScreen, ball:ballScreen, size:size }; \n}"}},"UdsHawkeyeDatabase":{"prototype":{"getData":{"Documentation":{"description":"Provide no-ops for getData, getMetadata and getHighestInnings.","tags":[]},"Source":"PULSE.UdsHawkeyeDatabase.prototype.getData = function()\n\t{ \n\t\treturn [];\n\t}"},"getMetadata":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.UdsHawkeyeDatabase.prototype.getMetadata = function()\n\t{ \n\t\treturn {};\n\t}"},"getHighestInnings":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.UdsHawkeyeDatabase.prototype.getHighestInnings = function()\n\t{\n\t\treturn 0;\n\t}"},"getLastKeys":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.UdsHawkeyeDatabase.prototype.getLastKeys = function()\n\t{\n\t\treturn {};\n\t}"},"informListener":{"Documentation":{"description":"Informs the listener of new data becoming available.","tags":[]},"Source":"PULSE.UdsHawkeyeDatabase.prototype.informListener = function ()\n{\n\tif ( this.listener !== null )\n\t{\n\t\tthis.listener.inform( this );\n\t}\n}"},"setListener":{"Documentation":{"description":"Sets the listener for updates to the data.","tags":[]},"Source":"PULSE.UdsHawkeyeDatabase.prototype.setListener = function ( listener )\n{\n\tthis.listener = listener;\n}"},"nullData":{"Documentation":{"description":"Provide no-ops for getData, getMetadata and getHighestInnings.","tags":[]},"Source":"PULSE.UdsHawkeyeDatabase.prototype.nullData = function () \n{\n\tPULSE.UdsHawkeyeDatabase.prototype.getData = function()\n\t{ \n\t\treturn [];\n\t};\n\tPULSE.UdsHawkeyeDatabase.prototype.getMetadata = function()\n\t{ \n\t\treturn {};\n\t};\n\tPULSE.UdsHawkeyeDatabase.prototype.getHighestInnings = function()\n\t{\n\t\treturn 0;\n\t};\n\tPULSE.UdsHawkeyeDatabase.prototype.getLastKeys = function()\n\t{\n\t\treturn {};\n\t};\n}"},"checkForUpdate":{"Documentation":{"description":"Checks to see if the data has been updated since the last time the data was read\nusing the readData method. If it has, then invoke the callback.","tags":[]},"Source":"PULSE.UdsHawkeyeDatabase.prototype.checkForUpdate = function ( callback )\n{\n\t// Save the update callback reference\n\tPULSE.UdsHawkeyeDatabase.updateCallback = callback;\n\t\n\t// Obtain the metadata via JSONP callback\n\tvar path = PULSE.UdsHawkeyeDatabase.URL_PREFIX + this.customer + '/' + this.gameId + \n\t\t\t   PULSE.UdsHawkeyeDatabase.UDSMETA_URL_SUFFIX;\n\tPULSE.UdsHawkeyeDatabase.dynamicScriptLoad( path );\n}"},"loadGame":{"Documentation":{"description":"Dynamically sets the UDS game ID and forces a load from the derived path.","tags":[]},"Source":"PULSE.UdsHawkeyeDatabase.prototype.loadGame = function ( gameId, customer )\n{\t\n\t// Unload current game\n\tthis.nullData();\n\tthis.informListener();\n\t\n\tvar thisCustomer = customer;\n\tif ( Utils.isNullish( thisCustomer ) )\n\t{\n\t\tthisCustomer = 'cricinfo';\n\t}\n\t\n\tPULSE.UdsHawkeyeDatabase.lastUpdated = null; \n\tthis.gameId = gameId;\n\tthis.customer = thisCustomer;\n\t\n\t// Stop any existing monitor\n\tif ( this.dataMonitor !== undefined )\n\t{\n\t\tthis.dataMonitor.stop();\n\t\tPULSE.Tracer.info( 'DataMonitor stopped' );\n\t}\n\t\n\t// Create a data monitor for the game and let that do the work\n\tthis.dataMonitor = new PULSE.DataMonitor( 30000, this, function () \n\t{\n\t\t// If the monitor triggers, load the full JSONP data  \n\t\tvar path = PULSE.UdsHawkeyeDatabase.URL_PREFIX + thisCustomer + '/' + gameId + \n\t\t\t\t   PULSE.UdsHawkeyeDatabase.UDS_URL_SUFFIX;\n\t\tPULSE.UdsHawkeyeDatabase.dynamicScriptLoad( path );\n\t} );\n\tthis.dataMonitor.start();\n\tPULSE.Tracer.info( 'DataMonitor started' );\n}"},"setActive":{"Documentation":{"description":"Sets whether the active datamonitor actually does any downloading of metadata.","tags":[]},"Source":"PULSE.UdsHawkeyeDatabase.prototype.setActive = function ( active )\n{\n\tif ( this.dataMonitor !== undefined )\n\t{\n\t\tthis.dataMonitor.downloading = active;\n\t}\n}"},"loadData":{"Documentation":{"description":"Loads the data from the actual UDS file on the CDN.","tags":[]},"Source":"PULSE.UdsHawkeyeDatabase.prototype.loadData = function ()\n{\n\tvar path = PULSE.UdsHawkeyeDatabase.URL_PREFIX + this.customer + '/' + this.gameId + \n\t\t\t   PULSE.UdsHawkeyeDatabase.UDS_URL_SUFFIX;\n\t//var path = \"file:///C:/svn/dev2/trunk/javascript/projects/cricket/pulse-telegraph/src/uds.json\";\n\tPULSE.UdsHawkeyeDatabase.dynamicScriptLoad( path );\n}"},"normalise":{"Documentation":{"description":"Normalises the data contained in the given coordinate to 'standard' (VR) coordinates.","tags":[]},"Source":"PULSE.UdsHawkeyeDatabase.prototype.normalise = function ( xyz )\n{\n\treturn { x:xyz.x-10.06, y:xyz.y, z:xyz.z };\n}"},"getMatchType":{"Documentation":{"description":"Gets the match type for this match.","tags":[]},"Source":"PULSE.UdsHawkeyeDatabase.prototype.getMatchType = function ()\n{\n\tvar mt = CricketMatchType.TEST;\n\n\tvar overs = this.getMetadata()[ 'overs' ];\n\tif ( overs === '20' )\n\t{\n\t\tmt = CricketMatchType.T20;\n\t}\n\telse if ( overs === '50' )\n\t{\n\t\tmt = CricketMatchType.ODI;\n\t}\n\t\n\treturn mt;\n}"},"getParticipants":{"Documentation":{"description":"Gets the participant data for this match.","tags":[]},"Source":"PULSE.UdsHawkeyeDatabase.prototype.getParticipants = function ()\n{\n\treturn [ new Participant( this.getMetadata()[ 'participant_1' ] ),\n\t         new Participant( this.getMetadata()[ 'participant_2' ] ) ];\n}"},"getScoring":{"Documentation":{"description":"Gets scoring data for this match.","tags":[]},"Source":"PULSE.UdsHawkeyeDatabase.prototype.getScoring = function ()\n{\n\tvar score = new PULSE.UdsScore( this.getData(), this.getBattingOrder(), this.getLastKeys().all );\n\t\n\treturn score;\n}"},"getBattingTeamIndex":{"Documentation":{"description":"Gets the batting team index (0 or 1) in the given 1-based innings number.","tags":[]},"Source":"PULSE.UdsHawkeyeDatabase.prototype.getBattingTeamIndex = function ( innings )\n{\n\tvar order = this.getMetadata()[ 'batting_order' ];\n\tif ( order && order.length >= innings )\n\t{\n\t\tvar idx = +order.charAt( innings - 1 );\n\t\treturn idx - 1;\n\t}\n\telse\n\t{\n\t\t// Something went wrong, as we are asking for an innings that doesn't exist\n\t\t// in the batting order; so, just return something\n\t\treturn 1;\n\t}\n}"},"getBattingOrder":{"Documentation":{"description":"Gets an array of batting team indexes (0 or 1)","tags":[]},"Source":"PULSE.UdsHawkeyeDatabase.prototype.getBattingOrder = function ()\n{\n\tvar battingOrder = [];\n\tvar order\t\t = this.getMetadata()[ 'batting_order' ];\n\t\n\tif ( order && order.length )\n\t{\n\t\tfor(var i = 0; i < order.length; i++) {\n\t\t\tvar idx = +order.charAt( i );\n\t\t\tbattingOrder.push(idx);\n\t\t}\n\t}\n\treturn battingOrder;\n}"},"getInningsString":{"Documentation":{"description":"Gets the innings string for the given innings.","tags":[{"title":"param","description":"the 1-based innings number","type":null,"name":"innings"}]},"Source":"PULSE.UdsHawkeyeDatabase.prototype.getInningsString = function ( innings )\n{\n\tvar battingIndex = this.getBattingTeamIndex( innings );\n\tvar participant = this.getParticipants()[ battingIndex ];\n\t\n\t// Seed string with participant name\n\tvar string = participant.fullName;\n\t\n\t// If we are in a Test match, add 1st/2nd\n\tif ( this.getMatchType() === CricketMatchType.TEST )\n\t{\n\t\tstring += ( innings <= 2 ? ' 1st' : ' 2nd' );\n\t}\n\n\t// Add 'innings'\n\tstring += ' innings';\n\treturn string;\t\n}"},"getInningsFromString":{"Documentation":{"description":"Converts an innings string back into the 1-based innings index. This is essentially the\ninverse function of getInningsString","tags":[{"title":"param","description":"the innings string","type":null,"name":"string"}]},"Source":"PULSE.UdsHawkeyeDatabase.prototype.getInningsFromString = function ( string )\n{\n\t// Build array of all available strings\n\tvar candidates = [];\n\tvar inningsLookup = {};\n\tfor ( var i = 1, j = this.getHighestInnings(); i <= j; i++ )\n\t{\n\t\tvar is = this.getInningsString( i );\n\n\t\tcandidates.push( is );\n\t\tinningsLookup[ is ] = i;\n\t}\n\t\n\t// Now do a Levenshtein match of the input string\n\tvar matched = PULSE.Levenshtein.bestMatch( candidates, string );\n\t\t\n\t// Return the innings number\n\treturn inningsLookup[ matched ];\n}"},"getOptions":{"Documentation":{"description":"Obtains the set of unique values for all filter options, given the optional filter.","tags":[{"title":"param","description":"(optional) the initial filter","type":null,"name":"filter"}]},"Source":"PULSE.UdsHawkeyeDatabase.prototype.getOptions = function ( filter )\n{\n\tPULSE.Tracer.info( 'getOptions with filter=' + Utils.toString( filter ) ); \n\t\n\tvar options = { innings:{}, batsman:{}, bowler:{}, over:{}, ball:{} };\n\t\n\tvar d = this.getData();\n\tfor ( var key in d )\n\t{\n\t\tvar record = d[ key ];\n\t\t\n\t\tif ( record.satisfiesFilter )\n\t\t{\n\t\t\t// Check to see if this record satisfies the given filter, but be careful to allow\n\t\t\t// through all value that are being used as a filter \n\t\t\tvar satisfy = record.satisfiesFilter( filter );\n\t\t\t\n\t\t\tvar s = record.get( CricketField.INNINGS );\n\t\t\tif ( !Utils.isNullish( s ) && ( satisfy || !Utils.isNullish( filter.innings ) ) )\n\t\t\t{\n\t\t\t\t// Convert innings to descriptive string\n\t\t\t\ts = this.getInningsString( +s );\n\t\t\t\toptions.innings[s] = undefined;\n\t\t\t}\n\t\t\ts = record.get( CricketField.BATSMAN );\n\t\t\tif ( !Utils.isNullish( s ) && ( satisfy || !Utils.isNullish( filter.batsman ) ) )\n\t\t\t{\n\t\t\t\toptions.batsman[s] = undefined;\n\t\t\t}\n\t\t\ts = record.get( CricketField.BOWLER );\t\t\t\n\t\t\tif ( !Utils.isNullish( s ) && ( satisfy || !Utils.isNullish( filter.bowler ) ) )\n\t\t\t{\t\n\t\t\t\toptions.bowler[s] = undefined;\n\t\t\t}\n\t\t\ts = record.get( CricketField.INNINGS ) + '.' + record.get( CricketField.OVER );\n\t\t\tif ( !Utils.isNullish( s ) && ( satisfy || !Utils.isNullish( filter.over ) ) )\n\t\t\t{\n\t\t\t\toptions.over[s] = undefined;\n\t\t\t}\n\t\t\ts = record.get( CricketField.BALL );\n\t\t\tif ( !Utils.isNullish( s ) && ( satisfy || !Utils.isNullish( filter.ball ) ) )\n\t\t\t{\n\t\t\t\t// Additionally check that the innings/over matches, if we are in a specific over\n\t\t\t\tvar add = true;\n\t\t\t\tif ( filter && CricketFilter.WATCHLIVE !== filter.over )\n\t\t\t\t{\n\t\t\t\t\tvar secondaryFilter = { innings:filter.innings, over:filter.over };\n\t\t\t\t\tadd = record.satisfiesFilter( secondaryFilter );\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif ( add )\n\t\t\t\t{\n\t\t\t\t\tvar extended = record.get( CricketField.COUNTING_BALL );\n\t\t\t\t\t\n\t\t\t\t\tvar summary = Utils.trim( record.generateSummary( true ) );\n\t\t\t\t\tif ( summary.length > 0 )\n\t\t\t\t\t{\n\t\t\t\t\t\textended += PULSE.UdsHawkeyeDatabase.BALL_RUNS_PREFIX + summary +\n\t\t\t\t\t\t\t\t\tPULSE.UdsHawkeyeDatabase.BALL_RUNS_SUFFIX; \n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\toptions.ball[s] = extended;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t//PULSE.Tracer.info( 'getOptions returned ' + Utils.toString( options ) );\n\t\n\treturn options;\n}"},"lookupPlayer":{"Documentation":{"description":"Looks up a player ID from a name.","tags":[]},"Source":"PULSE.UdsHawkeyeDatabase.prototype.lookupPlayer = function ( name )\n{\n\t// In this implementation, the ID is simply the name\n\treturn name;\n}"},"getType":{"Documentation":{"description":"Gets the 'class' name for this database.","tags":[]},"Source":"PULSE.UdsHawkeyeDatabase.prototype.getType = function ()\n{\n\treturn 'UdsHawkeyeDatabase';\n}"},"getParameter":{"Documentation":{"description":"Obtains a coordinate-space specific value from this database.","tags":[]},"Source":"PULSE.UdsHawkeyeDatabase.prototype.getParameter = function ( key )\n{\n\tif ( 'ww-sign' === key )\n\t{\n\t\treturn 1;\n\t}\n\telse if ( 'ww-origin-x' === key )\n\t{\n\t\treturn -11;\n\t}\t\n}"},"getInningsList":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.UdsHawkeyeDatabase.prototype.getInningsList = function()\n{\t\n\tvar allInnings = [];\n\tvar previousInnings = '';\n\tvar d = this.getData();\n\tfor ( var key in d )\n\t{\n\t\tif(d.hasOwnProperty(key)) {\n\t\t\tvar record = d[ key ];\n\t\t\tvar s = record.get( CricketField.INNINGS );\n\t\t\ts = this.getInningsString( +s );\n\t\t\tif( s && s !== previousInnings )\n\t\t\t{\n\t\t\t\tallInnings[allInnings.length] = s;\n\t\t\t}\n\t\t\tpreviousInnings = s;\n\t\t}\n\t}\n\t\t\t\n\treturn allInnings;\n}"}},"Documentation":{"description":"Constructor. No-op: data load deferred to loadGame call","tags":[]},"Source":"PULSE.UdsHawkeyeDatabase = function ( listener )\n{\n\t// Constants\n\tPULSE.UdsHawkeyeDatabase.LOADER_SCRIPT_ID = 'udsLoaderScript';\n\tPULSE.UdsHawkeyeDatabase.UDSMETA_URL_SUFFIX = '/uds-meta.js';\n\n\tPULSE.UdsHawkeyeDatabase.BALL_RUNS_PREFIX = ' <span>';\n\tPULSE.UdsHawkeyeDatabase.BALL_RUNS_SUFFIX = '</span>';\n\t\n\t// This is where the CDN setup code goes. There are currently 3 supported environments\n\t// and you should comment in the two lines appropriate to the target environment \n\t\n\t// Lee's testing only\n\t//PULSE.UdsHawkeyeDatabase.URL_PREFIX = 'http://dynamic.pulselive.com/dynamic/';\n\t//PULSE.UdsHawkeyeDatabase.UDS_URL_SUFFIX = '/uds.jsonp';\n\t// Playdev testing only\n\t//PULSE.UdsHawkeyeDatabase.URL_PREFIX = 'http://dynamic.pulselive.com/test/';\n\t//PULSE.UdsHawkeyeDatabase.UDS_URL_SUFFIX = '/uds.json.jgz';\n\t// Production\n\tPULSE.UdsHawkeyeDatabase.URL_PREFIX = 'http://dynamic.pulselive.com/dynamic/';\n\tPULSE.UdsHawkeyeDatabase.UDS_URL_SUFFIX = '/uds.json.jgz';\n\t\n\t// Set up instance accessor\n\tvar that = this;\n\tPULSE.UdsHawkeyeDatabase.getInstance = function () { return that; };\n\t\n\t// Save listener reference\n\tthis.listener = listener;\n\t\n\t// Seed state\n\tthis.nullData();\n}","getInstance":{"Documentation":{"description":"Constructor. No-op: data load deferred to loadGame call","tags":[]},"Source":"PULSE.UdsHawkeyeDatabase.getInstance = function () { return that; }"},"dynamicScriptLoad":{"Documentation":{"description":"Provides a generic dynamic script loading method, for JSONP injection.","tags":[{"title":"param","description":"the cross-site path we want to load from","type":null,"name":"path"}]},"Source":"PULSE.UdsHawkeyeDatabase.dynamicScriptLoad = function ( path )\n{\n\tPULSE.Tracer.info( 'Dynamic script load from ' + path );\n\n\t// Unload any existing script\n\tvar script = document.getElementById( PULSE.UdsHawkeyeDatabase.LOADER_SCRIPT_ID );\n\tif ( script !== null )\n\t{\n\t\tscript.parentNode.removeChild( script );\n\t}\n\t\n\t// Use dynamic JavaScript insertion with JSONP to get the data from a different domain\n\tscript = document.createElement( 'script' );\n\tscript.setAttribute( 'id', PULSE.UdsHawkeyeDatabase.LOADER_SCRIPT_ID );\n\tscript.setAttribute( 'src', path + '?t=' + ( +new Date() ) );\n\n\t// Attach the script to the head, hence invoking its contents\n\tdocument.getElementsByTagName('head')[0].appendChild( script );\n}"}},"UdsHawkeyeRecord":{"Documentation":{"description":"Wrapper for a record from a UDS file.","tags":[]},"Source":"PULSE.UdsHawkeyeRecord = function ( rawBp, rawData )\n{\n\tthis.fields = rawData.split( ',' );\n\tthis.bp = new PULSE.BallProgress( rawBp );\n\tthis.traj = null;\n}","prototype":{"satisfiesFilter":{"Documentation":{"description":"Returns true if this record satisfies the given filter.","tags":[]},"Source":"PULSE.UdsHawkeyeRecord.prototype.satisfiesFilter = function ( filter )\n{\n\tif ( filter === undefined )\n\t{\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\t// First check a *.*.All match on the over filter\n/*\t\tif ( filter.over !== undefined && filter.over.match( /[0-9]+\\.[0-9]+\\.All/ ) !== null )\n\t\t{\n\t\t\tvar sample = filter.over.replace( /All/, '0' );\n\t\t\tvar sampleBp = new PULSE.BallProgress( sample );\n\t\t\t\n\t\t\treturn ( this.bp.innings === sampleBp.innings &&\n\t\t\t\t\t this.bp.over === sampleBp.over );\n\t\t}\n*/\t\t\n\t\t// Check innings, over and ball, allowing for All \n\t\tvar inn = Utils.isNullish( filter.innings ) || \n\t\t\t\t  CricketFilter.ALL === filter.innings ||\n\t\t\t\t  this.get( CricketField.INNINGS ) == filter.innings.toString(); // Coerce!\n\t\t\n\t\tvar over = Utils.isNullish( filter.over ) || \n\t\t   \t\t   CricketFilter.ALL === filter.over ||\n\t\t   \t\t   this.get( CricketField.OVER ) == filter.over; // Coerce!\n\n\t\tvar ball = Utils.isNullish( filter.ball ) || \n\t\t   \t\t   CricketFilter.ALL === filter.ball ||\n\t\t   \t\t   CricketFilter.ALLBALLS === filter.ball ||\n\t\t   \t\t   this.get( CricketField.BALL ) == filter.ball; // Coerce!\n\n\t\tif ( inn && over && ball )\n\t\t{\n\t\t\t// Check batsman\n\t    \tvar lh = this.get( CricketField.HANDEDNESS ) === CricketHandedness.LEFT;\n\t\t\tvar ba = Utils.isNullish( filter.batsman ) || \n\t\t\t\t\t CricketFilter.ALL === filter.batsman ||\n\t\t\t\t\t CricketFilter.ALLBATSMEN === filter.batsman ||\n\t\t\t\t\t ( !lh && CricketFilter.RIGHTHANDERS === filter.batsman ) || \n\t\t\t\t\t (  lh && CricketFilter.LEFTHANDERS === filter.batsman ) ||\n\t\t\t\t\t this.get( CricketField.BATSMAN ) === filter.batsman;\n\t\t\t\t\t \n\t\t\t// Check bowler\n\t\t\tvar spin = this.get( CricketField.BOWLER_SPEED ) === CricketBowlerSpeed.SPIN;\n\t\t\tvar bo = Utils.isNullish( filter.bowler ) || \n\t\t\t\t\t CricketFilter.ALL === filter.bowler ||\n\t\t\t\t\t CricketFilter.ALLBOWLERS === filter.bowler ||\n\t\t\t\t\t (  spin && CricketFilter.SPINBOWLERS === filter.bowler ) || \n\t\t\t\t\t ( !spin && CricketFilter.SEAMBOWLERS === filter.bowler ) ||\n\t\t\t\t\t this.get( CricketField.BOWLER ) === filter.bowler;\n\t\t\t\n\t\t\treturn ba && bo;\n\t    }\n\t\t\n    \treturn false;\n\t}\n}"},"get":{"Documentation":{"description":"Obtains a field (column) from this record.","tags":[]},"Source":"PULSE.UdsHawkeyeRecord.prototype.get = function ( field )\n{\n\tswitch ( field )\n\t{\n\t\tcase CricketField.ID:\n\t\t\treturn this.bp.description();\n\t\n\t\tcase CricketField.BATSMAN:\n\t\t\treturn this.fields[0];\n\t\t\t\n\t\tcase CricketField.BOWLER:\n\t\t\treturn this.fields[2];\n\t\t\t\n\t\tcase CricketField.INNINGS:\n\t\t\treturn this.bp.innings;\n\t\t\t\n\t\tcase CricketField.OVER:\n\t\t\treturn this.bp.over;\n\t\t\t\n\t\tcase CricketField.BALL:\n\t\t\treturn this.bp.ball;\n\t\t\t\n\t\tcase CricketField.COUNTING_BALL:\n\t\t\treturn this.countingBall;\n\t\t\t\n\t\tcase CricketField.WW:\n\t\t\tif ( Utils.isNullish( this.fields[11] ) || Utils.isNullish( this.fields[12] ) )\n\t\t\t{\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn { x:this.fields[11], y:this.fields[12] };\n\t\t\t}\n\t\t\t\n\t\tcase CricketField.RUNS:\n\t\t\tif ( this.fields[16].length > 0 )\n\t\t\t{\n\t\t\t\treturn this.fields[16];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t\n\t\tcase CricketField.CREDIT:\n\t\t\tif ( this.fields[17].length === 0 )\n\t\t\t{\n\t\t\t\treturn this.get( CricketField.RUNS );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn this.fields[17];\n\t\t\t}\n\t\t\t\n\t\tcase CricketField.DEBIT:\n\t\t\tif ( this.fields[18].length === 0 )\n\t\t\t{\n\t\t\t\treturn this.get( CricketField.RUNS );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn this.fields[18];\n\t\t\t}\n\t\t\t\n\t\tcase CricketField.PITCHED:\n\t\t\tif ( this.fields[4].length === 0 )\n\t\t\t{\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\treturn { x:this.fields[4], y:this.fields[5], z:0 };\n\t\t\t\n\t\tcase CricketField.IS_WICKET:\n\t\t\treturn this.fields[14].length > 0;\n\t\t\t\n\t\tcase CricketField.STUMPS:\n\t\t\tif ( this.fields[7].length === 0 )\n\t\t\t{\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\treturn { x:0, y:this.fields[7], z:this.fields[8] };\n\t\t\t\n\t\tcase CricketField.TRAJECTORY:\n\t\t\tif ( this.traj === null )\n\t\t\t{\n\t\t\t\tthis.traj = PULSE.UdsHawkeyeRecord.parseTrajectory( this.fields[23] );\n\t\t\t}\n\t\t\treturn this.traj;\n\t\t\t\n\t\tcase CricketField.BOWL_SPEED:\n\t\t\treturn Number( this.fields[3] );\n\t\t\t\n\t\tcase CricketField.HAS_HANDEDNESS:\n\t\t\treturn this.fields[6].length > 0;\n\t\t\t\n\t\tcase CricketField.HANDEDNESS:\n\t\t\treturn this.fields[6] === 'y' ? CricketHandedness.RIGHT : CricketHandedness.LEFT;\n\t\t\t\n\t\tcase CricketField.IS_COUNTING:\n\t\t\tvar et = this.fields[19];\n\t\t\treturn ( et.length === 0 || 'Lb' === et || 'B' === et );\n\t\t\t\n\t\tcase CricketField.EXTRA_TYPE:\n\t\t\treturn this.fields[19];\n\t\t\t\n\t\tcase CricketField.DISMISSED:\n\t\t\treturn this.fields[14];\n\t\t\t\n\t\tcase CricketField.NF_BATSMAN:\n\t\t\treturn this.fields[1];\n\t\t\t\n\t\tcase CricketField.WIN_LIKELIHOODS:\n\t\t\tif ( Utils.isNullish( this.fields[20] ) )\n\t\t\t{\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn [ +this.fields[20], +this.fields[21], +this.fields[22] ];\n\t\t\t}\n\t\t\t\n\t\tcase CricketField.BOWLER_SPEED:\n\t\t\treturn this.bowlerSpeed;\n\t\t\t\n\t\tcase CricketField.PITCH_SEGMENT:\n\t\t\treturn this.fields[13];\n\t\t\n\t\tcase CricketField.MOD:\n\t\t\treturn this.fields[15];\n\t}\n}"},"hasTrajData":{"Documentation":{"description":"Returns true if the traj field is non-nullish.","tags":[]},"Source":"PULSE.UdsHawkeyeRecord.prototype.hasTrajData = function ()\n{\n\treturn !Utils.isNullish( this.fields[23] );\n}"},"generateSummary":{"Documentation":{"description":"Gets a runs/wicket summary for this record.","tags":[]},"Source":"PULSE.UdsHawkeyeRecord.prototype.generateSummary = function ( lowercase )\n{\n\tvar summary = '';\n\tif ( this.get( CricketField.IS_WICKET ) )\n\t{\n\t\tsummary += lowercase ? 'wicket ' : 'Wicket ';\n\t}\n\t\n\tvar runs = +this.get( CricketField.RUNS );\n\tif ( runs > 0 )\n\t{\n\t\tsummary += runs + ' run';\n\t\tif ( runs > 1 )\n\t\t{\n\t\t\tsummary += 's';\n\t\t}\n\t\t\n\t\tvar et = this.get( CricketField.EXTRA_TYPE );\n\t\tif ( et.length > 0 )\n\t\t{\n\t\t\tsummary += ' (' + ( lowercase ? et.toLowerCase() : et ) + ')';\n\t\t}\n\t}\n\treturn summary;\n}"},"generateDescription":{"Documentation":{"description":"Obtains a commentary-style description of this record.","tags":[]},"Source":"PULSE.UdsHawkeyeRecord.prototype.generateDescription = function ()\n{\n\tvar description = '<b>';\n\n\tdescription += ( +this.get( CricketField.OVER ) - 1 );\n\tdescription += '.';\n\tdescription += this.get( CricketField.COUNTING_BALL );\n\tdescription += '</b> ';\n\t\n    description += this.get( CricketField.BOWLER );\n    description += ' to ';\n    description += this.get( CricketField.BATSMAN );\n\n    // Add ball speed to description\n    var speed = this.get( CricketField.BOWL_SPEED );\n    if ( !isNaN( speed ) && speed >= 30 && speed <= 120 )\n    {\n        description += ', ';\n        if ( PULSE.SpeedModeController.mode === PULSE.SpeedModeController.MODE_KMH )\n        {\n        \tspeed = PULSE.SpeedModeController.mphToKmh( speed );\n        }\n        \n        description += speed.toFixed( 1 );\n        description += ' ' + PULSE.SpeedModeController.unit;        \n    }\n\n    // Add runs scored to description\n\tvar credit = +this.get( CricketField.CREDIT );\n    \n    description += ', ';\n    if ( this.get( CricketField.IS_WICKET ) )\n    {\n        description += 'wicket';\n    }\n    else \n    {\n    \tif ( credit === 0 )\n\t    {\n\t        description += 'dot ball';\n\t    }\n\t    else\n\t    {\n\t        description += credit;\n\t        description += ' run';\n\t        if ( credit > 1 )\n\t        {\n\t            description += 's';\n\t        }\n\t    }\n    }\n\n    // Add description of where the ball went\n    var ps = this.get( CricketField.PITCH_SEGMENT );\n    if ( !Utils.isNullish( ps ) && !this.get( CricketField.IS_WICKET ) && credit > 0 )\n    {\n    \tdescription += ', hit ';\n    \tdescription += CricketSegmentLookup[ ps ];\n    }\n\n    // Finish the sentence\n    description += '.';\n\n    return description;\n}"}},"parseTrajectory":{"Documentation":{"description":"Parses the trajectory data given.","tags":[]},"Source":"PULSE.UdsHawkeyeRecord.parseTrajectory = function ( encoded )\n{\n\t// Raw string is a Base64 encoded stream\n\tvar decoded = Base64Decoder.decode( encoded );\n\t\n\tif ( decoded.length < 72 )\n\t{\n\t\tPULSE.Tracer.warn( 'Decoded traj length was ' + decoded.length );\n\t\treturn undefined;\n\t}\n\t\n    // Extract coefficients into a trajectory object\n\tvar traj = new CricketBallTrajectory();\n\ttry\n\t{\n\t\ttraj.bp   = PULSE.UdsHawkeyeRecord.readMulti( decoded, 0, 2 );\n\t\ttraj.bt   = PULSE.UdsHawkeyeRecord.readMulti( decoded, 8, 1 ).x;\n\t\ttraj.a \t  = PULSE.UdsHawkeyeRecord.readMulti( decoded, 12, 3 );\n\t\ttraj.ebv  = PULSE.UdsHawkeyeRecord.readMulti( decoded, 24, 3 );\n\t\ttraj.obv  = PULSE.UdsHawkeyeRecord.readMulti( decoded, 36, 3 );\n\t\ttraj.oba  = PULSE.UdsHawkeyeRecord.readMulti( decoded, 48, 3 );\n\t\ttraj.bh   = PULSE.UdsHawkeyeRecord.readMulti( decoded, 60, 1 ).x;\n\t\t//traj.pred = parseBoolean( decoded.substring( 64, 65 ) );\n\t\t//traj.xpos = this.readMulti( decoded, 65, 1 ).x;\n\t\t//traj.end = ?\n\t\t//traj.trackApproved = parseInt( decoded.substring( 71, 72 ) ) === 1;\n\t\t// TODO\n\t\ttraj.trackApproved = true;\n\n\t\t// Calculate the period\n\t    var start = traj.getTimeAtX( 18.5 ) + traj.bt;\n\t    var end = traj.getTimeAtX( 0 ) + traj.bt;\n\t    traj.period = { start: start, end: end };\n\t}\n\tcatch ( exception )\n\t{\n\t\tPULSE.Tracer.error( exception );\n\t\ttraj.trackApproved = false;\n\t}\n\t\n\treturn traj;\n}"},"readMulti":{"Documentation":{"description":"Utility method to read multiple floats from the given data stream.","tags":[]},"Source":"PULSE.UdsHawkeyeRecord.readMulti = function ( data, offset, n )\n{\n\tvar ret = {};\n\n\tif ( n > 0 )\n\t{\n\t\tret.x = PULSE.UdsHawkeyeRecord.decodeFloat( data.substring( offset, offset + 4 ) );\n\t}\n\tif ( n > 1 )\n\t{\n\t\tret.y = PULSE.UdsHawkeyeRecord.decodeFloat( data.substring( offset + 4, offset + 8 ) );\n\t}\n\tif ( n > 2 )\n\t{\n\t\tret.z = PULSE.UdsHawkeyeRecord.decodeFloat( data.substring( offset + 8, offset + 12 ) );\n\t}\n\t\n\treturn ret;\n}"},"decodeFloat":{"Documentation":{"description":"Decode an IEE754 float.","tags":[]},"Source":"PULSE.UdsHawkeyeRecord.decodeFloat = function ( data )\n{\n    var sign = ( data.charCodeAt( 0 ) & 0x80 ) >> 7;\n    var exponent = ( ( data.charCodeAt( 0 ) & 0x7F ) << 1 ) + ( data.charCodeAt( 1 ) >> 7 );\n    \n    var significand = 0.0;\n    var bit = 23;\n    var component = 1.0;\n    var b;\n    var mask;\n\n    while ( bit >= 0 )\n    {\n        if ( bit === 23 )\n        {\n            b = ( data.charCodeAt( 1 ) & 0x7F ) | 0x80;\n            mask = 0x80; \n        }\n        else if ( bit === 15 )\n        {\n            b = data.charCodeAt( 2 );\n            mask = 0x80; \n        }\n        else if ( bit === 7 )\n        {\n            b = data.charCodeAt( 3 );\n            mask = 0x80; \n        }\n\t\n\t    if ( ( mask & b ) === mask )\n\t    {\n\t        significand += component;\n\t    }\n\n\t    component /= 2;\n\t    mask = mask >> 1;\n\t    bit--;\n    }\n\n    return Math.pow( -1, sign ) *\n           Math.pow( 2, exponent - 127 ) *\n           significand; \n}"}},"UdsScore":{"Documentation":{"description":"Class to derive score from UDS data.","tags":[{"title":"param","description":":\n           assoc. array of all balls","type":null,"name":"rawData"},{"title":"param","description":":\n           array of the batting orders present for","type":null,"name":"battingOrder"}]},"Source":"PULSE.UdsScore = function( rawData, battingOrder, latest )\n{\n\tvar inningsNumber = \"1\";\n\tvar latestBP = new PULSE.BallProgress( latest );\n\n\t// an array of for initialized innings\n\tvar inningsObj =\n\t{\n\t\t\"1\" : new this.Innings( ),\n\t\t\"2\" : new this.Innings( ),\n\t\t\"3\" : new this.Innings( ),\n\t\t\"4\" : new this.Innings( )\n\t};\n\n\tvar selectedInnings = {};\n\n\tfor ( var key in rawData )\n\t{\n\t\tif ( rawData.hasOwnProperty( key ) )\n\t\t{\n\t\t\tvar item = rawData[key];\n\n\t\t\tvar innings = item.get( CricketField.INNINGS );\n\n\t\t\tvar runs = item.get( CricketField.RUNS );\n\n\t\t\tvar isWicket = item.get( CricketField.IS_WICKET );\n\n\t\t\tif ( inningsObj[innings] )\n\t\t\t{\n\n\t\t\t\tvar selectedInnings = inningsObj[innings];\n\n\t\t\t\t// increment runs\n\t\t\t\tselectedInnings.runs += +runs;\n\t\t\t\tselectedInnings.countingBall = rawData[key].countingBall;\n\n\t\t\t\t// increment wickets\n\t\t\t\tif ( isWicket )\n\t\t\t\t\tselectedInnings.wickets++;\n\n\t\t\t\tselectedInnings.lastBP = key;\n\t\t\t}\n\t\t}\n\t}\n\n\t// if there is a latest innings\n\t// make that innings obj true\n\tif ( latestBP.innings && inningsObj[latestBP.innings] )\n\t{\n\t\tinningsObj[latestBP.innings].mostRecentInnings = true;\n\t\tinningsObj[latestBP.innings].getScoreString( );\n\t}\n\n\t// work out which order to place the array in with battingOrder\n\tvar orderByTeam = this.battingOrderByTeam( battingOrder );\n\n\tvar orderedTeamInnings =\n\t{\n\t\t\"1\" : this.getTeamInnings( 0, inningsObj, orderByTeam ),\n\t\t\"2\" : this.getTeamInnings( 1, inningsObj, orderByTeam )\n\t};\n\n\treturn new PULSE.UdsScore.prototype.MatchResult( orderedTeamInnings );\n}","prototype":{"battingOrderByTeam":{"Documentation":{"description":"function: returns a filtered array of battingOrder ordered by team batting\nfirst","tags":[]},"Source":"PULSE.UdsScore.prototype.battingOrderByTeam = function( battingOrder )\n{\n\tvar orderedBattingOrder = [ [], [] ];\n\n\tfor ( var i = 0; i < 4; i++ )\n\t{\n\t\tvar teamNumber = battingOrder[i];\n\n\t\tif ( teamNumber )\n\t\t{\n\t\t\torderedBattingOrder[teamNumber - 1].push( i + 1 );\n\t\t}\n\t}\n\n\treturn orderedBattingOrder;\n}"},"getTeamInnings":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"PULSE.UdsScore.prototype.getTeamInnings"},{"title":"param","description":null,"type":null,"name":"teamIdx"},{"title":"param","description":null,"type":null,"name":"inningsObj"},{"title":"param","description":null,"type":null,"name":"orderByTeam"}]},"Source":"PULSE.UdsScore.prototype.getTeamInnings = function( teamIdx, inningsObj,\n\t\torderByTeam )\n{\n\tvar inningsFirst = inningsObj[orderByTeam[teamIdx][0]];\n\tvar inningsSecond = inningsObj[orderByTeam[teamIdx][1]];\n\treturn new this.TeamInnings( [ inningsFirst, inningsSecond ] );\n}"},"Innings":{"Documentation":{"description":"Object to help derive innings scores","tags":[]},"Source":"PULSE.UdsScore.prototype.Innings = function()\n{\n\tthis.runs = 0;\n\tthis.wickets = 0;\n\tthis.lastBP = \"\";\n\tthis.overProgress = '';\n\tthis.mostRecentInnings = false;\n}","prototype":{"getScoreString":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.UdsScore.prototype.Innings.prototype.getScoreString = function()\n{\n\t// if balls have been placed in\n\tif ( this.lastBP !== \"\" )\n\t{\n\t\tvar progress = new PULSE.BallProgress( this.lastBP );\n\n\t\t// this works out the over progress\n\t\tvar scoreInstance = PULSE.CLIENT.CRICKET.Score.getInstance();\n\t\tvar overNum = +progress.over;\n\t\tvar countingBalls = this.countingBall;\n\t\tif ( this.countingBall >= 6 )\n\t\t{\n\t\t\toverNum++;\n\t\t\tcountingBalls = 0;\n\t\t}\n\t\tthis.overProgress = scoreInstance.gameScore\n\t\t\t\t&& scoreInstance.gameScore['over-progress'] ? scoreInstance.gameScore['over-progress']\n\t\t\t\t: ( overNum - 1 ) + \".\" + countingBalls;\n\n\t\treturn this.runs\n\t\t\t\t+ ( this.wickets < 10 ? \"/\" + this.wickets : \"\" )\n\t\t\t\t+ ( this.mostRecentInnings ? \" (\" + this.overProgress + \" ov)\"\n\t\t\t\t\t\t: \"\" )\n\t}\n\treturn \"\";\n}"}}},"TeamInnings":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"inningsArray"}]},"Source":"PULSE.UdsScore.prototype.TeamInnings = function( inningsArray )\n{\n\tthis.inningsArray = inningsArray || [];\n}","prototype":{"getScoreString":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.UdsScore.prototype.TeamInnings.prototype.getScoreString = function()\n{\n\tvar string = \"\";\n\n\tfor ( var i = 0; i < this.inningsArray.length; i++ )\n\t{\n\n\t\tvar innings = this.inningsArray[i];\n\n\t\tif ( innings )\n\t\t{\n\t\t\tvar tmpString = innings.getScoreString( );\n\n\t\t\tif( tmpString )\n\t\t\t{\n\t\t\t\tif ( i === 0 )\n\t\t\t\t{\n\t\t\t\t\tstring += tmpString;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstring += \" & \" + tmpString;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\treturn string;\n}"}}},"MatchResult":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"teamsInnings"}]},"Source":"PULSE.UdsScore.prototype.MatchResult = function( teamsInnings )\n{\n\tthis.inningsByTeam = teamsInnings;\n}","prototype":{"inningsPlayed":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.UdsScore.prototype.MatchResult.prototype.inningsPlayed = function()\n{\n\tvar inningsCount = 0;\n\tvar first = this.inningsByTeam[\"1\"];\n\tvar second = this.inningsByTeam[\"2\"];\n\n\tfor ( var key in this.inningsByTeam )\n\t{\n\t\tif ( this.inningsByTeam.hasOwnProperty( key ) )\n\t\t{\n\t\t\tvar team = this.inningsByTeam[key];\n\n\t\t\tif ( team && team.inningsArray )\n\t\t\t{\n\t\t\t\tfor ( var i = 0; i < team.inningsArray.length; i++ )\n\t\t\t\t{\n\t\t\t\t\tvar innings = team.inningsArray[i];\n\n\t\t\t\t\tif ( innings )\n\t\t\t\t\t{\n\t\t\t\t\t\tvar bp = team.inningsArray[i].lastBP;\n\n\t\t\t\t\t\tif ( bp )\n\t\t\t\t\t\t\tinningsCount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn inningsCount;\n}"},"battingFirst":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.UdsScore.prototype.MatchResult.prototype.battingFirst = function()\n{\n\tvar first = this.inningsByTeam[\"1\"];\n\tvar bp = new PULSE.BallProgress( first.inningsArray[0].lastBP );\n\treturn bp.innings === \"1\" ? 0 : 1;\n}"},"followOn":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.UdsScore.prototype.MatchResult.prototype.followOn = function()\n{\n\tvar first = this.inningsByTeam[\"1\"];\n\tvar bp1 = new PULSE.BallProgress( first.inningsArray[0].lastBP );\n\tvar bp2 = new PULSE.BallProgress( first.inningsArray[1].lastBP );\n\treturn ( bp1.innings === \"1\" && bp2.innings === \"4\" || bp1.innings === \"2\"\n\t\t\t&& bp2.innings === \"3\" );\n}"},"getTotalRunsTeam":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"number"}]},"Source":"PULSE.UdsScore.prototype.MatchResult.prototype.getTotalRunsTeam = function(\n\t\tnumber )\n{\n\tvar count = 0;\n\tvar team = this.inningsByTeam[number] || undefined;\n\n\tif ( team )\n\t{\n\t\tfor ( var i = 0; i < team.inningsArray.length; i++ )\n\t\t{\n\t\t\tvar innings = team.inningsArray[i];\n\n\t\t\tif ( innings && innings.runs )\n\t\t\t{\n\t\t\t\tcount += innings.runs;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\t// throw bad param\n\t}\n\treturn count;\n}"},"getWicketsTakenTeam":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"number"}]},"Source":"PULSE.UdsScore.prototype.MatchResult.prototype.getWicketsTakenTeam = function(\n\t\tnumber )\n{\n\tvar count = 0;\n\tvar team = this.inningsByTeam[( number === \"1\" ? \"2\" : \"1\" )] || undefined;\n\n\tif ( team )\n\t{\n\t\tvar i = team.inningsArray.length;\n\n\t\twhile ( i-- )\n\t\t{\n\t\t\tvar innings = team.inningsArray[i];\n\n\t\t\tif ( innings && innings.lastBP )\n\t\t\t{\n\t\t\t\treturn innings.wickets;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count;\n}"}}}}},"CameraPosition":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"PULSE.CameraPosition"},{"title":"param","description":null,"type":null,"name":"altitude"},{"title":"param","description":null,"type":null,"name":"azimuth"},{"title":"param","description":null,"type":null,"name":"distance"}]},"Source":"PULSE.CameraPosition = function ( altitude, azimuth, distance )\n{\n\tthis.altitude = altitude;\n\tthis.azimuth = azimuth;\n\tthis.distance = distance;\n\tthis.offset = { x:0, y:0 };\n}","prototype":{"getXYZ":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.CameraPosition.prototype.getXYZ = function ()\n{\n\tvar ralt = Math.PI * this.altitude / 180;\n\tvar razi = Math.PI * this.azimuth / 180;\n\t\n\tvar base = this.distance * Math.cos( ralt );\n\n\treturn { \n\t\tx: ( -base * Math.sin( razi ) ) + this.offset.x,\n\t\ty: ( base * Math.cos( razi ) ) + this.offset.y,\n\t\tz: this.distance * Math.sin( ralt )\n\t};\n}"},"getRPY":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.CameraPosition.prototype.getRPY = function ()\n{\n\tvar ralt = Math.PI * this.altitude / 180;\n\tvar razi = Math.PI * this.azimuth / 180;\n\tvar result = {};\n\t\n\t// Roll is always zero\n\tresult.r = 0;\n\t\n\t// Pitch is negated camera altitude\n\tresult.p = ( Math.PI / -2 ) - ralt;\n\t\n\t// Yaw is circle-inverse of azimuth\n\tresult.y = razi + Math.PI;\n\t\n\treturn result;\n}"}}},"Color":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"PULSE.Color"},{"title":"param","description":null,"type":null,"name":"spec"}]},"Source":"PULSE.Color = function ( spec )\n{\n\tif ( spec && spec.charAt( 0 ) === '#' )\n\t{\n\t\tif ( spec.length === 4 )\n\t\t{\n\t \t    this.r = 16 * parseInt( spec.charAt( 1 ), 16 );\n\t\t    this.g = 16 * parseInt( spec.charAt( 2 ), 16 );\n\t\t    this.b = 16 * parseInt( spec.charAt( 3 ), 16 );\n\t\t}\n\t\telse if ( spec.length === 7 )\n\t\t{\t\t\t\n\t\t\tthis.r = parseInt( spec.substr( 1, 2 ), 16 );\n\t\t\tthis.g = parseInt( spec.substr( 3, 2 ), 16 );\n\t\t\tthis.b = parseInt( spec.substr( 5, 2 ), 16 );\n\t\t}\n\t}\n}","prototype":{"darken":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.Color.prototype.darken = function ()\n{\n\tvar newColor = new PULSE.Color( '' );\n\tnewColor.r = Math.round( 0.7 * this.r );\n\tnewColor.g = Math.round( 0.7 * this.g );\n\tnewColor.b = Math.round( 0.7 * this.b );\n\treturn newColor;\n}"},"normalise":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.Color.prototype.normalise = function ( )\n{\n\tvar normalised = { r:Math.round( this.r ), g:Math.round( this.g ), b:Math.round( this.b ) };\n\tfor ( var property in normalised )\n\t{\n\t\tif ( normalised[property] > 255 )\n\t\t{\n\t\t\tnormalised[property] = 255;\n\t\t}\n\t\telse if ( normalised[property] < 0 )\n\t\t{\n\t\t\tnormalised[property] = 0;\n\t\t} \n\t}\n\treturn normalised;\n}"},"toCSS":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.Color.prototype.toCSS = function ()\n{\n\tvar n = this.normalise();\n\treturn 'rgb(' + n.r + ',' + n.g + ',' + n.b + ')';\n}"},"toHex":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.Color.prototype.toHex = function ()\n{\n\tvar n = this.normalise();\n\tvar rr = n.r.toString( 16 );\n\tvar gg = n.g.toString( 16 );\n\tvar bb = n.b.toString( 16 );\n\t\n\tif ( rr.length < 2 )\n\t{\n\t\trr = '0' + rr;\n\t}\n\tif ( gg.length < 2 )\n\t{\n\t\tgg = '0' + gg;\n\t}\n\tif ( bb.length < 2 )\n\t{\n\t\tbb = '0' + bb;\n\t}\n\t\n\treturn '#' + rr + gg + bb;\n}"},"toCSSA":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.Color.prototype.toCSSA = function ()\n{\n\tvar n = this.normalise();\n\tif ( this.a )\n\t{\n\t\treturn 'rgba(' + n.r + ',' + n.g + ',' + n.b + ',' + this.a + ')';\t\n\t}\n\t\n\treturn 'rgba(' + n.r + ',' + n.g + ',' + n.b + ',1)';\n}"}},"createColorHtmlSpec":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"spec"}]},"Source":"PULSE.Color.createColorHtmlSpec = function( spec )\n{\n\t//rgb(255,255,255)\n\t//rgba(255,255,255,0.2)\n\t\n\tif ( spec )\n\t{\n\t\tvar arr = spec.split( '(' );\n\t\tif ( arr && arr.length > 1 )\n\t\t{\n\t\t\tvar type = arr[0];\n\t\t\tarr[1] = arr[1].replace( ')', '' ); \n\t\t\tvar vals = arr[1].split( ',' );\n\t\t\tvar color = new PULSE.Color( null );\n\t\t\t\n\t\t\tif ( type === 'rgb' || type === 'rgba' )\n\t\t\t{\n\t\t\t\tcolor.r = parseInt( vals[0] );\n\t\t\t\tcolor.g = parseInt( vals[1] );\n\t\t\t\tcolor.b = parseInt( vals[2] );\n\t\t\t}\n\t\t\t\n\t\t\tif ( type === 'rgba' )\n\t\t\t{\n\t\t\t\tcolor.a = parseFloat( vals[3] );\n\t\t\t}\n\t\t\t\n\t\t\treturn color;\n\t\t}\n\t}\n}"}},"DataMonitor":{"Documentation":{"description":"This class provides a means of querying the given database at specified intervals to\ndetermine whether the data has changed, and if it has, invoke a callback with the data.","tags":[{"title":"param","description":"the monitor interval, in milliseconds","type":null,"name":"interval"},{"title":"param","description":"the database to query","type":null,"name":"db"},{"title":"param","description":"the callback function to invoke when data is updated","type":null,"name":"callback"}]},"Source":"PULSE.DataMonitor = function ( interval, db, callback )\n{\n\tPULSE.Tracer.info( 'DataMonitor created' );\n\n\tthis.interval = interval;\n\tthis.db = db;\n\tthis.callback = callback; \n\tthis.timerId = null;\n\tthis.downloading = true;\n}","prototype":{"start":{"Documentation":{"description":"Starts the monitor.","tags":[]},"Source":"PULSE.DataMonitor.prototype.start = function ()\n{\n\tPULSE.Tracer.info( 'DataMonitor started' );\n\t\n\t// Stop any existing timer\n\tif ( this.timerId !== null )\n\t{\n\t\tthis.stop();\n\t}\n\t\n\t// Start a new timer\n\tvar that = this;\n\t\n\t// Perform an immediate update\n\tthat.onTimer();\n\t\n\t// Then set up the timer\n\tthis.timerId = setInterval( function() { that.onTimer(); }, this.interval );\n}"},"onTimer":{"Documentation":{"description":"Called when the timer is fired.","tags":[]},"Source":"PULSE.DataMonitor.prototype.onTimer = function ()\n{\n\tif ( this.downloading )\n\t{\n\t\tPULSE.Tracer.info( 'DataMonitor timer fired' );\n\t\tvar that = this;\n\t\tthis.db.checkForUpdate( function() { that.db.loadData( that.callback ); } );\n\t}\n}"},"stop":{"Documentation":{"description":"Stops the monitor.","tags":[]},"Source":"PULSE.DataMonitor.prototype.stop = function ()\n{\n\tPULSE.Tracer.info( 'DataMonitor stopped' );\n\n\tclearInterval( this.timerId );\n\tthis.timerId = null;\n}"}}},"Font":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"PULSE.Font"},{"title":"param","description":null,"type":null,"name":"family"},{"title":"param","description":null,"type":null,"name":"size"},{"title":"param","description":null,"type":null,"name":"weight"}]},"Source":"PULSE.Font = function ( family, size, weight )\n{\n\tthis['font-family'] = family;\n\tthis['font-size'] = size;\n\tthis['font-weight'] = weight;\n}"},"HtmlSelect":{"Documentation":{"description":"Create an HtmlSelect object by ID reference.","tags":[]},"Source":"PULSE.HtmlSelect = function ( id, callback, click )\n{\n\t// Obtain HTML Select element\n\tthis.element = document.getElementById( id );\n\tif ( this.element === null )\n\t{\n\t\tPULSE.Tracer.error( 'Could not find an HtmlSelect element with the ID ' + id );\n\t\treturn;\n\t}\n\t\n\t// Obtain the parent div\n\tthis.parent = this.element.parentNode;\n\t\n\tthis.selected = undefined;\n\t\n\t// Apply callback to onChange\n\tvar that = this;\n\t$(this.element).change( function() \n\t{\n\t\tthat.selected = that.element.options[ that.element.selectedIndex ];\n\t\t\n\t\tPULSE.Tracer.info( 'HtmlSelect callback of ' + that.element.id + '=' + that.selected.value );\n\t\tcallback( that.element.id, that.selected.value ); \n\t} );\n\t\n\tif ( click )\n\t{\n\t\t$(this.element).click( click );\n\t}\n\t\n\t// Dummy data setup\n\tthis.setData( [] );\n}","prototype":{"setClassname":{"Documentation":{"description":"Sets the CSS classname for the HtmlSelect's parent div.","tags":[]},"Source":"PULSE.HtmlSelect.prototype.setClassname = function ( classname )\n{\n\tthis.parent.setAttribute( 'class', classname );\n}"},"setSelectedLabel":{"Documentation":{"description":"Sets the selected label in this HTML Select, if we can.","tags":[]},"Source":"PULSE.HtmlSelect.prototype.setSelectedLabel = function ( label )\n{\n\tfor ( var i = 0, limit = this.element.options.length; i < limit; i++ )\n\t{\n\t\tvar item = this.element.options[i];\n\t\tif ( item.text === label )\n\t\t{\n\t\t\tthis.element.selectedIndex = i;\n\t\t\tthis.selected = item;\n\t\t\tbreak;\n\t\t}\n\t}\n}"},"setSelectedValue":{"Documentation":{"description":"Sets the selected value in this HTML Select, if we can.","tags":[]},"Source":"PULSE.HtmlSelect.prototype.setSelectedValue = function ( value )\n{\n\tfor ( var i = 0, limit = this.element.options.length; i < limit; i++ )\n\t{\n\t\tvar item = this.element.options[i];\n\t\tif ( item.value === value )\n\t\t{\n\t\t\tthis.element.selectedIndex = i;\n\t\t\tthis.selected = item;\n\t\t\tbreak;\n\t\t}\n\t}\n}"},"setData":{"Documentation":{"description":"Clears out the current select options and applies new ones. Ensures that any previously-\nselected option is reselected, if it exists. If it doesn't, then show either the first\nor last value (depending on the showLast flag)","tags":[]},"Source":"PULSE.HtmlSelect.prototype.setData = function ( data, showLast )\n{\n\t// Save the data. We only need this to check whether the item exists during a\n\t// setSelectedItem call\n\tthis.data = data;\n\n\t// Save selection\n\tvar selectedLabel = undefined;\n\tif ( this.selected )\n\t{\n\t\tselectedLabel = this.selected.text;\n\t\tif ( !selectedLabel )\n\t\t{\n\t\t\t// IE8/7 do not have a text property\n\t\t\tselectedLabel = this.selected.value;\n\t\t}\n\t}\n\t\n\t// Remove all children currently inside the HTML Select \n\twhile ( this.element.firstChild )\n\t{\n\t\tthis.element.removeChild( this.element.firstChild );\n\t}\n\t\n\t// Add Option children\n\tvar hit = false;\n\tfor ( var i = 0, limit = data.length; i < limit; i++ )\n\t{\n\t\tvar item = data[i];\n\t\t\n\t\t// Extract label and value\n\t\tvar label = item.label;\n\t\tvar value = item.value;\n\t\tif ( value === undefined )\n\t\t{\n\t\t\t// Default value to label\n\t\t\tvalue = label;\n\t\t\titem.value = value;\n\t\t}\n\t\t\n\t\t// Create an option element\n\t\tvar option = PULSE.NewUI.createElement( 'option' );\n\t\t// Set innerText for IE7/8\n        option.innerText = label;\n        // Set text for modern browsers\n        option.text = label;\n\t\toption.value = value;\n\n\t\t// Add option as child of select\n\t\tthis.element.appendChild( option );\n\n\t\t// Check if we have hit the selected label\n\t\tif ( label == selectedLabel ) // Coerce!\n\t\t{\n\t\t\tthis.element.selectedIndex = i;\n\t\t\tthis.selected = option;\n\t\t\thit = true;\n\t\t}\n\t}\n\t\n\t// Try to select the previously-selected label. If there wasn't one, or it no longer\n\t// exists, then just select the first or last item\n\tvar newSelection = false;\n\tif ( !hit ) \n\t{\n\t\tnewSelection = true;\n\t\tif ( data.length > 0 )\n\t\t{\n\t\t\tthis.element.selectedIndex = showLast ? data.length - 1 : 0;\n\t\t\tthis.selected = this.element.options[ this.element.selectedIndex ];\n\t\t}\n\t}\n\t\n\t// Return true if there was a new selection\n\tPULSE.Tracer.info( 'setData resulted in newSelection=' + newSelection );\n\t\n\treturn newSelection;\n}"}}},"Levenshtein":{"bestMatch":{"Documentation":{"description":"Returns the best-matching string in the candidates array when scored\nusing the Levenshtein distance against the input string.\n\nSee http://en.wikipedia.org/wiki/Levenshtein_distance for more info.","tags":[{"title":"param","description":"the array of candidate strings","type":null,"name":"candidates"},{"title":"param","description":"the input string","type":null,"name":"input"}]},"Source":"PULSE.Levenshtein.bestMatch = function ( candidates, input )\n{\n\tvar best;\n\tvar bestScore = PULSE.Levenshtein.MAX_LENGTH + 1;\n\tvar normInput = PULSE.Levenshtein.normalise( input );\n\n\tfor ( var i = 0, j = candidates.length; i < j; i++ )\n\t{\n\t\tvar candidate = candidates[i];\n\t\tvar normCandidate = PULSE.Levenshtein.normalise( candidate ); \n\t\tvar score = PULSE.Levenshtein.score( normInput, normCandidate );\n\t\t\n\t\tif ( score === 0 )\n\t\t{\n\t\t\t// These matched perfectly, so return early\n\t\t\treturn candidate;\n\t\t}\n\t\telse if ( score < bestScore )\n\t\t{\n\t\t\t// This beat the last best score, so save it\n\t\t\tbestScore = score;\n\t\t\tbest = candidate;\n\t\t}\n\t}\n\t\n\treturn best;\n}"},"normalise":{"Documentation":{"description":"Normalises a String to all lower case, no non-letters. Also trims the\nstring to MAX_LENGTH.","tags":[{"title":"param","description":"the input string","type":null,"name":"input"}]},"Source":"PULSE.Levenshtein.normalise = function ( input )\n{\n\tif ( input )\n\t{\n\t\t// Take out non-letters\n\t\tvar ret = input.replace( /[^a-zA-Z]/g, '' );\n\t\t\n\t\t// Lower case\n\t\tret = ret.toLowerCase();\n\t\t\n\t\t// Trim\n\t\tif ( ret.length > PULSE.Levenshtein.MAX_LENGTH )\n\t\t{\n\t\t\tret = ret.substr( 0, PULSE.Levenshtein.MAX_LENGTH );\n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n}"},"score":{"Documentation":{"description":"Internal function to score one string against another using the\nLevenshtein distance.","tags":[{"title":"param","description":"one string","type":null,"name":"s1"},{"title":"param","description":"the other","type":null,"name":"s2"}]},"Source":"PULSE.Levenshtein.score = function ( s1, s2 )\n{\n\tvar i, j, dist = [];\n\tvar s1len = s1.length, s2len = s2.length;\n\t\n    for ( i = 0; i <= s1len; i++ )\n    {\n    \tdist[i] = [];\n    \tdist[i][0] = i;\n    }\n    for ( j = 0; j <= s2len; j++ )\n    {\n        dist[0][j] = j;\n    }\n\n    for ( j = 1; j <= s2len; j++ )\n    {\n        for ( i = 1; i <= s1len; i++ )\n        {\n            if ( s2.charAt( j - 1 ) === s1.charAt( i - 1 ) )\n            {\n                dist[i][j] = dist[i-1][j-1];\n            }\n            else\n            {\n                dist[i][j] = Math.min( Math.min( dist[i-1][j] + 1, dist[i][j-1] + 1),\n                                       dist[i-1][j-1] + 1 );\n            }\n        }\n    }\n    return dist[s1len][s2len];\n}"}},"ManagedDatabase":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"PULSE.ManagedDatabase"},{"title":"param","description":null,"type":null,"name":"name"}]},"Source":"PULSE.ManagedDatabase = function ( name )\n{\n\tvar that = this;\n\tPULSE.ManagedDatabase.prototype.clearQueue = function ()\n\t{\n\t\tthat.outstandingOperations = 0;\n\t\tthat.sql = [];\n\t\tthat.params = [];\n\t\tthat.callback = [];\n\t};\n\t\n\tthis.clearQueue();\n\tthis.db = openDatabase( name, '', '', 1000000 );\n}","prototype":{"clearQueue":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.ManagedDatabase.prototype.clearQueue = function ()\n\t{\n\t\tthat.outstandingOperations = 0;\n\t\tthat.sql = [];\n\t\tthat.params = [];\n\t\tthat.callback = [];\n\t}"},"queueTransaction":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"sql"},{"title":"param","description":null,"type":null,"name":"params"},{"title":"param","description":null,"type":null,"name":"callback"}]},"Source":"PULSE.ManagedDatabase.prototype.queueTransaction = function ( sql, params, callback )\n{\n\tthis.outstandingOperations++;\n\tthis.sql.push( sql );\n\tthis.params.push( params );\n\tthis.callback.push( callback );\n}"},"runTransactions":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.ManagedDatabase.prototype.runTransactions = function ()\n{\n\tfor ( var i = 0, j = this.sql.length; i < j; i++ )\n\t{\n\t\tthis.transaction( this.sql[i], this.params[i], this.callback[i] );\n\t}\n}"},"resolve":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.ManagedDatabase.prototype.resolve = function ()\n{\n\tthis.outstandingOperations--;\n\tif ( this.outstandingOperations === 0 )\n\t{\n\t\tthis.clearQueue();\n\t}\n}"},"transaction":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"sql"},{"title":"param","description":null,"type":null,"name":"params"},{"title":"param","description":null,"type":null,"name":"callback"}]},"Source":"PULSE.ManagedDatabase.prototype.transaction = function ( sql, params, callback )\n{\t\n\tvar that = this;\n\tthis.db.transaction( function ( tx ) { \n\t\ttx.executeSql( sql, params,\n\t\t\tfunction ( tx, result )\n\t\t\t{\n\t\t\t\tcallback( result );\n\t\t\t\tthat.resolve();\n\t\t\t},\n\t\t\tfunction ( tx, error )\n\t\t\t{\n\t\t\t\tPULSE.Tracer.error( 'Error during database operation: ' + error );\n\t\t\t\tthat.resolve();\n\t\t\t}\n\t\t)\n\t} );\n}"},"ready":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.ManagedDatabase.prototype.ready = function ()\n{\n\treturn this.outstandingOperations === 0;\n}"}}},"RaphaelAxis":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"PULSE.RaphaelAxis"},{"title":"param","description":null,"type":null,"name":"title"},{"title":"param","description":null,"type":null,"name":"min"},{"title":"param","description":null,"type":null,"name":"max"},{"title":"param","description":null,"type":null,"name":"start"},{"title":"param","description":null,"type":null,"name":"end"},{"title":"param","description":null,"type":null,"name":"fixed"},{"title":"param","description":null,"type":null,"name":"numLabels"},{"title":"param","description":null,"type":null,"name":"labels"},{"title":"param","description":null,"type":null,"name":"overdraw"},{"title":"param","description":null,"type":null,"name":"shift"},{"title":"param","description":null,"type":null,"name":"titleShift"},{"title":"param","description":null,"type":null,"name":"colour"}]},"Source":"PULSE.RaphaelAxis = function ( title, min, max, start, end, fixed, numLabels, labels, overdraw, shift, titleShift, colour )\n{\n\tthis.title = title;\n\tthis.min = min;\n\tthis.max = max;\n\tthis.configuredMax = max;\n\tthis.start = start;\n\tthis.end = end;\n\tthis.configuredEnd = end;\n\tthis.fixed = fixed;\n\tthis.numLabels = numLabels;\n\tthis.labels = labels;\n\tthis.overdraw \t= overdraw   === undefined ? 0 : overdraw;\n\tthis.shift \t\t= shift \t === undefined ? 0 : shift;\n\tthis.titleShift = titleShift === undefined ? 0 : titleShift;\n    this.colour = colour || '#fff';\n}","prototype":{"project":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"value"}]},"Source":"PULSE.RaphaelAxis.prototype.project = function ( value )\n{\n\t// Clamp the value to within the range\n\tvar clamped = value;\n\tif ( clamped < this.min )\n\t{\n\t\tclamped = this.min;\n\t}\n\tif ( clamped > this.max )\n\t{\n\t\tclamped = this.max;\n\t}\n\n\treturn this.shift + this.start +\n\t\t( ( ( clamped - this.min ) / ( this.max - this.min ) ) * ( this.end - this.start ) );\n}"},"drawTo":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"r"},{"title":"param","description":null,"type":null,"name":"isX"}]},"Source":"PULSE.RaphaelAxis.prototype.drawTo = function ( r, isX )\n{\n\tvar attrs = this.font;\n\tattrs.fill = this.colour;\n\n\tvar path = 'M';\n\tif ( isX )\n\t{\n\t\tpath += this.start + ' ' + this.fixed;\n\t\tpath += 'L' + ( this.end + this.overdraw ) + ' ' + this.fixed;\n\t}\n\telse\n\t{\n\t\tpath += this.fixed + ' ' + this.start;\n\t\tpath += 'L' + this.fixed + ' ' + ( this.end + this.overdraw );\n\t}\n\n\tr.path( path )\n\t .attr( { stroke: this.colour, fill:'none', 'stroke-width':2, 'stroke-linecap':'square' } );\n\n\t// Draw tick labels\n\tvar spacing = Math.round( ( this.max - this.min ) / this.numLabels );\n\n\t// Round spacing to the nearest 10, if we can\n\tvar newSpacing = 10 * ( Math.round( spacing / 10 ) );\n\tif ( newSpacing > 0 )\n\t{\n\t\tspacing = newSpacing;\n\t}\n\n\tfor ( var val = this.min; val <= this.max; val += spacing )\n\t{\n\t\tvar pos = this.project( val );\n\n\t\tvar label = val;\n\t\tif ( this.labels !== undefined && this.labels[ val ] !== undefined )\n\t\t{\n\t\t\tlabel = this.labels[ val ];\n\t\t}\n\n\t\tif ( isX )\n\t\t{\n\t\t\tr.text( pos, PULSE.Browser.y( this.fixed + 9 ), label )\n\t\t\t .attr( attrs );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tr.text( this.fixed - 6, PULSE.Browser.y( pos ), label )\n\t\t\t .attr( attrs ).attr( { 'text-anchor':'end' } );\n\t\t}\n\t}\n\n\t// Draw axis title\n\tvar pos = this.project( ( this.min + this.max ) / 2 );\n\tif ( isX )\n\t{\n\t\tr.text( pos, PULSE.Browser.y( this.fixed + 25 + this.titleShift ), this.title )\n\t\t .attr( attrs );\n\t}\n\telse\n\t{\n\t\tvar x = this.fixed - 37 - this.titleShift;\n\t\tvar y = PULSE.Browser.y( pos );\n\n\t\tr.text( x, y, this.title ).rotate( -90 ).attr( attrs );\n\t}\n}"}}},"RaphaelFlexikey":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"PULSE.RaphaelFlexikey"},{"title":"param","description":null,"type":null,"name":"config"}]},"Source":"PULSE.RaphaelFlexikey = function ( config )\n{\n\tthis.entries = [];\n\tthis.config = config;\n}","prototype":{"addEntry":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"label"},{"title":"param","description":null,"type":null,"name":"color"}]},"Source":"PULSE.RaphaelFlexikey.prototype.addEntry = function ( label, color )\n{\n\tthis.entries.push( { label:label, color:color } );\n}"},"render":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"r"}]},"Source":"PULSE.RaphaelFlexikey.prototype.render = function ( r )\n{\n\t// Create a set to group all Raphael components\n\tvar set = r.set();\n\n\t// Calculate the size of the flexikey\n\tvar height = this.config.margin.top;\n\tvar width = this.config.margin.left;\n\n\tvar maxWidth = 0;\n\tvar sheight = 0;\n\n\t// Create background and add it to the set\n\tvar bg = r.rect()\n    \t\t  .attr( { fill:this.config.background.color, stroke:'none',\n    \t\t\t  \t   opacity:this.config.background.opacity } );\n\tset.push( bg );\n\n\t// Create common label attributes\n\tvar attrs = this.config.font;\n\tattrs.fill = this.config.colour || '#fff';\n\tattrs.stroke = 'none';\n\tattrs['text-anchor'] = 'start';\n\tattrs.x = width + this.config.swatch.size + this.config.swatch.spacing;\n\n\t// Iterate over labels, adding text objects and calculating overall size\n\tvar y = this.config.margin.top + ( this.config.spacing * 1.5 );\n\tfor ( var i = 0, j = this.entries.length; i < j; i++ )\n\t{\n\t\tvar entry = this.entries[i];\n\n\t\tattrs.y = PULSE.Browser.y( y );\n\n\t\t// Add label\n\t\tvar label = r.text( 0, 0, entry.label ).attr( attrs );\n\t\tset.push( label );\n\n\t\tvar ss = label.getBBox();\n\n\t\theight += ss.height + this.config.spacing;\n\t\tsheight = ss.height;\n\n\t\tif ( ss.width > maxWidth )\n\t\t{\n\t\t\tmaxWidth = ss.width;\n\t\t}\n\n\t\t// Add swatch\n\t\tvar swatch = r.circle( this.config.margin.left + ( this.config.swatch.size / 2 ), y,\n\t\t\t\t               this.config.swatch.size / 2 )\n\t\t  \t\t \t  .attr( { fill:entry.color, stroke:'none' } );\n\t\tset.push( swatch );\n\n\t\ty += ss.height + this.config.spacing;\n\t}\n\n\t// Update size of background\n\theight += this.config.margin.bottom - this.config.spacing;\n\twidth += this.config.swatch.size + this.config.swatch.spacing + maxWidth + this.config.margin.right;\n\n\tbg.attr( { width:width, height:height } );\n\n\t// Calculate new origin\n\tvar origin = Utils.adjustForAnchor( this.config.position.x, this.config.position.y,\n\t\t\t   { width:width, height:height }, this.config.position.anchor );\n\n\t// Move all components to new origin\n\tset.translate( origin.x, origin.y );\n}"}}},"RaphaelNonLinearAxis":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"PULSE.RaphaelNonLinearAxis"},{"title":"param","description":null,"type":null,"name":"title"},{"title":"param","description":null,"type":null,"name":"min"},{"title":"param","description":null,"type":null,"name":"max"},{"title":"param","description":null,"type":null,"name":"start"},{"title":"param","description":null,"type":null,"name":"end"},{"title":"param","description":null,"type":null,"name":"fixed"},{"title":"param","description":null,"type":null,"name":"numLabels"},{"title":"param","description":null,"type":null,"name":"spec"},{"title":"param","description":null,"type":null,"name":"labels"},{"title":"param","description":null,"type":null,"name":"colour"}]},"Source":"PULSE.RaphaelNonLinearAxis = function ( title, min, max, start, end, fixed, numLabels, spec, labels, colour )\n{\n\tthis.title = title;\n\tthis.min = min;\n\tthis.max = max;\n\tthis.start = start;\n\tthis.end = end;\n\tthis.fixed = fixed;\n\tthis.numLabels = numLabels;\n\tthis.spec = spec;\n\tthis.labels = labels;\n    this.colour = colour;\n\n\tthis.overdraw = 0;\n\tthis.shift = 0;\n\tthis.titleShift = 0;\n}","prototype":{"project":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"value"}]},"Source":"PULSE.RaphaelNonLinearAxis.prototype.project = function ( value )\n{\n\t// Clamp the value to within the range\n\tvar clamped = value;\n\tif ( clamped < this.min )\n\t{\n\t\tclamped = this.min;\n\t}\n\tif ( clamped > this.max )\n\t{\n\t\tclamped = this.max;\n\t}\n\n\t// Now apply the non-linear spec\n\tvar proportion;\n\tfor ( var i = 1, j = this.spec.length; i < j; i++ )\n\t{\n\t\tvar limit = this.spec[i][0];\n\t\tvar fraction = this.spec[i][1];\n\n\t\tif ( clamped <= limit )\n\t\t{\n\t\t\t// Add the fraction from the previous limit\n\t\t\tproportion = this.spec[i-1][1];\n\n\t\t\t// Add the proportional size in this limit\n\t\t\tvar dx = this.spec[i][0] - this.spec[i-1][0];\n\t\t\tvar xx = clamped - this.spec[i-1][0];\n\t\t\tvar dy = this.spec[i][1] - this.spec[i-1][1];\n\n\t\t\tproportion += ( xx / dx ) * dy;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn this.start + ( proportion * ( this.end - this.start ) );\n}"}}},"RaphaelTextField":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"PULSE.RaphaelTextField"},{"title":"param","description":null,"type":null,"name":"config"}]},"Source":"PULSE.RaphaelTextField = function ( config )\n{\n\tthis.lines = [];\n\tthis.config = config;\n\t\n\tthis.additional = {};\n\tthis.additional.height = 0;\n\tthis.additional.width = 0;\n}","prototype":{"addLine":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"line"}]},"Source":"PULSE.RaphaelTextField.prototype.addLine = function ( line )\n{\n\tthis.lines.push( line );\n}"},"setLines":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"lines"}]},"Source":"PULSE.RaphaelTextField.prototype.setLines = function ( lines )\n{\n\tthis.lines = lines;\n}"},"fallsWithin":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"xy"}]},"Source":"PULSE.RaphaelTextField.prototype.fallsWithin = function ( xy )\n{\n\treturn xy.x >= this.bounds.x && xy.x <= ( this.bounds.x + this.bounds.width ) &&\n\t       xy.y >= this.bounds.y && xy.y <= ( this.bounds.y + this.bounds.height );\n}"},"render":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"r"},{"title":"param","description":null,"type":null,"name":"set"}]},"Source":"PULSE.RaphaelTextField.prototype.render = function ( r, set )\n{\n\t// Calculate the size of the container\n\tvar height = this.config.margin.top;\n\tvar width = this.config.margin.left;\n\tvar texts = [];\n\tvar bg = r.rect();\n\t\n\tset.push( bg );\n\t\n\tvar maxWidth = 0;\n\tvar sheight = 0;\n\tvar y = this.config.margin.top + ( this.config.spacing * 2 );\n\t\n\tfor ( var i = 0, j = this.lines.length; i < j; i++ )\n\t{\n\t\tvar lineWidth = 0;\n\t\tvar components = PULSE.RaphaelTextField.getTextComponents( this.lines[i] );\n\n\t\tfor ( var c = 0, climit = components.length; c < climit; c++ )\n\t\t{\n\t\t\tvar attrs = this.config.font;\n\t\t\tattrs['text-anchor'] = 'start';\n\t\t\tattrs.stroke = 'none';\n\t\t\tattrs.fill = components[c].color ? components[c].color : '#fff';\n\t\t\tattrs.x = this.config.margin.left + lineWidth;\n\t\t\tattrs.y = PULSE.Browser.y( y );\n\n\t\t\tvar text = r.text( 0, 0, components[c].text )\n\t\t\t            .attr( attrs ); \n\t\t\ttexts.push( text );\n\t\t\tset.push( text );\n\t\t\t\n\t\t\tvar bb = text.getBBox();\n\t\t\tsheight = bb.height;\n\t\t\t\n\t\t\tlineWidth += bb.width;\n\t\t\tif ( ( components[c].text.charAt(components[c].text.length-1) === ' ' ) \n\t\t\t\t\t&& PULSE.Browser && PULSE.Browser.addSpacer )\n\t\t\t{\n\t\t\t\tlineWidth += ( bb.width / components[c].text.length ) * 0.75;\n\t\t\t}\n\t\t}\n\n\t\tif ( lineWidth > maxWidth )\n\t\t{\n\t\t\tmaxWidth = lineWidth;\n\t\t\tbg.attr( { width:maxWidth } );\n\t\t}\t\t\t\n\t\t\n\t\theight += ( bb ? bb.height : 0 ) + this.config.spacing;\n\t\ty += sheight + this.config.spacing;\n\t}\n\t\n\theight += this.config.margin.bottom - this.config.spacing + this.additional.height;\n\twidth += maxWidth + this.config.margin.right + this.additional.width;\n\t\n\t// Position the background\n\tbg.attr( { x:0, y:0, width:width, height:height, \n\t\t       fill:this.config.background.color, opacity:this.config.background.opacity } );\n\t\n\t// Draw the optional border\n\tif ( this.config.border )\n\t{\n\t\tset.push( r.rect( 0, 0, width, height )\n\t\t\t\t   .attr( { 'stroke-width':this.config.border.width, stroke:this.config.border.color,\n\t\t\t\t\t        opacity:this.config.border.opacity } ) );\n\t\t\n\t\t// Draw the optional anchor indicator\n\t\tif ( this.config.border.indicator > 0 )\n\t\t{\n\t\t\tvar points = [];\n\t\t\tswitch ( this.config.position.anchor )\n\t\t\t{\n\t\t\t\tcase 'nw':\n\t\t\t\t\tpoints = [ { x:0, y:this.config.border.indicator }, \n\t\t\t\t\t           { x:0, y:0 }, \n\t\t\t\t\t           { x:this.config.border.indicator, y:0 } ];\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'ne':\n\t\t\t\t\tpoints = [ { x:0 + width - this.config.border.indicator, y:0 }, \n\t\t\t\t\t           { x:0 + width, y:0 }, \n\t\t\t\t\t           { x:0 + width, y:this.config.border.indicator } ];\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'se':\n\t\t\t\t\tpoints = [ { x:0 + width - this.config.border.indicator, y:height }, \n\t\t\t\t\t           { x:0 + width, y:height }, \n\t\t\t\t\t           { x:0 + width, y:height - this.config.border.indicator } ];\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'sw':\n\t\t\t\t\tpoints = [ { x:0, y:height - this.config.border.indicator }, \n\t\t\t\t\t           { x:0, y:height }, \n\t\t\t\t\t           { x:0 + this.config.border.indicator, y:height } ];\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tvar path = '';\n\t\t\tfor ( var p = 0, plimit = points.length; p < plimit; p++ )\n\t\t\t{\n\t\t\t\tvar point = points[p];\n\t\t\t\tif ( p === 0 )\n\t\t\t\t{\n\t\t\t\t\tpath += 'M';\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpath += 'L';\n\t\t\t\t}\n\t\t\t\tpath += point.x;\n\t\t\t\tpath += ' ';\n\t\t\t\tpath += point.y;\n\t\t\t}\n\t\t\t\n\t\t\tset.push( r.path( path + 'z' ).attr( { fill:this.config.border.color,\n\t\t\t\t                                   opacity:this.config.border.opacity,\n\t\t\t\t                                   stroke:'none' } ) );\n\t\t}\n\t}\n\t\n\t// Move everthing to the correct position\n\tvar origin = Utils.adjustForAnchor( this.config.position.x, this.config.position.y,\n\t\t\t           { width:width, height:height }, this.config.position.anchor );\n\tset.translate( origin.x, origin.y );\n\t\n\t// Save bounds\n\tthis.bounds = { x:origin.x, y:origin.y, width:width, height:height };\n}"},"setHighlight":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"hl"},{"title":"param","description":null,"type":null,"name":"ctx"}]},"Source":"PULSE.RaphaelTextField.prototype.setHighlight = function ( hl, ctx )\n{\n\tctx.save();\n\tctx.lineWidth = hl ? this.config.hlborder.width : this.config.border.width;\n\tctx.strokeStyle = hl ? this.config.hlborder.color : this.config.border.color;\n\tctx.beginPath();\n\tctx.rect( this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height );\n\tctx.stroke();\n\tctx.restore();\n}"}},"getTextComponents":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"string"}]},"Source":"PULSE.RaphaelTextField.getTextComponents = function ( string )\n{\n\tvar components = [];\n\t\n\tvar scan = 0;\n\tvar more = true;\n\n\twhile ( more )\n\t{\n\t\tvar fragment = string.substring( scan );\n\t\tvar color = undefined;\n\t\t\n\t\tvar tagStart = string.indexOf( '<c:', scan );\n\t\tif ( tagStart !== -1 )\n\t\t{\t\n\t\t\tvar tagClose = string.indexOf( '>', tagStart );\n\t\t\tvar tagEnd = string.indexOf( '</c>', tagStart );\n\t\t\t\n\t\t\tvar color = string.substring( tagStart + 3, tagClose );\n\t\t\tfragment = string.substring( tagClose + 1, tagEnd );\n\n\t\t\t// Draw the prefragment\n\t\t\tvar preFragment = string.substring( scan, tagStart );\n\t\t\t\n\t\t\tif ( preFragment.length > 0 )\n\t\t\t{\n\t\t\t\tcomponents.push( { text:preFragment } );\n\t\t\t}\n\t\t\t\n\t\t\tscan = tagEnd + 4;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmore = false;\n\t\t}\n\t\t\n\t\tif ( fragment.length > 0 )\n\t\t{\n\t\t\tcomponents.push( { text:fragment, color:color } );\n\t\t}\n\t}\n\t\n\treturn components;\n}"}},"SelectorList":{"Documentation":{"description":"Constructor.","tags":[{"title":"param","description":"the id of the div, which is expected to exist already","type":null,"name":"id"},{"title":"param","description":"the callback function, taking id and value arguments","type":null,"name":"callback"}]},"Source":"PULSE.SelectorList = function ( id, callback )\n{\n\t// Set up scroll behavioural constants\n\tPULSE.SelectorList.SCROLLING = { threshold:12,\n\t\t\t\t\t\t\t\t\t met:    { activeClass:'activeDD',      lastClass:'' },\n\t\t\t\t\t\t\t\t\t notmet: { activeClass:'activeSmallDD', lastClass:'last' } };\n\t\n\tvar that = this;\n\t\n\t// Obtain the div from the DOM\n\tthis.div = document.getElementById( id );\n\tif ( this.div === null )\n\t{\n\t\tPULSE.Tracer.error( 'Could not find a SelectorList element with the ID ' + id );\n\t\treturn;\n\t}\n\t\n\t// Obtain reference to parent LI, if it has been tagged\n\tthis.li = document.getElementById( id + 'Li' );\n\t\n\t// Nothing yet selected\n\tthis.selected = null;\n\tthis.expanded = false;\n\t\n\t// Save selection callback\n\tthis.callback = callback;\n\t\n\t// Create toplink, ul-containing div and ul itself\n\tthis.topLink = PULSE.NewUI.createElement( 'a', { 'class':'button' } );\n\tthis.topLink.addEventListener( 'click', function() { that.onTopLink( this.item ); }, false );\n\n\t// Build container divs\n\tvar outerDiv = PULSE.NewUI.createElement( 'div', { 'class':'dropCntr' } );\n\tthis.innerDiv = PULSE.NewUI.createElement( 'div', { 'class':'dropCntrInner' } );\n\tvar scrollIndicator = PULSE.NewUI.createElement( 'div', { 'class':'scrollIndicator' } );\n\t\n\touterDiv.appendChild( this.innerDiv );\n\touterDiv.appendChild( scrollIndicator );\n\t\n\t// Build a new list to populate the drop-down\n\tthis.ul = PULSE.NewUI.createElement( 'ul' );\n\n\t// Add ul to innerDiv\n\tthis.innerDiv.appendChild( this.ul );\n\t\n\t// Add the drop-down link\n\tthis.div.appendChild( this.topLink );\n\tthis.div.appendChild( outerDiv );\n\t\n\t// Setup touch scrolling if we need to\n\tif ( isiPad() )\n\t{\n\t\tif ( !TouchScroll )\n\t\t{\n\t\t\tPULSE.Tracer.error( 'No TouchScroll support found' );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.touchScroll = new TouchScroll( this.innerDiv, { elastic:false } );\n\t    } \n\t}\t\t\n\t\n\t// Dummy data setup\n\tthis.setData( [] );\n}","prototype":{"setData":{"Documentation":{"description":"Sets the data displayed by this SelectorList.","tags":[{"title":"param","description":"an array of selectable objects, each having at least a label property, plus\nan optional value property.","type":null,"name":"data"}]},"Source":"PULSE.SelectorList.prototype.setData = function ( data )\n{\n\tthis.scrollBehaviour = \n\t\t( data !== undefined && data.length >= PULSE.SelectorList.SCROLLING.threshold ) ?\n\t\tPULSE.SelectorList.SCROLLING.met : PULSE.SelectorList.SCROLLING.notmet;\n\t\n\t// Save the data. We only need this to check whether the item exists during a\n\t// setSelectedItem call\n\tthis.data = data;\n\t\n\tvar that = this;\n\tvar hit = false;\n\t\n\t// Remove all children currently inside the ul \n\twhile ( this.ul.firstChild )\n\t{\n\t\tthis.ul.removeChild( this.ul.firstChild );\n\t}\n\n\t// Setup callback\n\tvar f = function() { that.onSelect( this.item ); };\n\t\n\t// Add li children, each containing an anchor, to the ul\n\tfor ( var i = 0, j = data.length; i < j; i++ )\n\t{\n\t\tvar item = data[i];\n\t\t\n\t\t// Extract label and value\n\t\tvar label = item.label;\n\t\tvar value = item.value;\n\t\tif ( value === undefined )\n\t\t{\n\t\t\t// Default value to label\n\t\t\tvalue = label;\n\t\t\titem.value = value;\n\t\t}\n\t\t\n\t\t// Check if we have hit the selected item\n\t\tif ( this.selected !== null && label == this.selected.label )\n\t\t{\n\t\t\thit = true;\n\t\t}\n\t\t\n\t\t// Create anchor\n\t\tvar a = PULSE.NewUI.createElement( 'a' );\n\t\ta.item = item;\n\t\ta.addEventListener( 'click', f, false );\n\t\ta.innerHTML = label;\n\t\t\n\t\tvar li = document.createElement( 'li' );\n\t\tif ( i === j - 1 && !Utils.isNullish( this.scrollBehaviour.lastClass ) )\n\t\t{\n\t\t\tli.setAttribute( 'class', this.scrollBehaviour.lastClass );\n\t\t}\n\t\t\n\t\tli.appendChild( a );\n\t\tthis.ul.appendChild( li );\n\t}\n\t\n\t// Try to select the previously-selected label. If there wasn't one, or it no longer\n\t// exists, then just select the first item\n\tvar newSelection = false;\n\tif ( this.selected === null || !hit ) \n\t{\n\t\tnewSelection = true;\n\t\tif ( data.length > 0 )\n\t\t{\n\t\t\tthis.selected = data[0];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.selected = null;\n\t\t}\n\t}\n\t\n\t// Update the top link\n\tif ( this.selected !== null )\n\t{\n\t\tthis.topLink.innerHTML = this.selected.label;\n\t}\n\t\t\n\t// Reset touch scroller\n\tif ( this.touchScroll )\n\t{\n\t\twhile ( this.innerDiv.firstChild )\n\t\t{\n\t\t\tthis.innerDiv.removeChild( this.innerDiv.firstChild );\n\t\t}\n\t\tthis.innerDiv.appendChild( this.ul );\n\t\tthis.innerDiv.setAttribute( 'class', 'dropCntrInner' );\n\t\tthis.touchScroll = new TouchScroll( this.innerDiv, { elastic:false } );\n\t}\n\t\n\t// Return true if there was a new selection\n\treturn newSelection;\n}","f":{"Documentation":{"description":"Sets the data displayed by this SelectorList.","tags":[{"title":"param","description":"an array of selectable objects, each having at least a label property, plus\nan optional value property.","type":null,"name":"data"}]},"Source":"var f = function() { that.onSelect( this.item ); }"}},"onSelect":{"Documentation":{"description":"Called when a value in a dropdown is selected.","tags":[]},"Source":"PULSE.SelectorList.prototype.onSelect = function ( item )\n{\n\tthis.topLink.innerHTML = item.label;\n\tthis.selected = item;\n\t\n\tthis.callback( this.div.id, item.value );\n}"},"onTopLink":{"Documentation":{"description":"Called when a top link is selected.","tags":[]},"Source":"PULSE.SelectorList.prototype.onTopLink = function ( item )\n{\n\tthis.callback( this.div.id );\n}"},"setExpanded":{"Documentation":{"description":"Sets the expanded state of this selector.","tags":[]},"Source":"PULSE.SelectorList.prototype.setExpanded = function ( expanded )\n{\n\tthis.expanded = expanded;\n\tthis.div.setAttribute( 'class', 'dropdowncntr' + \n\t\t\t( expanded ? ' ' + this.scrollBehaviour.activeClass : '' ) );\n\tif ( expanded && this.touchScroll )\n\t{\n\t\tthis.touchScroll.setupScroller( true );\n\t}\n}"},"setSelectedItem":{"Documentation":{"description":"Sets the selected item in this selector. This is a no-op if the item does not exist.","tags":[]},"Source":"PULSE.SelectorList.prototype.setSelectedItem = function ( value )\n{\n\tfor ( var i = 0, j = this.data.length; i < j; i++ )\n\t{\n\t\tif ( this.data[i].value === value )\n\t\t{\n\t\t\tthis.topLink.innerHTML = this.data[i].label;\n\t\t\tthis.selected = this.data[i];\n\t\t\tbreak;\n\t\t}\n\t}\n}"}}},"TextDataDiv":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"PULSE.TextDataDiv"},{"title":"param","description":null,"type":null,"name":"dataDivConfig"},{"title":"param","description":null,"type":null,"name":"config"}]},"Source":"PULSE.TextDataDiv = function ( dataDivConfig, config )\n{\n\tthis.lines = [];\n\tthis.dataDivConfig = dataDivConfig;\n\tthis.config = config;\n\tthis.containerDiv = document.createElement( 'div' );\n\t\n\tthis.applyConfig();\n}","prototype":{"applyConfig":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.TextDataDiv.prototype.applyConfig = function()\n{\n\tthis.containerDiv.setAttribute( 'id', this.config.id );\n\tthis.containerDiv.setAttribute( 'class', this.config.classes );\n}"},"setContent":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"innerHTML"}]},"Source":"PULSE.TextDataDiv.prototype.setContent = function( innerHTML )\n{\n\tthis.containerDiv.innerHTML = Utils.toHTML( innerHTML );\t\n}"},"setPosition":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"dataDiv"}]},"Source":"PULSE.TextDataDiv.prototype.setPosition = function( dataDiv )\n{\n//\twindow.alert( 'in setPosition' );\n\t\n//\twindow.alert( 'dataDiv = ' + dataDiv );\n\tvar ddWidth = dataDiv.offsetWidth;\n\tvar ddHeight = dataDiv.offsetHeight;\n\t\n\t// grid elements dimensions\n//\twindow.alert( 'dataDivConfig=' + this.dataDivConfig );\n\t\n\tvar colSize = Math.round( ddWidth / this.dataDivConfig.cols );\n\tvar rowSize = Math.round( ddHeight / this.dataDivConfig.rows );\n\t\n//\twindow.alert( 'after col and row size' );\n\t\n\t//position of the div in the grid\n\tvar colPos = this.config.position.col;\n\tvar rowPos = this.config.position.row;\n\t\n\t// apply anchor\n\tvar anchor = this.config.position.anchor;\n\t\n\t// inital position of the div relative to the container\n\tvar position = { \t\t\t\n\t\t\t\tx : colSize * colPos,\n\t\t\t\ty : rowSize * rowPos\t\t\t\n\t\t\t};\n\t\n\tvar height = this.containerDiv.offsetHeight;\n\tvar width = this.containerDiv.offsetWidth;\t\n\t\n//\twindow.alert( 'before anchor' );\n\n\tswitch ( anchor )\n\t{\n\t\tcase 'n':\n\t\t\tposition.x += Math.round( colSize/2 - width/2 );\n\t\t\tbreak;\n\t\t\t\n\t\tcase 'e':\n\t\t\tposition.x += colSize - width;\n\t\t\tposition.y += Math.round( rowSize/2 - height/2 );\n\t\t\tbreak;\n\t\t\t\n\t\tcase 's':\n\t\t\tposition.x += Math.round( colSize/2 - width/2 );\n\t\t\tposition.y += rowSize - height;\n\t\t\tbreak;\n\t\t\t\n\t\tcase 'w':\n\t\t\tposition.y += Math.round( rowSize/2 - height/2 );\t\t\t\n\t\t\tbreak;\n\t\t\t\n\t\tcase 'nw':\n//\t\t\tposition.x += marginLeft;\n//\t\t\tposition.y += marginTop;\n\t\t\tbreak;\n\t\t\t\n\t\tcase 'ne':\n\t\t\tposition.x += colSize - width;\n//\t\t\tposition.y += marginTop;\n\t\t\tbreak;\n\t\t\t\n\t\tcase 'se':\n\t\t\tposition.x += colSize - width;\n\t\t\tposition.y += rowSize - height;\n\t\t\tbreak;\n\t\t\t\n\t\tcase 'sw':\n//\t\t\tposition.x += marginLeft;\n\t\t\tposition.y += rowSize - height;\n\t\t\tbreak;\n\t\t\t\n\t\tcase 'c':\n\t\t\tposition.x += Math.round( colSize/2 - width/2 );\n\t\t\tposition.y += Math.round( rowSize/2 - height/2 );\n\t}\n\t\n\tvar ref = this.containerDiv.style; \n\tif ( !ref )\n\t{ \n\t\tref = this.containerDiv;\n\t}\t\n\tref.left = position.x + 'px';\n\tref.top = position.y + 'px';\t\n\t\n//\twindow.alert( 'end of setPosition' );\n}"}},"setChildrenFromTextDataDivs":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"textDataDivs"},{"title":"param","description":null,"type":null,"name":"parent"}]},"Source":"PULSE.TextDataDiv.setChildrenFromTextDataDivs = function( textDataDivs, parent )\n{\n\t// Remove all children\n\tUtils.clearContent( parent );\n\t\n\tfor ( var i = 0, limit = textDataDivs.length; i < limit; i++ )\n\t{\n\t\tparent.appendChild( textDataDivs[ i ].containerDiv );\n\t}\n}"},"clearTextDataDivs":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"textDataDivs"}]},"Source":"PULSE.TextDataDiv.clearTextDataDivs = function( textDataDivs )\n{\n\tfor ( var i = 0, limit = textDataDivs.length; i < limit; i++ )\n\t{\n\t\ttextDataDivs[ i ].setContent( '' );\n\t}\n}"},"updateTextDataDivsPosition":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"textDataDivs"},{"title":"param","description":null,"type":null,"name":"dataDiv"}]},"Source":"PULSE.TextDataDiv.updateTextDataDivsPosition = function( textDataDivs, dataDiv )\n{\n\t// Update div containers position\n\tfor ( var i = 0, limit = textDataDivs.length; i < limit; i++ )\n\t{\n\t\ttextDataDivs[ i ].setPosition( dataDiv );\n\t}\n}"},"setDefaultValsDataDivs":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"textDataDivs"}]},"Source":"PULSE.TextDataDiv.setDefaultValsDataDivs = function( textDataDivs )\n{\n\tvar value = null;\n\tfor ( var i = 0, limit = textDataDivs.length; i < limit; i++ )\n\t{\n\t\tvalue = textDataDivs[ i ].config.value;\n\t\tif ( value )\n\t\t{\n\t\t\ttextDataDivs[ i ].setContent( value );\n\t\t}\t\t\n\t}\t\n}"}},"TextField":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"PULSE.TextField"},{"title":"param","description":null,"type":null,"name":"config"}]},"Source":"PULSE.TextField = function ( config )\n{\n\tthis.lines = [];\n\tthis.config = config;\n\t\n\tthis.additional = {};\n\tthis.additional.height = 0;\n\tthis.additional.width = 0;\n}","prototype":{"addLine":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"line"}]},"Source":"PULSE.TextField.prototype.addLine = function ( line )\n{\n\tthis.lines.push( line );\n}"},"setLines":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"lines"}]},"Source":"PULSE.TextField.prototype.setLines = function ( lines )\n{\n\tthis.lines = lines;\n}"},"fallsWithin":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"xy"}]},"Source":"PULSE.TextField.prototype.fallsWithin = function ( xy )\n{\n\treturn xy.x >= this.bounds.x && xy.x <= ( this.bounds.x + this.bounds.width ) &&\n\t       xy.y >= this.bounds.y && xy.y <= ( this.bounds.y + this.bounds.height );\n}"},"render":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"ctx"}]},"Source":"PULSE.TextField.prototype.render = function ( ctx )\n{\n\tctx.save();\n\tctx.font = this.config.font;\n\t\n\t// Calculate the size of the flexikey\n\tvar height = this.config.margin.top;\n\tvar width = this.config.margin.left;\n\t\n\tvar maxWidth = 0;\n\tvar sheight = 0;\n\tfor ( var i = 0, j = this.lines.length; i < j; i++ )\n\t{\n\t\tvar line = this.lines[i];\n\t\tvar ss = Utils.stringSize( ctx, line );\n\t\t\n\t\theight += ss.height + this.config.spacing;\n\t\tsheight = ss.height;\n\t\t\n\t\tif ( ss.width > maxWidth )\n\t\t{\n\t\t\tmaxWidth = ss.width;\n\t\t}\n\t}\n\t\n\theight += this.config.margin.bottom - this.config.spacing + this.additional.height;\n\twidth += maxWidth + this.config.margin.right + this.additional.width;\n\n\tvar origin = Utils.adjustForAnchor( this.config.position.x, this.config.position.y,\n\t\t\t  { width:width, height:height }, this.config.position.anchor );\n\t\n\t// Draw the background\n\t//ctx.save();\n\tctx.beginPath();\n\tctx.fillStyle = this.config.background;\n\tctx.rect( origin.x, origin.y, width, height );\n\tctx.fill();\n\t//ctx.restore();\n\t\n\t// Draw each key entry\n\tvar x = origin.x + this.config.margin.left;\n\tvar y = origin.y + this.config.margin.top + ( sheight / 2 );\n\t\n\tctx.fillStyle = 'white';\n\tfor ( var i = 0, j = this.lines.length; i < j; i++ )\n\t{\n\t\tthis.drawString( ctx, this.lines[i], x, y );\n\t\ty += sheight + this.config.spacing;\n\t}\n\t\n\t// Draw the optional border\n\tif ( this.config.border )\n\t{\n\t\tctx.lineWidth = this.config.border.width;\n\t\tctx.strokeStyle = this.config.border.color;\n\t\tctx.beginPath();\n\t\tctx.rect( origin.x, origin.y, width, height );\n\t\tctx.stroke();\n\n\t\t// Draw the optional anchor indicator\n\t\tif ( this.config.border.indicator > 0 )\n\t\t{\n\t\t\tvar points = [];\n\t\t\tswitch ( this.config.position.anchor )\n\t\t\t{\n\t\t\t\tcase 'nw':\n\t\t\t\t\tpoints = [ { x:origin.x, y:origin.y + this.config.border.indicator }, \n\t\t\t\t\t           { x:origin.x, y:origin.y }, \n\t\t\t\t\t           { x:origin.x + this.config.border.indicator , y:origin.y } ];\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'ne':\n\t\t\t\t\tpoints = [ { x:origin.x + width - this.config.border.indicator, y:origin.y }, \n\t\t\t\t\t           { x:origin.x + width, y:origin.y }, \n\t\t\t\t\t           { x:origin.x + width, y:origin.y + this.config.border.indicator } ];\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'se':\n\t\t\t\t\tpoints = [ { x:origin.x + width - this.config.border.indicator, y:origin.y + height }, \n\t\t\t\t\t           { x:origin.x + width, y:origin.y + height }, \n\t\t\t\t\t           { x:origin.x + width, y:origin.y + height - this.config.border.indicator } ];\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'sw':\n\t\t\t\t\tpoints = [ { x:origin.x, y:origin.y + height - this.config.border.indicator }, \n\t\t\t\t\t           { x:origin.x, y:origin.y + height }, \n\t\t\t\t\t           { x:origin.x + this.config.border.indicator, y:origin.y + height } ];\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tctx.fillStyle = this.config.border.color;\n\t\t\tUtils.polygon( ctx, points );\n\t\t\tctx.fill();\n\t\t}\n\t}\n\t\n\tctx.restore();\n\t\n\t// Save bounds\n\tthis.bounds = { x:origin.x, y:origin.y, width:width, height:height };\n}"},"setHighlight":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"hl"},{"title":"param","description":null,"type":null,"name":"ctx"}]},"Source":"PULSE.TextField.prototype.setHighlight = function ( hl, ctx )\n{\n\tctx.save();\n\tctx.lineWidth = hl ? this.config.hlborder.width : this.config.border.width;\n\tctx.strokeStyle = hl ? this.config.hlborder.color : this.config.border.color;\n\tctx.beginPath();\n\tctx.rect( this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height );\n\tctx.stroke();\n\tctx.restore();\n}"},"drawString":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"ctx"},{"title":"param","description":null,"type":null,"name":"string"},{"title":"param","description":null,"type":null,"name":"x"},{"title":"param","description":null,"type":null,"name":"y"}]},"Source":"PULSE.TextField.prototype.drawString = function ( ctx, string, x, y )\n{\n\tvar standardColor = ctx.fillStyle;\n\t\n\tvar xx = x;\n\tvar scan = 0;\n\tvar more = true;\n\n\twhile ( more )\n\t{\n\t\tvar fragment = string.substring( scan );\n\t\t\n\t\tvar tagStart = string.indexOf( '<c:', scan );\n\t\tif ( tagStart !== -1 )\n\t\t{\t\n\t\t\tvar tagClose = string.indexOf( '>', tagStart );\n\t\t\tvar tagEnd = string.indexOf( '</c>', tagStart );\n\t\t\t\n\t\t\tvar color = string.substring( tagStart + 3, tagClose );\n\t\t\tfragment = string.substring( tagClose + 1, tagEnd );\n\n\t\t\t// Draw the prefragment\n\t\t\tvar preFragment = string.substring( scan, tagStart );\n\t\t\tctx.fillStyle = standardColor;\n\t\t\tctx.beginPath();\n\t\t\tUtils.anchoredFillText( ctx, preFragment, xx, y, 'w' );\t\t\n\t\t\txx += Utils.stringSize( ctx, preFragment ).width;\n\t\t\t\n\t\t\tctx.fillStyle = color;\n\t\t\tscan = tagEnd + 4;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tctx.fillStyle = standardColor;\n\t\t\tmore = false;\n\t\t}\n\t\t\n\t\tctx.beginPath();\n\t\tUtils.anchoredFillText( ctx, fragment, xx, y, 'w' );\t\t\n\t\txx += Utils.stringSize( ctx, fragment ).width;\n\t}\n\t\n\tctx.fillStyle = standardColor;\n}"}}},"Tower":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"PULSE.Tower"},{"title":"param","description":null,"type":null,"name":"x"},{"title":"param","description":null,"type":null,"name":"y"},{"title":"param","description":null,"type":null,"name":"width"},{"title":"param","description":null,"type":null,"name":"depth"},{"title":"param","description":null,"type":null,"name":"height"}]},"Source":"PULSE.Tower = function ( x, y, width, depth, height )\n{\n\tthis.x = x;\n\tthis.y = y;\n\tthis.width = width;\n\tthis.depth = depth;\n\tthis.height = height;\n}","prototype":{"face":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"ctx"},{"title":"param","description":null,"type":null,"name":"projection"},{"title":"param","description":null,"type":null,"name":"face"}]},"Source":"PULSE.Tower.prototype.face = function ( ctx, projection, face )\n{\n\tvar points = [];\n\tswitch ( face )\n\t{\n\t\tcase 't':\n\t\t\tpoints.push( { x:this.x, y:this.y, z:this.height } );\n\t\t\tpoints.push( { x:this.x, y:this.y + this.width, z:this.height } );\n\t\t\tpoints.push( { x:this.x + this.depth, y:this.y + this.width, z:this.height } );\n\t\t\tpoints.push( { x:this.x + this.depth, y:this.y, z:this.height } );\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tpoints.push( { x:this.x, y:this.y, z:0 } );\n\t\t\tpoints.push( { x:this.x, y:this.y + this.width, z:0 } );\n\t\t\tpoints.push( { x:this.x + this.depth, y:this.y + this.width, z:0 } );\n\t\t\tpoints.push( { x:this.x + this.depth, y:this.y, z:0 } );\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tpoints.push( { x:this.x + this.depth, y:this.y, z:0 } );\n\t\t\tpoints.push( { x:this.x + this.depth, y:this.y, z:this.height } );\n\t\t\tpoints.push( { x:this.x + this.depth, y:this.y + this.width, z:this.height } );\n\t\t\tpoints.push( { x:this.x + this.depth, y:this.y + this.width, z:0 } );\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tpoints.push( { x:this.x, y:this.y + this.width, z:0 } );\n\t\t\tpoints.push( { x:this.x, y:this.y + this.width, z:this.height } );\n\t\t\tpoints.push( { x:this.x + this.depth, y:this.y + this.width, z:this.height } );\n\t\t\tpoints.push( { x:this.x + this.depth, y:this.y + this.width, z:0 } );\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tpoints.push( { x:this.x, y:this.y, z:0 } );\n\t\t\tpoints.push( { x:this.x, y:this.y, z:this.height } );\n\t\t\tpoints.push( { x:this.x, y:this.y + this.width, z:this.height } );\n\t\t\tpoints.push( { x:this.x, y:this.y + this.width, z:0 } );\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\tpoints.push( { x:this.x, y:this.y, z:0 } );\n\t\t\tpoints.push( { x:this.x, y:this.y, z:this.height } );\n\t\t\tpoints.push( { x:this.x + this.depth, y:this.y, z:this.height } );\n\t\t\tpoints.push( { x:this.x + this.depth, y:this.y, z:0 } );\n\t\t\tbreak;\n\t}\t\t\n\t\n\tctx.beginPath();\n\tfor ( var i = 0, j = points.length; i < j; i++ )\n\t{\n\t\tvar pos = projection.project( points[i] );\n\t\tif ( i === 0 )\n\t\t{\n\t\t\tctx.moveTo( pos.x, pos.y );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tctx.lineTo( pos.x, pos.y );\n\t\t}\n\t}\n\tctx.closePath();\n}"}}},"Tracer":{"init":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"PULSE.Tracer.init"},{"title":"param","description":null,"type":null,"name":"acceptedLevels"}]},"Source":"PULSE.Tracer.init = function ( acceptedLevels )\n{\n\t// Save the accepted levels\n\tPULSE.Tracer.acceptedLevel = {};\n\tfor ( var i = 0, j = acceptedLevels.length; i < j; i++ )\n\t{\n\t\tPULSE.Tracer.acceptedLevel[ acceptedLevels[i] ] = true;\n\t}\n\t\n\t// Obtain the tracing element if it exists\n\t//var tracingElement = document.getElementById( PULSE.Tracer.TRACING_ELEMENT_ID );\n\t//if ( tracingElement === null )\n\t//{\n\t\t// Create a new one\n\t\t//tracingElement = document.createElement( 'div' );\n\t\t//tracingElement.id = PULSE.Tracer.TRACING_ELEMENT_ID;\n\t\t\n\t\t// Attach it to the head\n\t\t//document.getElementsByTagName('head')[0].appendChild( tracingElement );\n\t//}\n\t\n\t// Save the reference\n\t//PULSE.Tracer.tracingElement = tracingElement;\n}"},"debug":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"message"}]},"Source":"PULSE.Tracer.debug = function ( message )\n{\n\tPULSE.Tracer.addTrace( 'debug', message );\n}"},"info":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"message"}]},"Source":"PULSE.Tracer.info = function ( message )\n{\n\tPULSE.Tracer.addTrace( 'info', message );\n}"},"warn":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"message"}]},"Source":"PULSE.Tracer.warn = function ( message )\n{\n\tPULSE.Tracer.addTrace( 'warn', message );\n}"},"error":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"message"}]},"Source":"PULSE.Tracer.error = function ( message )\n{\n\tPULSE.Tracer.addTrace( 'error', message );\n}"},"addTrace":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"level"},{"title":"param","description":null,"type":null,"name":"message"}]},"Source":"PULSE.Tracer.addTrace = function ( level, message )\n{\n\tvar format = function ( value, size, pad )\n\t{\n\t\tif ( size === undefined )\n\t\t{\n\t\t\tsize = 2;\n\t\t}\n\t\tif ( pad === undefined )\n\t\t{\n\t\t\tpad = '0';\n\t\t}\n\t\tvar s = String( value );\n\t\twhile ( s.length < Math.abs( size ) )\n\t\t{\n\t\t\tif ( size > 0 )\n\t\t\t{\n\t\t\t\ts = pad + s;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ts = s + pad;\n\t\t\t}\n\t\t}\n\t\treturn s;\n\t};\n\t\n\tif ( PULSE.Tracer.acceptedLevel !== undefined && PULSE.Tracer.acceptedLevel[ level ] )\n\t{\n\t\tvar date = new Date();\n\t\tvar ts = date.getFullYear() + '-' + format( date.getMonth() + 1 ) + '-' + \n\t\t\t\t format( date.getDate() ) + ' ' + format( date.getHours() ) + ':' + \n\t\t\t\t format( date.getMinutes() ) + ':' + format( date.getSeconds() ) + '.' +\n\t\t\t\t format( date.getMilliseconds(), 3 );\n\t\t\n\t\tvar msg = ts + ' [' + format( level, -5, ' ' ) + '] ' + message;\n\t\t\n\t\t// No longer trace to the head div\n\t\t//PULSE.Tracer.tracingElement.appendChild( document.createTextNode( msg ) );\n\t\t\n\t\t// Also log to console\n\t\tif ( window.console )\n\t\t{\n\t\t\tif ( 'info' === level )\n\t\t\t{\n\t\t\t\tconsole.info( msg );\n\t\t\t}\n\t\t\telse if ( 'warn' === level )\n\t\t\t{\n\t\t\t\tconsole.warn( msg );\n\t\t\t}\n\t\t\telse if ( 'error' === level )\n\t\t\t{\n\t\t\t\tconsole.error( msg );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tconsole.log( msg );\n\t\t\t}\n\t\t}\n\t}\n}","format":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"value"},{"title":"param","description":null,"type":null,"name":"size"},{"title":"param","description":null,"type":null,"name":"pad"}]},"Source":"var format = function ( value, size, pad )\n\t{\n\t\tif ( size === undefined )\n\t\t{\n\t\t\tsize = 2;\n\t\t}\n\t\tif ( pad === undefined )\n\t\t{\n\t\t\tpad = '0';\n\t\t}\n\t\tvar s = String( value );\n\t\twhile ( s.length < Math.abs( size ) )\n\t\t{\n\t\t\tif ( size > 0 )\n\t\t\t{\n\t\t\t\ts = pad + s;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ts = s + pad;\n\t\t\t}\n\t\t}\n\t\treturn s;\n\t}"}},"clear":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.Tracer.clear = function ()\n{\n\t//while ( PULSE.Tracer.tracingElement.firstChild )\n\t//{\n\t//\tPULSE.Tracer.tracingElement.removeChild( PULSE.Tracer.tracingElement.firstChild );\n\t//}\n}"}},"Video":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"PULSE.Video"},{"title":"param","description":null,"type":null,"name":"id"}]},"Source":"PULSE.Video = function ( id )\n{\n\tthis.video = document.getElementById( id );\n\tthis.videoDiv = document.getElementById( id + 'div' );\n\tif ( this.video === null || this.videoDiv === null )\n\t{\n\t\tPULSE.Tracer.error( 'Expected video tag ' + id + ' was missing' );\n\t}\n}","prototype":{"load":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"filename"}]},"Source":"PULSE.Video.prototype.load = function ( filename )\n{\n\tthis.video.src = filename;\n}"},"play":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.Video.prototype.play = function ()\n{\n\tthis.video.play();\n}"},"setVisible":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"visible"}]},"Source":"PULSE.Video.prototype.setVisible = function ( visible )\n{\n\tthis.videoDiv.setAttribute( 'style', visible ? '' : 'display:none' );\n}"}}},"Projector":{"Documentation":{"description":"Constructor.","tags":[{"title":"param","description":"the projection parameters","type":null,"name":"p"}]},"Source":"PULSE.Projector = function ( p )\n{\n\tif ( p )\n\t{\n\t\tthis.p = p;\n\t\n\t\tvar mRoll  = PULSE.axisRotation( 2, p.r );\n\t\tvar mPitch = PULSE.axisRotation( 0, p.p );\n\t\tvar mYaw   = PULSE.axisRotation( 2, p.y );\n\t\n\t\tvar m = PULSE.matrixMatrixMultiply( mRoll, mPitch );\n\t\tthis.rot = PULSE.matrixMatrixMultiply( m, mYaw );\n\t}\n}","prototype":{"project":{"Documentation":{"description":"Projects world coordinates into screen ones.","tags":[{"title":"param","description":"the xyz world coordinates","type":null,"name":"world"}]},"Source":"PULSE.Projector.prototype.project = function ( world )\n{\n\tvar newWorld = [ world.x - this.p.tx, world.y - this.p.ty, world.z - this.p.tz ]; \n\tvar cam = PULSE.matrixVectorMultiply( this.rot, newWorld );\n\t\t\t\n\tif ( cam[2] < 1e-9 )\n\t{\n\t\tcam[2] = -1e-9;\n\t}\n\t\t\n    var x = this.p.cx + ( ( cam[0] / cam[2] ) * this.p.fl );\n    var y = this.p.cy + ( ( cam[1] / cam[2] ) * this.p.fl * this.p.ar );\n\n    var dx = world.x - this.p.tx;\n    var dy = world.y - this.p.ty;\n    var dz = world.z - this.p.tz;\n    var dsquared = dx*dx + dy*dy + dz*dz;\n\t        \n    return { x:x, y:y, dsquared:dsquared };\n}"}}},"axisRotation":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"PULSE.axisRotation"},{"title":"param","description":null,"type":null,"name":"axis"},{"title":"param","description":null,"type":null,"name":"angle"}]},"Source":"PULSE.axisRotation = function ( axis, angle )\n{\n    var i0 = PULSE.LUT[axis][0];\n    var i1 = PULSE.LUT[axis][1];\n    var i2 = PULSE.LUT[axis][2];\n\n    var rot = [ [0,0,0], [0,0,0], [0,0,0] ]; \n    rot[i0][i0] = 1.0;\n    rot[i1][i1] = Math.cos( angle );\n    rot[i2][i2] = Math.cos( angle );\n    rot[i1][i2] = Math.sin( angle );\n    rot[i2][i1] = -rot[i1][i2];\n\n    return rot;\n}"},"matrixMatrixMultiply":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"a"},{"title":"param","description":null,"type":null,"name":"b"}]},"Source":"PULSE.matrixMatrixMultiply = function ( a, b )\n{\n\treturn [\n\t    [ a[0][0]*b[0][0] + a[0][1]*b[1][0] + a[0][2]*b[2][0], \n\t      a[0][0]*b[0][1] + a[0][1]*b[1][1] + a[0][2]*b[2][1], \n\t      a[0][0]*b[0][2] + a[0][1]*b[1][2] + a[0][2]*b[2][2] ],\n\t    [ a[1][0]*b[0][0] + a[1][1]*b[1][0] + a[1][2]*b[2][0], \n\t      a[1][0]*b[0][1] + a[1][1]*b[1][1] + a[1][2]*b[2][1],\t\n\t      a[1][0]*b[0][2] + a[1][1]*b[1][2] + a[1][2]*b[2][2] ],\n        [ a[2][0]*b[0][0] + a[2][1]*b[1][0] + a[2][2]*b[2][0], \n          a[2][0]*b[0][1] + a[2][1]*b[1][1] + a[2][2]*b[2][1],\t\n          a[2][0]*b[0][2] + a[2][1]*b[1][2] + a[2][2]*b[2][2] ]\n\t];\n}"},"matrixVectorMultiply":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"a"},{"title":"param","description":null,"type":null,"name":"b"}]},"Source":"PULSE.matrixVectorMultiply = function ( a, b )\n{\n\treturn [ a[0][0]*b[0] + a[0][1]*b[1] + a[0][2]*b[2],\n\t         a[1][0]*b[0] + a[1][1]*b[1] + a[1][2]*b[2],\n\t         a[2][0]*b[0] + a[2][1]*b[1] + a[2][2]*b[2] ];\n}"},"PointProgress":{"Documentation":{"description":"Class to encapsulate a point progress.","tags":[]},"Source":"PULSE.PointProgress = function ( rawPp )\n{\n\tvar fields = rawPp.split( '.' );\n\tthis.set = fields[0];\n\tthis.game = fields[1];\n\tthis.point = fields[2];\n}","matches":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"PULSE.PointProgress.matches"},{"title":"param","description":null,"type":null,"name":"raw"}]},"Source":"PULSE.PointProgress.matches = function ( raw )\n{\n\treturn !Utils.isNullish( raw ) && raw.match( /\\d+\\.\\d+\\.\\d+/ ) !== null;\n}"},"prototype":{"description":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.PointProgress.prototype.description = function ()\n{\n\treturn this.set + '.' + this.game + '.' + this.point;\n}"},"compareTo":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"rawPp"}]},"Source":"PULSE.PointProgress.prototype.compareTo = function ( rawPp )\n{\n\tvar other = new PULSE.PointProgress( rawPp );\n\t\n    var compare = +this.set - +other.set;\n    if ( compare === 0 )\n    {\n        compare = +this.game - +other.game;\n        if ( compare === 0 )\n        {\n            compare = +this.point - +other.point;\n        }\n    }\n\n    return compare;\n}"}}},"UdsStatsRecord":{"Documentation":{"description":"Wrapper for a record from a UDS file.","tags":[]},"Source":"PULSE.UdsStatsRecord = function ( rawBp, rawData, playerLookup )\n{\n\tthis.fields = rawData.split( ',' );\n\tthis.bp = new PULSE.BallProgress( rawBp );\n\tthis.traj = null;\n\tthis.playerLookup = playerLookup;\n}","prototype":{"satisfiesFilter":{"Documentation":{"description":"Returns true if this record satisfies the given filter.","tags":[]},"Source":"PULSE.UdsStatsRecord.prototype.satisfiesFilter = function ( filter )\n{\n\tif ( filter === undefined )\n\t{\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\t// Check innings, over and ball, allowing for All \n\t\tvar inn = Utils.isNullish( filter.innings ) || \n\t\t\t\t  CricketFilter.ALL === filter.innings ||\n\t\t\t\t  this.get( CricketField.INNINGS ) == filter.innings.toString(); // Coerce!\n\t\t\n\t\tvar over = Utils.isNullish( filter.over ) || \n\t\t   \t\t   CricketFilter.ALL === filter.over ||\n\t\t   \t\t   this.get( CricketField.OVER ) == filter.over; // Coerce!\n\n\t\tvar ball = Utils.isNullish( filter.ball ) || \n\t\t   \t\t   CricketFilter.ALL === filter.ball ||\n\t\t   \t\t   CricketFilter.ALLBALLS === filter.ball ||\n\t\t   \t\t   this.get( CricketField.BALL ) == filter.ball; // Coerce!\n\n\t\tif ( inn && over && ball )\n\t\t{\n\t\t\t// Check batsman\n\t    \tvar lh = this.get( CricketField.HANDEDNESS ) === CricketHandedness.LEFT;\n\t\t\tvar ba = Utils.isNullish( filter.batsman ) || \n\t\t\t\t\t CricketFilter.ALL === filter.batsman ||\n\t\t\t\t\t CricketFilter.ALLBATSMEN === filter.batsman ||\n\t\t\t\t\t ( !lh && CricketFilter.RIGHTHANDERS === filter.batsman ) || \n\t\t\t\t\t (  lh && CricketFilter.LEFTHANDERS === filter.batsman ) ||\n\t\t\t\t\t this.get( CricketField.BATSMAN ) === filter.batsman;\n\t\t\t\t\t \n\t\t\t// Check bowler\n\t\t\tvar spin = this.get( CricketField.BOWLER_SPEED ) === CricketBowlerSpeed.SPIN;\n\t\t\tvar bo = Utils.isNullish( filter.bowler ) || \n\t\t\t\t\t CricketFilter.ALL === filter.bowler ||\n\t\t\t\t\t CricketFilter.ALLBOWLERS === filter.bowler ||\n\t\t\t\t\t (  spin && CricketFilter.SPINBOWLERS === filter.bowler ) || \n\t\t\t\t\t ( !spin && CricketFilter.SEAMBOWLERS === filter.bowler ) ||\n\t\t\t\t\t this.get( CricketField.BOWLER ) === filter.bowler;\n\t\t\t\n\t\t\treturn ba && bo;\n\t    }\n\t\t\n    \treturn false;\n\t}\n}"},"get":{"Documentation":{"description":"Obtains a field (column) from this record.","tags":[]},"Source":"PULSE.UdsStatsRecord.prototype.get = function ( field )\n{\n\tswitch ( field )\n\t{\n\t\tcase CricketField.ID:\n\t\t\treturn this.bp.description();\n\t\t\t\n\t\tcase CricketField.INNINGS:\n\t\t\treturn this.bp.innings;\n\t\t\t\n\t\tcase CricketField.OVER:\n\t\t\treturn this.bp.over;\n\t\t\t\n\t\tcase CricketField.BALL:\n\t\t\treturn this.bp.ball;\n\t\t\t\n\t\tcase CricketField.COUNTING_BALL:\n\t\t\treturn this.countingBall;\n\t\t\t\n\t\tcase CricketField.IS_COUNTING:\n\t\t\tvar et = this.fields[10];\n\t\t\treturn ( et.length === 0 || 'Lb' === et || 'B' === et );\n\t\n\t\tcase CricketField.BATSMAN:\n\t\t\treturn this.playerLookup[ this.fields[1] ].fullName;\n\t\t\t\n\t\tcase CricketField.NF_BATSMAN:\n\t\t\treturn this.playerLookup[ this.fields[2] ].fullName;\n\t\t\t\n\t\tcase CricketField.BOWLER:\n\t\t\treturn this.playerLookup[ this.fields[3] ].fullName;\n\t\t\t\n\t\tcase CricketField.BOWL_SPEED:\n\t\t\treturn Number( this.fields[4] );\n\t\t\t\n\t\tcase CricketField.DISMISSED:\n\t\t\treturn this.playerLookup[ this.fields[5] ] ? this.playerLookup[ this.fields[5] ].fullName : '';\n\t\t\t\n\t\tcase CricketField.IS_WICKET:\n\t\t\treturn this.fields[5] !== \"-1\";\n\t\t\t\n\t\tcase CricketField.MOD:\n\t\t\treturn this.fields[6];\n\t\t\t\t\t\n\t\tcase CricketField.RUNS:\n\t\t\tif ( this.fields[7].length > 0 )\n\t\t\t{\n\t\t\t\treturn this.fields[7];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t\n\t\tcase CricketField.CREDIT:\n\t\t\t/*if ( this.fields[8] === \"0\" )\n\t\t\t{\n\t\t\t\treturn this.get( CricketField.RUNS );\n\t\t\t}\n\t\t\telse\n\t\t\t{*/\n\t\t\t\treturn this.fields[8];\n\t\t\t//}\n\t\t\t\n\t\tcase CricketField.DEBIT:\n\t\t\t/*if ( this.fields[9] === \"0\" )\n\t\t\t{\n\t\t\t\treturn this.get( CricketField.RUNS );\n\t\t\t}\n\t\t\telse\n\t\t\t{*/\n\t\t\t\treturn this.fields[9];\n\t\t\t//}\n\t\t\t\n\t\tcase CricketField.EXTRA_TYPE:\n\t\t\treturn this.fields[10];\n\t\t\t\n\t\tcase CricketField.HAS_HANDEDNESS:\n\t\t\treturn this.fields[11].length > 0;\n\t\t\t\n\t\tcase CricketField.HANDEDNESS:\n\t\t\treturn this.fields[11] === 'y' ? CricketHandedness.RIGHT : CricketHandedness.LEFT;\n\t\t\t\n\t\tcase CricketField.PITCHED:\n\t\t\tif ( this.fields[12].length === 0 )\n\t\t\t{\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\treturn { x:this.fields[12], y:this.fields[13], z:0 };\n\t\t\t\n\t\tcase CricketField.STUMPS:\n\t\t\tif ( this.fields[14].length === 0 )\n\t\t\t{\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\treturn { x:0, y:this.fields[14], z:this.fields[15] };\n\t\t\t\n\t\tcase CricketField.WW:\n\t\t\tif ( Utils.isNullish( this.fields[16] ) || Utils.isNullish( this.fields[17] ) )\n\t\t\t{\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn PULSE.UdsStatsRecord.covertWWToCoaching( this.fields[16], this.fields[17] );\n\t\t\t}\n\t\t\t\n\t\tcase CricketField.WIN_LIKELIHOODS:\n\t\t\tif ( Utils.isNullish( this.fields[18] ) )\n\t\t\t{\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn [ +this.fields[18], +this.fields[19], +this.fields[20] ];\n\t\t\t}\n\t}\n}"},"hasTrajData":{"Documentation":{"description":"Returns true if the traj field is non-nullish.","tags":[]},"Source":"PULSE.UdsStatsRecord.prototype.hasTrajData = function ()\n{\n\treturn false;\n}"},"generateSummary":{"Documentation":{"description":"Gets a runs/wicket summary for this record.","tags":[]},"Source":"PULSE.UdsStatsRecord.prototype.generateSummary = function ( lowercase )\n{\n\tvar summary = '';\n\tif ( this.get( CricketField.IS_WICKET ) )\n\t{\n\t\tsummary += lowercase ? 'wicket ' : 'Wicket ';\n\t}\n\t\n\tvar runs = +this.get( CricketField.RUNS );\n\tif ( runs > 0 )\n\t{\n\t\tsummary += runs + ' run';\n\t\tif ( runs > 1 )\n\t\t{\n\t\t\tsummary += 's';\n\t\t}\n\t\t\n\t\tvar et = this.get( CricketField.EXTRA_TYPE );\n\t\tif ( et.length > 0 )\n\t\t{\n\t\t\tsummary += ' (' + ( lowercase ? et.toLowerCase() : et ) + ')';\n\t\t}\n\t}\n\treturn summary;\n}"},"generateDescription":{"Documentation":{"description":"Obtains a commentary-style description of this record.","tags":[]},"Source":"PULSE.UdsStatsRecord.prototype.generateDescription = function ()\n{\n\tvar description = '<b>';\n\n\tdescription += ( +this.get( CricketField.OVER ) - 1 );\n\tdescription += '.';\n\tdescription += this.get( CricketField.COUNTING_BALL );\n\tdescription += '</b> ';\n\t\n    description += this.get( CricketField.BOWLER );\n    description += ' to ';\n    description += this.get( CricketField.BATSMAN );\n\n    // Add ball speed to description\n    var speed = this.get( CricketField.BOWL_SPEED );\n    if ( !isNaN( speed ) && speed >= 13 && speed <= 54 )\n    {\n        description += ', ';\n        if ( PULSE.SpeedModeController.mode === PULSE.SpeedModeController.MODE_KMH )\n        {\n        \tspeed = PULSE.SpeedModeController.mpsToKmh( speed );\n        }\n        \n        description += speed.toFixed( 1 );\n        description += ' ' + PULSE.SpeedModeController.unit;        \n    }\n\n    // Add runs scored to description\n\tvar credit = +this.get( CricketField.CREDIT );\n    \n    description += ', ';\n    if ( this.get( CricketField.IS_WICKET ) )\n    {\n        description += 'wicket';\n    }\n    else \n    {\n    \tif ( credit === 0 )\n\t    {\n\t        description += 'dot ball';\n\t    }\n\t    else\n\t    {\n\t        description += credit;\n\t        description += ' run';\n\t        if ( credit > 1 )\n\t        {\n\t            description += 's';\n\t        }\n\t    }\n    }\n\n    // Add description of where the ball went\n    var ps = this.get( CricketField.PITCH_SEGMENT );\n    if ( !Utils.isNullish( ps ) && !this.get( CricketField.IS_WICKET ) && credit > 0 )\n    {\n    \tdescription += ', hit ';\n    \tdescription += CricketSegmentLookup[ ps ];\n    }\n\n    // Finish the sentence\n    description += '.';\n\n    return description;\n}"}},"parseTrajectory":{"Documentation":{"description":"Parses the trajectory data given.","tags":[]},"Source":"PULSE.UdsStatsRecord.parseTrajectory = function ( encoded )\n{\n\t// Raw string is a Base64 encoded stream\n\tvar decoded = Base64Decoder.decode( encoded );\n\t\n\tif ( decoded.length < 72 )\n\t{\n\t\tPULSE.Tracer.warn( 'Decoded traj length was ' + decoded.length );\n\t\treturn undefined;\n\t}\n\t\n    // Extract coefficients into a trajectory object\n\tvar traj = new CricketBallTrajectory();\n\ttry\n\t{\n\t\ttraj.bp   = PULSE.UdsStatsRecord.readMulti( decoded, 0, 2 );\n\t\ttraj.bt   = PULSE.UdsStatsRecord.readMulti( decoded, 8, 1 ).x;\n\t\ttraj.a \t  = PULSE.UdsStatsRecord.readMulti( decoded, 12, 3 );\n\t\ttraj.ebv  = PULSE.UdsStatsRecord.readMulti( decoded, 24, 3 );\n\t\ttraj.obv  = PULSE.UdsStatsRecord.readMulti( decoded, 36, 3 );\n\t\ttraj.oba  = PULSE.UdsStatsRecord.readMulti( decoded, 48, 3 );\n\t\ttraj.bh   = PULSE.UdsStatsRecord.readMulti( decoded, 60, 1 ).x;\n\t\t//traj.pred = parseBoolean( decoded.substring( 64, 65 ) );\n\t\t//traj.xpos = this.readMulti( decoded, 65, 1 ).x;\n\t\t//traj.end = ?\n\t\t//traj.trackApproved = parseInt( decoded.substring( 71, 72 ) ) === 1;\n\t\t// TODO\n\t\ttraj.trackApproved = true;\n\n\t\t// Calculate the period\n\t    var start = traj.getTimeAtX( 18.5 ) + traj.bt;\n\t    var end = traj.getTimeAtX( 0 ) + traj.bt;\n\t    traj.period = { start: start, end: end };\n\t}\n\tcatch ( exception )\n\t{\n\t\tPULSE.Tracer.error( exception );\n\t\ttraj.trackApproved = false;\n\t}\n\t\n\treturn traj;\n}"},"readMulti":{"Documentation":{"description":"Utility method to read multiple floats from the given data stream.","tags":[]},"Source":"PULSE.UdsStatsRecord.readMulti = function ( data, offset, n )\n{\n\tvar ret = {};\n\n\tif ( n > 0 )\n\t{\n\t\tret.x = PULSE.UdsStatsRecord.decodeFloat( data.substring( offset, offset + 4 ) );\n\t}\n\tif ( n > 1 )\n\t{\n\t\tret.y = PULSE.UdsStatsRecord.decodeFloat( data.substring( offset + 4, offset + 8 ) );\n\t}\n\tif ( n > 2 )\n\t{\n\t\tret.z = PULSE.UdsStatsRecord.decodeFloat( data.substring( offset + 8, offset + 12 ) );\n\t}\n\t\n\treturn ret;\n}"},"decodeFloat":{"Documentation":{"description":"Decode an IEE754 float.","tags":[]},"Source":"PULSE.UdsStatsRecord.decodeFloat = function ( data )\n{\n    var sign = ( data.charCodeAt( 0 ) & 0x80 ) >> 7;\n    var exponent = ( ( data.charCodeAt( 0 ) & 0x7F ) << 1 ) + ( data.charCodeAt( 1 ) >> 7 );\n    \n    var significand = 0.0;\n    var bit = 23;\n    var component = 1.0;\n    var b;\n    var mask;\n\n    while ( bit >= 0 )\n    {\n        if ( bit === 23 )\n        {\n            b = ( data.charCodeAt( 1 ) & 0x7F ) | 0x80;\n            mask = 0x80; \n        }\n        else if ( bit === 15 )\n        {\n            b = data.charCodeAt( 2 );\n            mask = 0x80; \n        }\n        else if ( bit === 7 )\n        {\n            b = data.charCodeAt( 3 );\n            mask = 0x80; \n        }\n\t\n\t    if ( ( mask & b ) === mask )\n\t    {\n\t        significand += component;\n\t    }\n\n\t    component /= 2;\n\t    mask = mask >> 1;\n\t    bit--;\n    }\n\n    return Math.pow( -1, sign ) *\n           Math.pow( 2, exponent - 127 ) *\n           significand; \n}"},"covertWWToCoaching":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"PULSE.UdsStatsRecord.covertWWToCoaching"},{"title":"param","description":null,"type":null,"name":"wwX"},{"title":"param","description":null,"type":null,"name":"wwY"}]},"Source":"PULSE.UdsStatsRecord.covertWWToCoaching = function ( wwX, wwY )\n{\n\tvar scaleX = 4.05;\n\tvar scaleY = 3.45;\n\tvar offsetX = -130.33;\n\tvar offsetY = -163.64;\n\t//{ x:this.fields[16], y:this.fields[17] }\n\t\n\treturn { x: ( ( wwY * scaleX ) + offsetX ), y : ( ( wwX * scaleY ) + offsetY ) };\n}"}},"UdsTrajRecord":{"Documentation":{"description":"Wrapper for a record from a UDS file.","tags":[]},"Source":"PULSE.UdsTrajRecord = function ( rawBp, rawData, playerLookup )\n{\n\tthis.fields = rawData.split( ',' );\n\tthis.bp = new PULSE.BallProgress( rawBp );\n\tthis.traj = null;\n\tthis.playerLookup = playerLookup;\n}","prototype":{"satisfiesFilter":{"Documentation":{"description":"Returns true if this record satisfies the given filter.","tags":[]},"Source":"PULSE.UdsTrajRecord.prototype.satisfiesFilter = function ( filter )\n{\n\tif ( filter === undefined )\n\t{\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\t// First check a *.*.All match on the over filter\n/*\t\tif ( filter.over !== undefined && filter.over.match( /[0-9]+\\.[0-9]+\\.All/ ) !== null )\n\t\t{\n\t\t\tvar sample = filter.over.replace( /All/, '0' );\n\t\t\tvar sampleBp = new PULSE.BallProgress( sample );\n\t\t\t\n\t\t\treturn ( this.bp.innings === sampleBp.innings &&\n\t\t\t\t\t this.bp.over === sampleBp.over );\n\t\t}\n*/\t\t\n\t\t// Check innings, over and ball, allowing for All \n\t\tvar inn = Utils.isNullish( filter.innings ) || \n\t\t\t\t  CricketFilter.ALL === filter.innings ||\n\t\t\t\t  this.get( CricketField.INNINGS ) == filter.innings.toString(); // Coerce!\n\t\t\n\t\tvar over = Utils.isNullish( filter.over ) || \n\t\t   \t\t   CricketFilter.ALL === filter.over ||\n\t\t   \t\t   this.get( CricketField.OVER ) == filter.over; // Coerce!\n\n\t\tvar ball = Utils.isNullish( filter.ball ) || \n\t\t   \t\t   CricketFilter.ALL === filter.ball ||\n\t\t   \t\t   CricketFilter.ALLBALLS === filter.ball ||\n\t\t   \t\t   this.get( CricketField.BALL ) == filter.ball; // Coerce!\n\n\t\tif ( inn && over && ball )\n\t\t{\n\t\t\t// Check batsman\n\t    \tvar lh = this.get( CricketField.HANDEDNESS ) === CricketHandedness.LEFT;\n\t\t\tvar ba = Utils.isNullish( filter.batsman ) || \n\t\t\t\t\t CricketFilter.ALL === filter.batsman ||\n\t\t\t\t\t CricketFilter.ALLBATSMEN === filter.batsman ||\n\t\t\t\t\t ( !lh && CricketFilter.RIGHTHANDERS === filter.batsman ) || \n\t\t\t\t\t (  lh && CricketFilter.LEFTHANDERS === filter.batsman ) ||\n\t\t\t\t\t this.get( CricketField.BATSMAN ) === filter.batsman;\n\t\t\t\t\t \n\t\t\t// Check bowler\n\t\t\tvar spin = this.get( CricketField.BOWLER_SPEED ) === CricketBowlerSpeed.SPIN;\n\t\t\tvar bo = Utils.isNullish( filter.bowler ) || \n\t\t\t\t\t CricketFilter.ALL === filter.bowler ||\n\t\t\t\t\t CricketFilter.ALLBOWLERS === filter.bowler ||\n\t\t\t\t\t (  spin && CricketFilter.SPINBOWLERS === filter.bowler ) || \n\t\t\t\t\t ( !spin && CricketFilter.SEAMBOWLERS === filter.bowler ) ||\n\t\t\t\t\t this.get( CricketField.BOWLER ) === filter.bowler;\n\t\t\t\n\t\t\treturn ba && bo;\n\t    }\n\t\t\n    \treturn false;\n\t}\n}"},"get":{"Documentation":{"description":"Obtains a field (column) from this record.","tags":[]},"Source":"PULSE.UdsTrajRecord.prototype.get = function ( field )\n{\n\tswitch ( field )\n\t{\n\t\tcase CricketField.ID:\n\t\t\treturn this.bp.description();\n\t\t\t\n\t\tcase CricketField.INNINGS:\n\t\t\treturn this.bp.innings;\n\t\t\t\n\t\tcase CricketField.OVER:\n\t\t\treturn this.bp.over;\n\t\t\t\n\t\tcase CricketField.BALL:\n\t\t\treturn this.bp.ball;\n\t\t\t\n\t\tcase CricketField.COUNTING_BALL:\n\t\t\treturn this.countingBall;\n\t\t\t\n\t\tcase CricketField.IS_COUNTING:\n\t\t\tvar et = this.fields[9];\n\t\t\treturn ( et.length === 0 || 'Lb' === et || 'B' === et );\n\t\n\t\tcase CricketField.BATSMAN:\n\t\t\treturn this.playerLookup[ this.fields[1] ].fullName;\n\t\t\t\n\t\tcase CricketField.NF_BATSMAN:\n\t\t\treturn this.playerLookup[ this.fields[2] ].fullName;\n\t\t\t\n\t\tcase CricketField.BOWLER:\n\t\t\treturn this.playerLookup[ this.fields[3] ].fullName;\n\t\t\t\n\t\tcase CricketField.BOWL_SPEED:\n\t\t\treturn Number( this.fields[4] );\n\t\t\t\n\t\tcase CricketField.DISMISSED:\n\t\t\treturn this.playerLookup[ this.fields[5] ] ? this.playerLookup[ this.fields[5] ].fullName : '';\n\t\t\t\n\t\tcase CricketField.IS_WICKET:\n\t\t\treturn this.fields[5] !== \"-1\";\n\t\t\t\n\t\tcase CricketField.MOD:\n\t\t\treturn this.fields[6];\n\t\t\t\n\t\tcase CricketField.RUNS:\n\t\t\tif ( this.fields[7].length > 0 )\n\t\t\t{\n\t\t\t\treturn this.fields[7];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t\n\t\tcase CricketField.CREDIT:\n\t\t\t/*if ( this.fields[8] === \"0\" )\n\t\t\t{\n\t\t\t\treturn this.get( CricketField.RUNS );\n\t\t\t}\n\t\t\telse\n\t\t\t{*/\n\t\t\t\treturn this.fields[8];\n\t\t\t//}\n\t\t\t\n\t\tcase CricketField.EXTRA_TYPE:\n\t\t\treturn this.fields[9];\n\t\t\t\n\t\tcase CricketField.TRAJECTORY:\n\t\t\tif ( this.traj === null )\n\t\t\t{\n\t\t\t\tthis.traj = PULSE.UdsTrajRecord.parseTrajectory( this.fields[10] );\n\t\t\t}\n\t\t\treturn this.traj;\t\t\t\n\t}\n}"},"hasTrajData":{"Documentation":{"description":"Returns true if the traj field is non-nullish.","tags":[]},"Source":"PULSE.UdsTrajRecord.prototype.hasTrajData = function ()\n{\n\treturn !Utils.isNullish( this.fields[10] );\n}"},"generateSummary":{"Documentation":{"description":"Gets a runs/wicket summary for this record.","tags":[]},"Source":"PULSE.UdsTrajRecord.prototype.generateSummary = function ( lowercase )\n{\n\tvar summary = '';\n\tif ( this.get( CricketField.IS_WICKET ) )\n\t{\n\t\tsummary += lowercase ? 'wicket ' : 'Wicket ';\n\t}\n\t\n\tvar runs = +this.get( CricketField.RUNS );\n\tif ( runs > 0 )\n\t{\n\t\tsummary += runs + ' run';\n\t\tif ( runs > 1 )\n\t\t{\n\t\t\tsummary += 's';\n\t\t}\n\t\t\n\t\tvar et = this.get( CricketField.EXTRA_TYPE );\n\t\tif ( et.length > 0 )\n\t\t{\n\t\t\tsummary += ' (' + ( lowercase ? et.toLowerCase() : et ) + ')';\n\t\t}\n\t}\n\treturn summary;\n}"},"generateDescription":{"Documentation":{"description":"Obtains a commentary-style description of this record.","tags":[]},"Source":"PULSE.UdsTrajRecord.prototype.generateDescription = function ()\n{\n\tvar description = '<b>';\n\n\tdescription += ( +this.get( CricketField.OVER ) - 1 );\n\tdescription += '.';\n\tdescription += this.get( CricketField.COUNTING_BALL );\n\tdescription += '</b> ';\n\t\n    description += this.get( CricketField.BOWLER );\n    description += ' to ';\n    description += this.get( CricketField.BATSMAN );\n\n    // Add ball speed to description\n    var speed = this.get( CricketField.BOWL_SPEED );\n    if ( !isNaN( speed ) && speed >= 13 && speed <= 54 )\n    {\n        description += ', ';\n        if ( PULSE.SpeedModeController.mode === PULSE.SpeedModeController.MODE_KMH )\n        {\n        \tspeed = PULSE.SpeedModeController.mpsToKmh( speed );\n        }\n        \n        description += speed.toFixed( 1 );\n        description += ' ' + PULSE.SpeedModeController.unit;        \n    }\n\n    // Add runs scored to description\n\tvar credit = +this.get( CricketField.CREDIT );\n    \n    description += ', ';\n    if ( this.get( CricketField.IS_WICKET ) )\n    {\n        description += 'wicket';\n    }\n    else \n    {\n    \tif ( credit === 0 )\n\t    {\n\t        description += 'dot ball';\n\t    }\n\t    else\n\t    {\n\t        description += credit;\n\t        description += ' run';\n\t        if ( credit > 1 )\n\t        {\n\t            description += 's';\n\t        }\n\t    }\n    }\n\n    // Add description of where the ball went\n    var ps = this.get( CricketField.PITCH_SEGMENT );\n    if ( !Utils.isNullish( ps ) && !this.get( CricketField.IS_WICKET ) && credit > 0 )\n    {\n    \tdescription += ', hit ';\n    \tdescription += CricketSegmentLookup[ ps ];\n    }\n\n    // Finish the sentence\n    description += '.';\n\n    return description;\n}"}},"parseTrajectory":{"Documentation":{"description":"Parses the trajectory data given.","tags":[]},"Source":"PULSE.UdsTrajRecord.parseTrajectory = function ( encoded )\n{\n\t// Raw string is a Base64 encoded stream\n\tvar decoded = Base64Decoder.decode( encoded );\n\t\n\tif ( decoded.length < 72 )\n\t{\n\t\tPULSE.Tracer.warn( 'Decoded traj length was ' + decoded.length );\n\t\treturn undefined;\n\t}\n\t\n    // Extract coefficients into a trajectory object\n\tvar traj = new CricketBallTrajectory();\n\ttry\n\t{\n\t\ttraj.bp   = PULSE.UdsTrajRecord.readMulti( decoded, 0, 2 );\n\t\ttraj.bt   = PULSE.UdsTrajRecord.readMulti( decoded, 8, 1 ).x;\n\t\ttraj.a \t  = PULSE.UdsTrajRecord.readMulti( decoded, 12, 3 );\n\t\ttraj.ebv  = PULSE.UdsTrajRecord.readMulti( decoded, 24, 3 );\n\t\ttraj.obv  = PULSE.UdsTrajRecord.readMulti( decoded, 36, 3 );\n\t\ttraj.oba  = PULSE.UdsTrajRecord.readMulti( decoded, 48, 3 );\n\t\ttraj.bh   = PULSE.UdsTrajRecord.readMulti( decoded, 60, 1 ).x;\n\t\t//traj.pred = parseBoolean( decoded.substring( 64, 65 ) );\n\t\t//traj.xpos = this.readMulti( decoded, 65, 1 ).x;\n\t\t//traj.end = ?\n\t\t//traj.trackApproved = parseInt( decoded.substring( 71, 72 ) ) === 1;\n\t\t// TODO\n\t\ttraj.trackApproved = true;\n\n\t\t// Calculate the period\n\t    var start = traj.getTimeAtX( 18.5 ) + traj.bt;\n\t    var end = traj.getTimeAtX( 0 ) + traj.bt;\n\t    traj.period = { start: start, end: end };\n\t}\n\tcatch ( exception )\n\t{\n\t\tPULSE.Tracer.error( exception );\n\t\ttraj.trackApproved = false;\n\t}\n\t\n\treturn traj;\n}"},"readMulti":{"Documentation":{"description":"Utility method to read multiple floats from the given data stream.","tags":[]},"Source":"PULSE.UdsTrajRecord.readMulti = function ( data, offset, n )\n{\n\tvar ret = {};\n\n\tif ( n > 0 )\n\t{\n\t\tret.x = PULSE.UdsTrajRecord.decodeFloat( data.substring( offset, offset + 4 ) );\n\t}\n\tif ( n > 1 )\n\t{\n\t\tret.y = PULSE.UdsTrajRecord.decodeFloat( data.substring( offset + 4, offset + 8 ) );\n\t}\n\tif ( n > 2 )\n\t{\n\t\tret.z = PULSE.UdsTrajRecord.decodeFloat( data.substring( offset + 8, offset + 12 ) );\n\t}\n\t\n\treturn ret;\n}"},"decodeFloat":{"Documentation":{"description":"Decode an IEE754 float.","tags":[]},"Source":"PULSE.UdsTrajRecord.decodeFloat = function ( data )\n{\n    var sign = ( data.charCodeAt( 0 ) & 0x80 ) >> 7;\n    var exponent = ( ( data.charCodeAt( 0 ) & 0x7F ) << 1 ) + ( data.charCodeAt( 1 ) >> 7 );\n    \n    var significand = 0.0;\n    var bit = 23;\n    var component = 1.0;\n    var b;\n    var mask;\n\n    while ( bit >= 0 )\n    {\n        if ( bit === 23 )\n        {\n            b = ( data.charCodeAt( 1 ) & 0x7F ) | 0x80;\n            mask = 0x80; \n        }\n        else if ( bit === 15 )\n        {\n            b = data.charCodeAt( 2 );\n            mask = 0x80; \n        }\n        else if ( bit === 7 )\n        {\n            b = data.charCodeAt( 3 );\n            mask = 0x80; \n        }\n\t\n\t    if ( ( mask & b ) === mask )\n\t    {\n\t        significand += component;\n\t    }\n\n\t    component /= 2;\n\t    mask = mask >> 1;\n\t    bit--;\n    }\n\n    return Math.pow( -1, sign ) *\n           Math.pow( 2, exponent - 127 ) *\n           significand; \n}"}},"TENNIS":{"Trajectory":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"PULSE.TENNIS.Trajectory"},{"title":"param","description":null,"type":null,"name":"encodedData"}]},"Source":"PULSE.TENNIS.Trajectory = function ( encodedData )\n{\n}","prototype":{"getNumArcs":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.TENNIS.Trajectory.prototype.getNumArcs = function ()\n{\n\treturn this.arcs.length;\n}"},"getArc":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"index"}]},"Source":"PULSE.TENNIS.Trajectory.prototype.getArc = function ( index )\n{\n\treturn this.arcs[index];\n}"},"getRange":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.TENNIS.Trajectory.prototype.getRange = function ()\n{\n    return { start : this.getArc( 0 ).time.start,\n    \t     end   : this.getArc( this.getNumArcs() - 1 ).time.end };\n\t\n}"},"getInitialX":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PULSE.TENNIS.Trajectory.prototype.getInitialX = function ()\n{\n\tif ( this.getNumArcs() > 0 )\n\t{\n\t\treturn this.getPositionAtTime( this.getArc( 0 ).time.start ).x; \n\t}\n}"},"getPositionAtTime":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"time"}]},"Source":"PULSE.TENNIS.Trajectory.prototype.getPositionAtTime = function ( time )\n{\n    for ( var arcNum = 0, numArcs = this.getNumArcs(); arcNum < numArcs; arcNum++ )\n    {\n        var arc = this.getArc( arcNum );\n        if ( time >= arc.time.start && time <= arc.time.end )\n        {\n            return PULSE.TENNIS.getPositionAtTime( arc, time );\n        }\n    }\n}"},"getSpeedAtTime":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"time"}]},"Source":"PULSE.TENNIS.Trajectory.prototype.getSpeedAtTime = function ( time )\n{\n    for ( var arcNum = 0, numArcs = this.getNumArcs(); arcNum < numArcs; arcNum++ )\n    {\n        var arc = this.getArc( arcNum );\n        if ( time >= arc.time.start && time <= arc.time.end )\n        {\n            return PULSE.TENNIS.getSpeedAtTime( arc, time );\n        }\n    }\n}"}}},"normaliseTimes":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"times"}]},"Source":"PULSE.TENNIS.normaliseTimes = function ( times )\n{\n\tif ( times )\n\t{\n\t\tif ( times.start > 327.67 )\n\t\t{\n\t\t\ttimes.start -= 655.35;\n\t\t}\n\t\tif ( times.end > 327.67 )\n\t\t{\n\t\t\ttimes.end -= 655.35;\n\t\t}\n\t}\n}"},"parseTrajectory":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"encodedData"}]},"Source":"PULSE.TENNIS.parseTrajectory = function ( encodedData )\n{\n\tvar decodedData = Base64Decoder.decode( encodedData );\n\t\n\tvar traj = new PULSE.TENNIS.Trajectory();\n\ttraj.complete = false;\n\t\n\ttry\n\t{\n\t\tvar version = PULSE.TENNIS.readShort( decodedData, 0 );\n\t\tif ( version === 1 )\n\t\t{\n\t\t\ttraj.arcs = [];\n\t\t\t\n\t\t\ttraj.serverIndex = PULSE.TENNIS.readByte( decodedData, 2 );\n\t\t\tvar pointer = 3;\n\t\t\t\n\t\t\twhile ( pointer < decodedData.length )\n\t\t\t{\n\t\t\t\tvar arc = {};\n\t\t\t\tarc.time = { start: PULSE.TENNIS.shortToDouble( PULSE.TENNIS.readShort( decodedData, pointer ) ),\n\t\t\t\t             end  : PULSE.TENNIS.shortToDouble( PULSE.TENNIS.readShort( decodedData, pointer + 2 ) ) };\n\t\n\t\t\t\t// Ensure that encoded negative times are properly offset\n\t\t\t\tPULSE.TENNIS.normaliseTimes( arc.time );\n\t\t\t\t\n\t\t\t\tvar numVectors = PULSE.TENNIS.readByte( decodedData, pointer + 4 );\n\t\t\t\tpointer += 5;\n\t\t\t\t\n\t\t\t\tvar vectors = [];\n\t\t\t\tfor ( var v = 0; v < numVectors; v++ )\n\t\t\t\t{\n\t\t\t\t\tvectors.push( { x:PULSE.TENNIS.readFloat( decodedData, pointer ),\n\t\t\t\t\t\t\t\t\ty:PULSE.TENNIS.readFloat( decodedData, pointer + 4 ),\n\t\t\t\t\t\t\t\t\tz:PULSE.TENNIS.readFloat( decodedData, pointer + 8 ) } );\n\t\t\t\t\t\n\t\t\t\t\tpointer += 12;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tarc.vectors = vectors;\n\t\t\t\t\n\t\t\t\tarc.dx = PULSE.TENNIS.getPositionAtTime( arc, arc.time.end ).x - \n\t\t\t\t\t\t PULSE.TENNIS.getPositionAtTime( arc, arc.time.start ).x;\n\t\t\t\t\n\t\t\t\ttraj.arcs.push( arc );\n\t\t\t}\n\t\t\t\n\t\t\ttraj.complete = true;\n\t\t}\n\t}\n\tcatch ( exception )\n\t{\n\t}\n\t\n\treturn traj;\n}"},"shortToDouble":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"i"}]},"Source":"PULSE.TENNIS.shortToDouble = function ( i )\n{\n\treturn i / 100.0;\n}"},"readShort":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"data"},{"title":"param","description":null,"type":null,"name":"offset"}]},"Source":"PULSE.TENNIS.readShort = function ( data, offset )\n{\n\treturn ( 256 * data.charCodeAt( offset ) ) + data.charCodeAt( offset + 1 );\n}"},"readByte":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"data"},{"title":"param","description":null,"type":null,"name":"offset"}]},"Source":"PULSE.TENNIS.readByte = function ( data, offset )\n{\n\treturn data.charCodeAt( offset );\n}"},"readFloat":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"data"},{"title":"param","description":null,"type":null,"name":"offset"}]},"Source":"PULSE.TENNIS.readFloat = function ( data, offset )\n{\n    var sign = ( data.charCodeAt( offset ) & 0x80 ) >> 7;\n    var exponent = ( ( data.charCodeAt( offset ) & 0x7F ) << 1 ) + \n    \t\t\t\t ( data.charCodeAt( offset + 1 ) >> 7 );\n    \n    var significand = 0.0;\n    var bit = 23;\n    var component = 1.0;\n    var b;\n    var mask;\n\n    while ( bit >= 0 )\n    {\n        if ( bit === 23 )\n        {\n            b = ( data.charCodeAt( offset + 1 ) & 0x7F ) | 0x80;\n            mask = 0x80; \n        }\n        else if ( bit === 15 )\n        {\n            b = data.charCodeAt( offset + 2 );\n            mask = 0x80; \n        }\n        else if ( bit === 7 )\n        {\n            b = data.charCodeAt( offset + 3 );\n            mask = 0x80; \n        }\n\t\n\t    if ( ( mask & b ) === mask )\n\t    {\n\t        significand += component;\n\t    }\n\n\t    component /= 2;\n\t    mask = mask >> 1;\n\t    bit--;\n    }\n\n    return Math.pow( -1, sign ) *\n           Math.pow( 2, exponent - 127 ) *\n           significand; \n}"},"getPositionAtTime":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"arc"},{"title":"param","description":null,"type":null,"name":"time"}]},"Source":"PULSE.TENNIS.getPositionAtTime = function ( arc, time )\n{\n    var tOffset = time;\n    var pos = arc.vectors[0];\n    var tt = tOffset;\n    var xdirection = 0;\n\n    for ( var i = 1; i < arc.vectors.length; i++ )\n    {\n        var vector = arc.vectors[i];\n        var scaledVector = { x:vector.x*tt, y:vector.y*tt, z:vector.z*tt };\n\n        pos = { x:pos.x + scaledVector.x, y:pos.y + scaledVector.y, z:pos.z + scaledVector.z };\n        tt *= tOffset;\n    }\n\n    if ( pos.z < 0.0 )\n    {\n    \tpos.z = 0.0;\n    }\n    \n    pos.dx = arc.dx;\n    return pos;\n}"},"getSpeedAtTime":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"arc"},{"title":"param","description":null,"type":null,"name":"time"}]},"Source":"PULSE.TENNIS.getSpeedAtTime = function ( arc, time )\n{\n    var tOffset = time;\n    var vel = {x:0,y:0,z:0};\n    var tt = 1.0;\n\n    for ( var i = 1; i < arc.vectors.length; i++ )\n    {\n        var vector = arc.vectors[i];\n        var scaledVector = { x:vector.x*tt, y:vector.y*tt, z:vector.z*tt };\n        scaledVector = { x:i*scaledVector.x, y:i*scaledVector.y, z:i*scaledVector.z };\n\n        vel = { x:vel.x + scaledVector.x, y:vel.y + scaledVector.y, z:vel.z + scaledVector.z };\n        tt *= tOffset;\n    }\n\n    return vel;\n}"},"linearMph":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"vel"}]},"Source":"PULSE.TENNIS.linearMph = function ( vel )\n{\n\tif ( vel )\n\t{\n\t\treturn Math.sqrt( ( vel.x * vel.x ) + ( vel.y * vel.y ) + ( vel.z * vel.z ) ) * \n\t    \t   2.23693629;\n\t}\n}"}}},"CricketBallTrajectory":{"Documentation":{"description":"Data type for a cricket ball trajectory. Parsers up-stream handle parsing from the various\ndifferent source formats.","tags":[]},"Source":"function CricketBallTrajectory()\n{\n}","prototype":{"getPositionAtTime":{"Documentation":{"description":"Gets the ball position at a particular time.","tags":[]},"Source":"CricketBallTrajectory.prototype.getPositionAtTime = function ( t )\n{\n\tvar time = t - this.bt;\n\n    if ( time > 0 )\n    {\n    \treturn { x: this.getX( this.bp.x, this.obv.x, this.oba.x, time ),\n    \t\t     y: this.getYorZ( this.bp.y, this.obv.y, this.oba.y, time ),\n    \t\t\t z: this.getYorZ( this.bh, this.obv.z, this.oba.z, time ) };\n    }\n    else\n    {\n    \treturn { x: this.getX( this.bp.x, this.ebv.x, this.a.x, time ),\n    \t\t\t y: this.getYorZ( this.bp.y, this.ebv.y, this.a.y, time ),\n    \t\t\t z: this.getYorZ( this.bh, this.ebv.z, this.a.z, time ) };\n    }\n}"},"getTimeAtX":{"Documentation":{"description":"Gets the time at a particular X position.","tags":[]},"Source":"CricketBallTrajectory.prototype.getTimeAtX = function ( x )\n{\n    if ( this.bp.x > x )\n    {\n    \treturn Math.log( ( ( x - this.bp.x ) * ( this.oba.x / this.obv.x ) ) + 1 ) / this.oba.x;\n    }\n    else\n    {\n    \treturn Math.log( ( ( x - this.bp.x ) * ( this.a.x / this.ebv.x ) ) + 1 ) / this.a.x;\n    }\n}"},"getX":{"Documentation":{"description":"Gets the x value at a specific time.","tags":[]},"Source":"CricketBallTrajectory.prototype.getX = function ( x, vx, ax, t )\n{\n    return x - ( vx * ( ( 1 - Math.exp( ax * t ) ) / ax ) );\n}"},"getYorZ":{"Documentation":{"description":"Gets the y or z values at a specific time.","tags":[]},"Source":"CricketBallTrajectory.prototype.getYorZ = function ( pos, velocity, accel, t )\n{\n    return pos + ( velocity * t ) + ( ( accel * t * t ) / 2 );\n}"}}},"PitchMapRenderer":{"Documentation":{"description":"*********","tags":[]},"Source":"function PitchMapRenderer ( config ) \n{\n\tthis.config = config;\n}","isSameCategory":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"PitchMapRenderer.isSameCategory"},{"title":"param","description":null,"type":null,"name":"a"},{"title":"param","description":null,"type":null,"name":"b"}]},"Source":"PitchMapRenderer.isSameCategory = function ( a, b )\n{\n\treturn ( a === b || ( a >= 1 && a <= 3 && b >= 1 && b <= 3 ) || ( a >= 4 && b >= 4 ) );\n}"},"prototype":{"isValid":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"row"}]},"Source":"PitchMapRenderer.prototype.isValid = function ( row )\n{\n\treturn true;\n}"},"render":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"db"},{"title":"param","description":null,"type":null,"name":"data"},{"title":"param","description":null,"type":null,"name":"ctx"}]},"Source":"PitchMapRenderer.prototype.render = function ( db, data, ctx )\n{\n\tthis.db = db;\n\tthis.data = this.prepareData( data );\n\tthis.ctx = ctx;\n\t\n\tthis.setSize( { x:0, y:0, width: ctx.canvas.canvas.width, height: ctx.canvas.canvas.height } );\n\t\n\tthis.tooltipData = undefined;\n\tthis.draw();\n}"},"setSize":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"sizeProperties"}]},"Source":"PitchMapRenderer.prototype.setSize = function ( sizeProperties )\n{\n\tif( !this.origConfig )\n\t{\n\t\tthis.origConfig = Utils.cloneObject( this.config );\n\n\t\t//sets some static values\n\t\tthis.origConfig.aspect = this.origConfig.width / this.origConfig.height;\n\t}\n\t\n\t//set current aspect ration\n\tthis.config.aspect = sizeProperties.width / sizeProperties.height;\n\t\n\tif( this.config.aspect >= this.origConfig.aspect )\n\t{\n\t\t//if this canvas is wider than the original\n\t\t//scale based on current height\n\t\tvar scale = this.config.scale = ( 1 / this.origConfig.height ) * sizeProperties.height;\n\t}\n\telse\n\t{\n\t\t//scale based on current width\n\t\tvar scale = this.config.scale = ( 1 / this.origConfig.width ) * sizeProperties.width;\n\t}\n\n\tthis.config.height \t= this.origConfig.height * scale;\n\tthis.config.width \t= this.origConfig.width * scale;\n\n\tthis.config.ballSize= Utils.numberToPixelString( Utils.pixelStringToNumber( this.origConfig.ballSize ) * scale > 11 ? 12 : 8 );\n\tthis.config.projection.fl = this.origConfig.projection.fl * scale;\n\tthis.config.projection.center.x = sizeProperties.width / 2;\n\tthis.config.projection.center.y = sizeProperties.height / 2;\n}"},"getColorKey":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"row"}]},"Source":"PitchMapRenderer.prototype.getColorKey = function ( row )\n{\n\treturn row.get( CricketField.IS_WICKET ) ? 'w' : row.get( CricketField.DEBIT );\n}"},"compare":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"a"},{"title":"param","description":null,"type":null,"name":"b"}]},"Source":"PitchMapRenderer.prototype.compare = function ( a, b )\n{\n\tvar aw = a.get( CricketField.IS_WICKET );\n\tvar bw = b.get( CricketField.IS_WICKET );\n\t\n\tif ( aw && !bw )\n\t{\n\t\treturn 1;\n\t}\n\telse if ( !aw && bw )\n\t{\n\t\treturn -1;\n\t}\n\telse\n\t{\n\t\tvar ar = +a.get( CricketField.DEBIT );\n\t\tvar br = +b.get( CricketField.DEBIT );\n\n\t\tif ( PitchMapRenderer.isSameCategory( ar, br ) )\n\t\t{\n\t\t\tif ( a.get( CricketField.PITCHED ) !== undefined && b.get( CricketField.PITCHED ) !== undefined )\n\t\t\t{\n\t\t\t\treturn ( +a.get( CricketField.PITCHED ).x ) - ( +b.get( CricketField.PITCHED ).x );\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn ar - br;\n\t\t}\n\t}\n\treturn 0;\n}"},"prepareData":{"Documentation":{"description":"This function sorts and projects the balls passed in. It results in an array\nof objects that each have a ball.x/y, a shadow.x/y and a color. It also sets the background image\nappropriately.","tags":[]},"Source":"PitchMapRenderer.prototype.prepareData = function ( data )\n{\n\tthis.tooltipDataCache = {};\n\n\t// Need to clone the array, so we can sort on BounceX\n\tvar dataArray = Utils.cloneArray( data );\n\t\n\t// Sort the array; also track handedness so we don't need to iterate again\n\tvar hasRight = false;\n\tvar hasLeft = false;\n\tvar that = this;\n\t\n\tdataArray.sort( function ( a, b ) \n\t{\n\t\tvar handedness = a.get( CricketField.HANDEDNESS );\n\t\tif ( !hasRight && CricketHandedness.RIGHT === handedness )\n\t\t{\n\t\t\thasRight = true;\n\t\t}\n\t\tif ( !hasLeft && CricketHandedness.LEFT === handedness )\n\t\t{\n\t\t\thasLeft = true;\n\t\t}\n\t\t\n\t\treturn that.compare( a, b );\n\t} );\n\t\n\t// Set background based upon hasLeft/hasRight\n\tif ( hasLeft && hasRight )\n\t{\n\t\tthis.controller.setBackground( this.config.variants.mix.background );\n\t}\n\telse if ( hasLeft )\n\t{\n\t\tthis.controller.setBackground( this.config.variants.lh.background );\n\t}\n\telse if ( hasRight )\n\t{\n\t\tthis.controller.setBackground( this.config.variants.rh.background );\n\t}\n\t\n\t// Iterate through sorted balls\n\tvar preparedData = [];\n\tfor ( var i = 0, j = dataArray.length; i < j; i++ )\n\t{\n\t\tvar row = dataArray[i];\n\t\tvar xyz = row.get( CricketField.PITCHED );\n\t\tif ( xyz !== undefined )\n\t\t{\n\t\t\t//if( !i )\n\t\t\t//{\n\t\t\t\txyz = this.db.normalise( xyz );\n\t\t\t\t\n\t\t\t\tif ( xyz.x > -999 && xyz.y > -999 && this.isValid( row ) )\n\t\t\t\t{\n\t\t\t\t\tvar shadow = this.config.projection.project( xyz );\n\t\t\t\t\txyz.z = 0.036;\n\t\t\t\t\t\n\t\t\t\t\t//TODO: remove following ball hacks\n\t\t\t\t\t//xyz.x = -10.06;\n\t\t\t\t\t//xyz.y = 0;\n\t\t\t\t\t\n\t\t\t\t\tvar ball = this.config.projection.project( xyz );\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\tif ( hasLeft && hasRight )\n\t\t\t\t\t{\n\t\t\t\t\t\tif ( CricketHandedness.LEFT === row.get( CricketField.HANDEDNESS ) )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tshadow.x += this.config.variants.lh.offset;\n\t\t\t\t\t\t\tball.x += this.config.variants.lh.offset;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tshadow.x += this.config.variants.rh.offset;\n\t\t\t\t\t\t\tball.x += this.config.variants.rh.offset;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tshadow.x -= 3;\n\t\t\t\t\tshadow.y += 1;\n\t\t\t\t\t\n\t\t\t\t\tvar colorKey = this.getColorKey( row );\n\t\t\t\t\tpreparedData.push( { ball:ball, shadow:shadow, color:this.config.colors[ colorKey ] } );\n\n\t\t\t\t\tthis.updateTooltipCache( ball, row );\n\t\t\t\t}\n\t\t\t//}\n\t\t}\n\t}\n\t\n\treturn preparedData;\n}"},"updateTooltipCache":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"ball"},{"title":"param","description":null,"type":null,"name":"row"}]},"Source":"PitchMapRenderer.prototype.updateTooltipCache = function ( ball, row )\n{\n\t// Update tooltip cache\n\tvar ix = Math.round( ball.x );\n\tvar iy = Math.round( ball.y );\t\t\t\t\n\tvar tx = this.tooltipDataCache[ ix ];\n\tif ( tx === undefined )\n\t{\n\t\ttx = {};\n\t\tthis.tooltipDataCache[ ix ] = tx;\n\t}\n\t\n\tvar lines = [];\n\tlines.push( '<c:#bbb>Ball </c>' + row.get( CricketField.INNINGS ) + '.' + \n\t\t\t( +row.get( CricketField.OVER ) - 1 ) + '.' +\n\t\t\trow.get( CricketField.COUNTING_BALL ) );\n\tlines.push( row.get( CricketField.BOWLER ) + \n\t\t\t' <c:#bbb>to </c>' + row.get( CricketField.BATSMAN ) );\n\t\n\tvar line3 = '';\n\t\n\tvar bs = row.get( CricketField.BOWL_SPEED );\n\tif ( !Utils.isNullish( bs ) && +bs >= 40 )\n\t{\n\t\tline3 += +bs.toFixed(1) + 'mph';\n\t}\n\t\n\tvar summary = row.generateSummary();\n\tif ( !Utils.isNullish( summary ) )\n\t{\n\t\tif ( line3.length > 0 )\n\t\t{\n\t\t\tline3 += ' <c:#bbb>resulting in </c>';\n\t\t}\n\t\tline3 += summary;\n\t}\n\t\n\tif ( !Utils.isNullish( line3 ) )\n\t{\n\t\tlines.push( line3 );\n\t}\n\t\n\tlines.push( '<c:#888>Click to view trajectory</c>' );\n\t\n\tvar ttd = { lines:lines, x:ix, y:iy, bp:row.get( CricketField.ID ) };\n\tthis.tooltipDataCache[ ix ][ iy ] = ttd;\n}"},"draw":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"PitchMapRenderer.prototype.draw = function () \n{\n\tthis.ctx.canvas.clearRect( 0, 0, this.ctx.canvas.canvas.width, this.ctx.canvas.canvas.height );\n\t\t\n\t// Render all the shadows first\n\tthis.ctx.canvas.save();\n\tthis.ctx.canvas.scale( 1, 0.6 );\n\tthis.ctx.canvas.fillStyle = 'rgba(0,0,0,0.3)';\n\tfor ( var i = 0, j = this.data.length; i < j; i++ )\n\t{\n\t\tthis.ctx.canvas.beginPath();\n\t\tUtils.circle( this.ctx.canvas, this.data[i].shadow.x, this.data[i].shadow.y / 0.6, 3 );\n\t\tthis.ctx.canvas.fill();\n\t}\n\tthis.ctx.canvas.restore();\n\t\n\t// Define render callback function\n\tvar that = this;\n\tvar callback = function () { that.draw(); };\n\t\n\t// Render all the balls next\n\tfor ( var i = 0, j = this.data.length; i < j; i++ )\n\t{\n\t\tPULSE.BallRenderer.render( this.ctx.canvas, this.data[i].ball.x, this.data[i].ball.y, this.data[i].color, \n\t\t\t\tthis.config.ballSize, callback );\n\t}\n\t\n\t// Finally render the tooltip data\n\tif ( this.tooltipData !== undefined )\n\t{\n\t\tvar cfg = this.config.tooltip;\n\t\tvar anchorv = 'n';\n\t\tvar anchorh = 'w';\n\t\t\n\t\tif ( this.tooltipData.x > this.config.width / 2 )\n\t\t{\n\t\t\tanchorh = 'e';\n\t\t}\n\t\tif ( this.tooltipData.y > this.config.height / 2 )\n\t\t{\n\t\t\tanchorv = 's';\n\t\t}\n\t\t\n\t\tcfg.position = { x:this.tooltipData.x, y:this.tooltipData.y, anchor:anchorv + anchorh };\n\t\t\n\t\tvar tf = new PULSE.TextField( cfg );\n\t\ttf.setLines( this.tooltipData.lines );\n\t\ttf.render( this.ctx.canvas );\n\t}\n}","callback":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"var callback = function () { that.draw(); }"}},"onMouse":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"event"}]},"Source":"PitchMapRenderer.prototype.onMouse = function ( event )\n{\n\t// Get XY and then infer ball\n\tvar xy = Utils.getXY( event );\n\tif ( xy !== undefined )\n\t{\n\t\tvar tooltipData = this.findNearbyTooltip( xy );\n\t\tif ( 'mousedown' === event.type )\n\t\t{\n\t\t\tif ( tooltipData !== undefined )\n\t\t\t{\n\t\t\t\tthis.controller.showTrajectory( tooltipData.bp );\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif ( this.tooltipData !== tooltipData )\n\t{\n\t\tthis.tooltipData = tooltipData;\n\t\tthis.draw();\n\t}\n}"},"findNearbyTooltip":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"xy"}]},"Source":"PitchMapRenderer.prototype.findNearbyTooltip = function ( xy )\n{\n\tfor ( var s = 0; s < 4; s++ )\n\t{\n\t\tfor ( var x = xy.x - s; x <= xy.x + s; x++ )\n\t\t{\n\t\t\tfor ( var y = xy.y - s; y <= xy.y + s; y++ )\n\t\t\t{\n\t\t\t\tif ( this.tooltipDataCache[ x ] !== undefined &&\n\t\t\t\t\t this.tooltipDataCache[ x ][ y ] !== undefined )\n\t\t\t\t{\n\t\t\t\t\treturn this.tooltipDataCache[ x ][ y ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"}}},"VariableBounceRenderer":{"Documentation":{"description":"***************","tags":[]},"Source":"function VariableBounceRenderer ( config ) \n{\n\tthis.config = config;\n}","prototype":{"getColorKey":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"row"}]},"Source":"VariableBounceRenderer.prototype.getColorKey = function ( row )\n{\n\tvar stumps = row.get( CricketField.STUMPS );\n\tif ( row.get( CricketField.IS_WICKET ) )\n\t{\n\t\treturn 'w';\n\t}\n\telse if ( stumps.z > 0.745 )\n\t{\n\t\treturn 'a';\n\t}\n\telse\n\t{\n\t\treturn 's';\n\t}\n}"},"isValid":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"row"}]},"Source":"VariableBounceRenderer.prototype.isValid = function ( row )\n{\n\tvar pitched = row.get( CricketField.PITCHED );\n\tvar stumps = row.get( CricketField.STUMPS );\n\t\n\tif ( pitched !== undefined && stumps !== undefined )\n\t{\n\t\tvar xyz = { x:pitched.x, y:pitched.y, z:stumps.z };\n\t\txyz = this.db.normalise( xyz );\n\t\t\n\t\treturn xyz.x > -999 && xyz.y > -999 && xyz.z > -999;\n\t}\n\t\n\treturn false;\n}"},"compare":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"a"},{"title":"param","description":null,"type":null,"name":"b"}]},"Source":"VariableBounceRenderer.prototype.compare = function ( a, b )\n{\n\tvar aw = a.get( CricketField.IS_WICKET );\n\tvar bw = b.get( CricketField.IS_WICKET );\n\t\n\tif ( aw && !bw )\n\t{\n\t\treturn 1;\n\t}\n\telse if ( !aw && bw )\n\t{\n\t\treturn -1;\n\t}\n\telse\n\t{\n\t\tif ( a.get( CricketField.PITCHED ) !== undefined && b.get( CricketField.PITCHED ) !== undefined )\n\t\t{\n\t\t\treturn +a.get( CricketField.PITCHED ).x - +b.get( CricketField.PITCHED ).x;\n\t\t}\n\t}\n\treturn 0;\n}"}}},"SpeedPitchMapRenderer":{"Documentation":{"description":"***************","tags":[]},"Source":"function SpeedPitchMapRenderer ( config ) \n{\n\tthis.config = config;\n}","prototype":{"getColorKey":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"row"}]},"Source":"SpeedPitchMapRenderer.prototype.getColorKey = function ( row )\n{\n\tvar speed = +row.get( CricketField.BOWL_SPEED );\n\t\n\t// Convert speed to units currently in use\n    if ( PULSE.SpeedModeController.mode === PULSE.SpeedModeController.MODE_KMH )\n    {\n    \tspeed = PULSE.SpeedModeController.mpsToKmh( speed );\n    }\n\t\n\tfor ( var b = 0, c = this.config.buckets.length; b < c; b++ )\n\t{\n\t\tif ( speed < this.config.buckets[b] )\n\t\t{\n\t\t\treturn b;\n\t\t}\n\t}\n\t\n\treturn this.config.buckets.length;\n}"},"isValid":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"row"}]},"Source":"SpeedPitchMapRenderer.prototype.isValid = function ( row )\n{\n\tvar bs = row.get( CricketField.BOWL_SPEED ),\n\t\tthreshold = 40;\n\t\n\tif ( PULSE.SpeedModeController.mode === PULSE.SpeedModeController.MODE_KMH )\n    {\n\t\tbs \t\t\t= PULSE.SpeedModeController.mpsToKmh( bs );\n\t\tthreshold \t= 10;\n    }\n\t\n\treturn !Utils.isNullish( bs ) && +bs >= 40;\n}"},"compare":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"a"},{"title":"param","description":null,"type":null,"name":"b"}]},"Source":"SpeedPitchMapRenderer.prototype.compare = function ( a, b )\n{\n\tif ( a.get( CricketField.PITCHED ) !== undefined && b.get( CricketField.PITCHED ) !== undefined )\n\t{\n\t\treturn ( +a.get( CricketField.PITCHED ).x ) - ( +b.get( CricketField.PITCHED ).x );\n\t}\n\treturn 0;\n}"}}},"PitchMapMountainRenderer":{"Documentation":{"description":"******************","tags":[]},"Source":"function PitchMapMountainRenderer ( config ) \n{\n\tthis.config = config;\n}","prototype":{"bucketise":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"x"},{"title":"param","description":null,"type":null,"name":"y"}]},"Source":"PitchMapMountainRenderer.prototype.bucketise = function ( x, y )\n{\n\tif ( x >= this.config.boundary.x.min && x <= this.config.boundary.x.max &&\n\t\t y >= this.config.boundary.y.min && y <= this.config.boundary.y.max )\n\t{\n\t\treturn { x : Math.floor( ( x - this.config.boundary.x.min ) / this.config.bucketSize ),\n\t\t\t     y : Math.floor( ( y - this.config.boundary.y.min ) / this.config.bucketSize ) };\n\t}\n}"},"render":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"db"},{"title":"param","description":null,"type":null,"name":"data"},{"title":"param","description":null,"type":null,"name":"ctx"}]},"Source":"PitchMapMountainRenderer.prototype.render = function ( db, data, ctx )\n{\n\tthis.projectedPoints = {};\n\n\tthis.ctx = ctx;\n\tthis.db = db;\n\t\n\tctx.canvas.clearRect( 0, 0, this.config.width, this.config.height );\n\t\n\tvar bubble1 = Math.sqrt( 8 ) / 3;\n\tvar bubble2 = Math.sqrt( 7 ) / 3;\n\tvar bubble3 = Math.sqrt( 5 ) / 3;\n\tvar bubble4 = 2 / 3;\n\tvar bubble5 = 1 / 3;\n\t\n\t// Bucketise the data\n\tvar heights = {};\n\tvar total = 0;\n\tfor ( var i = 0, j = data.length; i < j; i++ )\n\t{\n\t\tvar row = data[i];\n\t\tvar xyz = row.get( CricketField.PITCHED );\n\t\t\n\t\tif ( xyz !== undefined )\n\t\t{\n\t\t\tvar bucket = this.bucketise( xyz.x, xyz.y );\n\t\t\tif ( bucket !== undefined )\n\t\t\t{\n\t\t\t\tvar x = bucket.x;\n\t\t\t\tvar y = bucket.y;\n\t\t\t\t// Centre point\n\t\t\t\tthis.incrementBucket( heights, x, y, 1 );\n\t\t\t\t// Points one unit away\n\t\t\t\tthis.incrementBucket( heights, x - 1, y, bubble1 );\n\t\t\t\tthis.incrementBucket( heights, x + 1, y, bubble1 );\n\t\t\t\tthis.incrementBucket( heights, x, y - 1, bubble1 );\n\t\t\t\tthis.incrementBucket( heights, x, y + 1, bubble1 );\n\t\t\t\t// Points two steps away (diagonally)\n\t\t\t\tthis.incrementBucket( heights, x - 1, y - 1, bubble2 );\n\t\t\t\tthis.incrementBucket( heights, x - 1, y + 1, bubble2 );\n\t\t\t\tthis.incrementBucket( heights, x + 1, y - 1, bubble2 );\n\t\t\t\tthis.incrementBucket( heights, x + 1, y + 1, bubble2 );\n\t\t\t\t// Points two steps away (linearly)\n\t\t\t\tthis.incrementBucket( heights, x - 2, y, bubble3 );\n\t\t\t\tthis.incrementBucket( heights, x + 2, y, bubble3 );\n\t\t\t\tthis.incrementBucket( heights, x, y - 2, bubble3 );\n\t\t\t\tthis.incrementBucket( heights, x, y + 2, bubble3 );\n\t\t\t\t// Points three steps away\n\t\t\t\tthis.incrementBucket( heights, x - 2, y + 1, bubble4 );\n\t\t\t\tthis.incrementBucket( heights, x - 2, y - 1, bubble4 );\n\t\t\t\tthis.incrementBucket( heights, x + 2, y + 1, bubble4 );\n\t\t\t\tthis.incrementBucket( heights, x + 2, y - 1, bubble4 );\n\t\t\t\tthis.incrementBucket( heights, x - 1, y + 2, bubble4 );\n\t\t\t\tthis.incrementBucket( heights, x + 1, y + 2, bubble4 );\n\t\t\t\tthis.incrementBucket( heights, x - 1, y - 2, bubble4 );\n\t\t\t\tthis.incrementBucket( heights, x + 1, y - 2, bubble4 );\n\t\t\t\t// Points four steps away\n\t\t\t\tthis.incrementBucket( heights, x - 2, y - 2, bubble5 );\n\t\t\t\tthis.incrementBucket( heights, x - 2, y + 2, bubble5 );\n\t\t\t\tthis.incrementBucket( heights, x + 2, y - 2, bubble5 );\n\t\t\t\tthis.incrementBucket( heights, x + 2, y + 2, bubble5 );\n\n\t\t\t\ttotal++;\n\t\t\t}\n\t\t}\n\t}\n\n\tvar triangles = [];\n\t\n\tif ( total > 0 )\n\t{\n\t\tvar xs = ( this.config.boundary.x.max - this.config.boundary.x.min ) / this.config.bucketSize;\n\t\tvar ys = ( this.config.boundary.y.max - this.config.boundary.y.min ) / this.config.bucketSize;\n\t\t\n\t\t// Quickly loop over all the points and work out the max height\n\t\tvar maxHeight = 0;\n\t\tfor ( var x = 0; x <= xs; x++ )\n\t\t{\n\t\t\tfor ( var y = 0; y <= ys; y++ )\n\t\t\t{\n\t\t\t\tmaxHeight = Math.max( maxHeight, this.getHeight( heights, x, y ) );\n\t\t\t}\n\t\t}\n\t\tif ( maxHeight == 0 )\n\t\t{\n\t\t\tmaxHeight = 1;\n\t\t}\n\t\t\n\t\tmaxHeight /= this.config.maxHeight;\n\t\t\n\t\tfor ( var x = 0; x <= xs; x++ )\n\t\t{\n\t\t\tvar xpos1 = this.config.boundary.x.min + ( x * this.config.bucketSize );\n\t\t\tvar xpos2 = xpos1 + this.config.bucketSize;\n\t\t\tfor ( var y = 0; y <= ys; y++ )\n\t\t\t{\n\t\t\t\tvar ypos1 = this.config.boundary.y.min + ( y * this.config.bucketSize );\n\t\t\t\tvar ypos2 = ypos1 + this.config.bucketSize;\n\t\t\t\t\n\t\t\t\t// Get the height at the four corners\n\t\t\t\tvar height1 = this.getHeight( heights, x, y ) / maxHeight;\n\t\t\t\tvar height2 = this.getHeight( heights, x + 1, y ) / maxHeight;\n\t\t\t\tvar height3 = this.getHeight( heights, x, y + 1 ) / maxHeight;\n\t\t\t\tvar height4 = this.getHeight( heights, x + 1, y + 1 ) / maxHeight;\n\t\t\t\t\n\t\t\t\t// Triangle 1\n\t\t\t\tif ( height2 > 0 || height3 > 0 || height4 > 0 )\n\t\t\t\t{\n\t\t\t\t\ttriangles.push( {\n\t\t\t\t\t\tp1 : { x: xpos2, y: ypos1, z: height2 },\n\t\t\t\t\t\tp2 : { x: xpos2, y: ypos2, z: height4 },\n\t\t\t\t\t\tp3 : { x: xpos1, y: ypos2, z: height3 }\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Triangle 2\n\t\t\t\tif ( height1 > 0 || height2 > 0 || height3 > 0 )\n\t\t\t\t{\n\t\t\t\t\ttriangles.push( {\n\t\t\t\t\t\tp1 : { x: xpos1, y: ypos1, z: height1 },\n\t\t\t\t\t\tp2 : { x: xpos2, y: ypos1, z: height2 },\n\t\t\t\t\t\tp3 : { x: xpos1, y: ypos2, z: height3 }\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tthis.renderMesh( triangles );\n\t}\n}"},"incrementBucket":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"heights"},{"title":"param","description":null,"type":null,"name":"x"},{"title":"param","description":null,"type":null,"name":"y"},{"title":"param","description":null,"type":null,"name":"amount"}]},"Source":"PitchMapMountainRenderer.prototype.incrementBucket = function ( heights, x, y, amount )\n{\n\tif ( heights[ x ] === undefined )\n\t{\n\t\theights[ x ] = {};\n\t}\n\tif ( heights[ x ][ y ] === undefined )\n\t{\n\t\theights[ x ][ y ] = 0;\n\t}\n\n\theights[ x ][ y ] += amount;\n}"},"getHeight":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"heights"},{"title":"param","description":null,"type":null,"name":"x"},{"title":"param","description":null,"type":null,"name":"y"}]},"Source":"PitchMapMountainRenderer.prototype.getHeight = function ( heights, x, y )\n{\n\tvar height = 0;\n\tif ( heights[ x ] !== undefined && heights[ x ][ y ] !== undefined )\n\t{\n\t\theight = heights[ x ][ y ];\n\t}\n\treturn height;\n}"},"renderMesh":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"triangles"}]},"Source":"PitchMapMountainRenderer.prototype.renderMesh = function( triangles )\n{\n\tthis.ctx.canvas.save();\n\tthis.ctx.canvas.lineJoin = 'round';\n\t\n\tfor ( var i = 0, limit = triangles.length; i < limit; i++ )\n\t{\n\t\tvar triangle = triangles[ i ];\n\t\t\n\t\tvar p1 = this.db.normalise( { x:triangle.p1.x, y:triangle.p1.y, z:triangle.p1.z } );\n\t\tvar p2 = this.db.normalise( { x:triangle.p2.x, y:triangle.p2.y, z:triangle.p2.z } );\n\t\tvar p3 = this.db.normalise( { x:triangle.p3.x, y:triangle.p3.y, z:triangle.p3.z } );\n\t\t\n\t\tvar d1 = { x: p2.x - p1.x, y: p2.y - p1.y, z: p2.z - p1.z };\n\t\tvar d2 = { x: p3.x - p2.x, y: p3.y - p2.y, z: p3.z - p2.z };\n\t\t\n\t\t// Calculate the normal vector for the triangle using the cross product\n\t\tvar crossProduct = { x: d1.y * d2.z - d1.z * d2.y,\n\t\t\t\t             y: d1.z * d2.x - d1.x * d2.z,\n\t\t\t\t             z: d1.x * d2.y - d1.y * d2.x };\n\t\t// Work out the length of the vector\n\t\tvar crossProductSize = Math.sqrt( crossProduct.x * crossProduct.x + \n\t\t\t\tcrossProduct.y * crossProduct.y + crossProduct.z * crossProduct.z );\n\t\t// Normalise the cross product vector\n\t\tcrossProduct.x /= crossProductSize;\n\t\tcrossProduct.y /= crossProductSize;\n\t\tcrossProduct.z /= crossProductSize;\n\t\t\n\t\t// Work out the dot product of the normal and light vector to work out the angle between them\n\t\tvar dotProduct = crossProduct.x * this.config.light.x + \n\t\t                 crossProduct.y * this.config.light.y +\n\t\t                 crossProduct.z * this.config.light.z;\n\t\t\n\t\tif ( dotProduct < 0 )\n\t\t{\n\t\t\t// The triangle is facing away from the camera, so skip this one\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tdotProduct = dotProduct * this.config.lightStrength + 1 - this.config.lightStrength;\n\t\t\n\t\tvar color = { r : dotProduct * this.config.color.r,\n\t\t\t\t      g : dotProduct * this.config.color.g,\n\t\t\t\t      b : dotProduct * this.config.color.b };\n\t\t\n\t\tvar colorString = 'rgba(' + +Math.round( color.r * 255 ) + ',' + +Math.round( color.g * 255 ) + ',' + +Math.round( color.b * 255 ) + ', 1)';\n\t\tthis.ctx.canvas.fillStyle = colorString;\n\t\tthis.ctx.canvas.strokeStyle = colorString;\n\t\t\n\t\tthis.ctx.canvas.beginPath();\n\t\t\n\t\tvar pos1 = this.project( p1 );\n\t\tvar pos2 = this.project( p2 );\n\t\tvar pos3 = this.project( p3 );\n\t\tthis.ctx.canvas.moveTo( pos1.x, pos1.y );\n\t\tthis.ctx.canvas.lineTo( pos2.x, pos2.y );\n\t\tthis.ctx.canvas.lineTo( pos3.x, pos3.y );\n\t\t\n\t\tthis.ctx.canvas.closePath();\n\t\t\n\t\tthis.ctx.canvas.fill();\n\t\tthis.ctx.canvas.stroke();\n\t}\n\t\n\tthis.ctx.canvas.restore();\n}"},"project":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"xyz"}]},"Source":"PitchMapMountainRenderer.prototype.project = function ( xyz )\n{\n\t// This projects a world point to a screen point, but caches the result so that subsequent\n\t// invocations are quicker\n\n\tvar key = xyz.x + ',' + xyz.y + ',' + xyz.z;\n\tvar projected = this.projectedPoints[ key ];\n\t\n\tif ( !projected )\n\t{\n\t\tprojected = this.config.projection.project( xyz );\n\t\tthis.projectedPoints[ key ] = projected;\n\t}\n\t\n\treturn projected;\n}"}}},"WagonWheelRenderer":{"Documentation":{"description":"***********","tags":[]},"Source":"function WagonWheelRenderer ( config )\n{\n\tthis.config = config;\n\tthis.selected = -1;\n}","prototype":{"render":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"WagonWheelRenderer.prototype.render"},{"title":"param","description":null,"type":null,"name":"db"},{"title":"param","description":null,"type":null,"name":"data"},{"title":"param","description":null,"type":null,"name":"ctx"}]},"Source":"WagonWheelRenderer.prototype.render = function ( db, data, ctx )\n{\n\tthis.db = db;\n\tthis.data = data;\n\tthis.ctx = ctx;\n\tthis.selected = -1;\n\tthis.draw();\n}"},"draw":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"WagonWheelRenderer.prototype.draw = function () \n{\t\n\tthis.ctx.canvas.clearRect( 0, 0, this.config.width, this.config.height );\n\n\t// Get the scales\n\tvar yscale = this.config.scale.y;\n\tvar xscale = this.config.scale.x;\n\t\n\tvar screenOrigin = this.config.transform( 0, 0, 1 );\n\tthis.ctx.canvas.save();\n\tthis.ctx.canvas.beginPath();\n\tthis.ctx.canvas.scale( xscale, yscale );\n\tUtils.circle( this.ctx.canvas, ( screenOrigin.x / xscale ), 2 + ( screenOrigin.y / yscale ), 184 );\n\tthis.ctx.canvas.restore();\n\n\tthis.ctx.canvas.save();\n\tthis.ctx.canvas.clip();\n\n\tthis.ctx.canvas.lineWidth = 3;\n\tthis.ctx.canvas.strokeStyle = 'rgba(0,0,0,1)';\n\n\tvar sign = this.db.getParameter( 'ww-sign' );\n\tvar origin = this.config.transform( this.db.getParameter( 'ww-origin-x' ), 0, sign );\n\t\n\t// Stats object which is used to populate the annotated key\n\tvar stats = { runs:0, balls:0, scoring:0, runsleg:0, runsoff:0,\n\t\t\t\t  singles:0, twothrees:0, fours:0, sixes:0 };\n\n\t// Clone the data so we can sort on number of runs; singles are nearest the top, as other\n\t// shots will typically be longer and poke out from underneath; the exception is that 6s\n\t// should appear on top of 4/5s\n\tvar dataArray = Utils.cloneArray( this.data );\n\t\n\t// Sort the array\n\tdataArray.sort( function ( a, b ) \n\t{\n\t\tvar ar = +a.get( CricketField.CREDIT );\n\t\tvar br = +b.get( CricketField.CREDIT );\n\t\t\n\t\tif ( ar === 6 && br >= 4 )\n\t\t{\n\t\t\treturn ar - br;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn br - ar;\n\t\t}\n\t} );\n\t\n\tfor ( var i = 0, j = dataArray.length; i < j; i++ )\n\t{\n\t\tvar row = dataArray[i];\n\n        var extraType = row.get( CricketField.EXTRA_TYPE );\n\t\t// ignore wide and wide-bye balls as they are not batsman-faced-balls\n        if ( extraType !== \"Wd\" && extraType !== \"WdB\" )\n        {\n            stats.balls++;\n        } \n\t\t\n\t\tvar landing = row.get( CricketField.WW );\n\t\tif ( landing !== undefined && landing.x > -999 && landing.y > -999 )\n\t\t{\n\t\t\tvar runs = ( +row.get( CricketField.CREDIT ) );\n\t\t\tif ( runs > 0 )\n\t\t\t{\n\t\t\t\t// Update stats\n\t\t\t\tstats.scoring++;\n\t\t\t\tstats.runs += runs;\n\t\t\t\t\n\t\t\t\tswitch ( runs )\n\t\t\t\t{\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tstats.singles++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tstats.twothrees++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\tcase 5:\n\t\t\t\t\t\tstats.fours++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 6:\n\t\t\t\t\t\tstats.sixes++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar lh = ( row.get( CricketField.HANDEDNESS ) === CricketHandedness.LEFT );\n\t\t\t\tif ( ( lh && landing.y < 0 ) || ( !lh && landing.y >= 0 ) )\n\t\t\t\t{\n\t\t\t\t\tstats.runsleg += runs;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstats.runsoff += runs;\n\t\t\t\t}\n\n\t\t\t\tif ( this.shouldDraw( runs ) )\n\t\t\t\t{\n\t\t\t\t\t// Transform to screen position\n\t\t\t\t\tvar screenPos = this.config.transform( landing.x, landing.y, sign );\n\t\t\t\t\t\n\t\t\t\t\t// Scale to ensure 4+ runs go to the rope\n\t\t\t\t\tif ( runs >= 4 )\n\t\t\t\t\t{\n\t\t\t\t\t\tscreenPos = Utils.scaleLine( origin, screenPos, 200 );\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tvar len = this.config.scaleback ? this.config.scaleback.length : 170;\n\t\t\t\t\t\tvar amt = this.config.scaleback ? this.config.scaleback.amount : 0.8;\n\t\t\t\t\t\t\n\t\t\t\t\t\tscreenPos = Utils.scaleLineRel( origin, screenPos, len, amt );\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.ctx.canvas.beginPath();\n\t\t\t\t\tvar gradient = this.ctx.canvas.createRadialGradient( origin.x, origin.y, 0, origin.x, origin.y, 50 );\n\t\t\t\t\tgradient.addColorStop( 0, this.config.colors[ runs ][0] );\n\t\t\t\t\tgradient.addColorStop( 1, this.config.colors[ runs ][1] );\n\t\t\t\t\tthis.ctx.canvas.strokeStyle = gradient;\n\t\t\t\t\t\n\t\t\t\t\t// Special-case the Raphael implementation, that doesn't have a gradient stroke\n\t\t\t\t\t// so let's move the start of the line away from the origin slightly\n\t\t\t\t\tif ( this.config.innerClip )\n\t\t\t\t\t{\n\t\t\t\t\t\tvar newOrigin = WagonWheelRenderer.pointDownLine( origin, screenPos, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  this.config.innerClip );\n\t\t\t\t\t\tthis.ctx.canvas.moveTo( newOrigin.x, newOrigin.y ); \n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.ctx.canvas.moveTo( origin.x, origin.y );\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tthis.ctx.canvas.lineTo( screenPos.x, screenPos.y );\n\t\t\t\t\tthis.ctx.canvas.stroke();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Convert runs to leg/off to percentages\n\tvar tot = stats.runsleg + stats.runsoff;\n\tif ( tot > 0 )\n\t{\n\t\tstats.runsleg = ( Math.round( 100 * stats.runsleg / tot ) );\n\t\tstats.runsoff = ( 100 - stats.runsleg ) + '%';\n\t\tstats.runsleg += '%';\n\t}\n\telse\n\t{\n\t\tstats.runsleg = '';\n\t\tstats.runsoff = '';\n\t}\n\t\n\t// Write stats annotations\n\tthis.ctx.canvas.restore();\n\tthis.ctx.canvas.font = this.config.font;\n\tthis.ctx.canvas.fillStyle = 'black';\n\tfor ( var key in stats )\n\t{\n\t\tif ( key !== 'x' )\n\t\t{\n\t\t\tvar cfg = this.config.key[ key ];\n\t\t\t\n\t\t\tvar color = cfg.color;\n\t\t\tvar color2 = cfg.lcolor || cfg.color;\n\t\t\t\t\t\t\n\t\t\tif ( this.config.keyDisplayMode === 'values' )\n\t\t\t{\n\t\t\t\tthis.ctx.canvas.fillStyle = color2;\n\t\t\t\tUtils.anchoredFillText( this.ctx.canvas, stats[ key ], this.config.key.x[0], cfg.y, 'w' );\n\t\t\t}\n\t\t\telse if ( this.config.keyDisplayMode === 'labelsandvalues' )\n\t\t\t{\n\t\t\t\tthis.ctx.canvas.fillStyle = color2;\n\t\t\t\tUtils.anchoredFillText( this.ctx.canvas, cfg.label, this.config.key.x[0], cfg.y, 'w' );\n\t\t\t\tthis.ctx.canvas.fillStyle = color;\n\t\t\t\tUtils.anchoredFillText( this.ctx.canvas, stats[ key ], this.config.key.x[1], cfg.y, 'e' );\n\t\t\t}\t\t\t\t\t\t\t\t\n\t\t}\n\t}\n\t\n\t// Now write any freetext\n\tif ( this.config.freetext )\n\t{\n\t\tvar tf = new PULSE.TextField( this.config.freetext );\n\t\ttf.addLine( this.config.freetext.text );\n\t\ttf.render( this.ctx.canvas );\n\t}\n}"},"shouldDraw":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"runs"}]},"Source":"WagonWheelRenderer.prototype.shouldDraw = function ( runs )\n{\n\treturn ( this.selected === -1 ) ||\n\t\t   ( this.selected === 0 && runs === 1 ) ||\n\t\t   ( this.selected === 1 && ( runs === 2 || runs === 3 ) ) ||\n\t\t   ( this.selected === 2 && ( runs === 4 || runs === 5 ) ) ||\n\t\t   ( this.selected === 3 && runs === 6 );\n}"},"onMouse":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"event"}]},"Source":"WagonWheelRenderer.prototype.onMouse = function ( event )\n{\n\t// Get XY and then infer run class selection index\n\tvar xy = Utils.getXY( event );\n\tvar selection = -1;\n\t\n\tif ( xy !== undefined && xy.x >= this.config.keyLabelLeftLimit && xy.x <= this.config.keyLabelRightLimit\n\t\t\t&& xy.y >= this.config.keyLabelTopLimit && xy.y <= this.config.keyLabelBottomLimit )\n\t{\n\t\tselection = Math.floor( ( xy.y - this.config.keyLabelTopLimit ) / this.config.keyLabelWidth );\n\t}\n\t\n\tif ( selection !== this.selected )\n\t{\n\t\tthis.selected = selection;\n\t\tthis.draw();\n\t}\n}"}},"pointDownLine":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"start"},{"title":"param","description":null,"type":null,"name":"end"},{"title":"param","description":null,"type":null,"name":"amount"},{"title":"param","description":null,"type":null,"name":"isFraction"}]},"Source":"WagonWheelRenderer.pointDownLine = function ( start, end, amount, isFraction )\n{\n\tvar dx = end.x - start.x;\n\tvar dy = end.y - start.y;\n\t\n\tif ( isFraction )\n\t{\n\t\treturn { x: start.x + ( amount * dx ), \n\t\t\t     y: start.y + ( amount * dy ) };\n\t}\n\telse\n\t{\n\t\tvar theta = Math.atan2( dy, dx );\n\t\tif ( Math.sqrt( ( dx * dx ) + ( dy * dy ) ) <= amount ) \n\t\t{\n\t\t\treturn { x: end.x + ( 3 * Math.cos( theta ) ),\n\t\t\t\t     y: end.y + ( 3 * Math.sin( theta ) ) };\n\t\t\t// Ignore, as the current length is smaller than the target\n\t\t\t//return end;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn { x: start.x + ( amount * Math.cos( theta ) ),\n\t\t\t\t\t y: start.y + ( amount * Math.sin( theta ) ) };\n\t\t}\n\t}\n}"}},"TrajectoryRenderer":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"TrajectoryRenderer"},{"title":"param","description":null,"type":null,"name":"config"}]},"Source":"function TrajectoryRenderer ( config )\n{\n    this.config = config;\n    this.timerId = null;\n    this.animationPeriod = null;\n    this.time = null;\n    this.speed = config.speed;\n    this.viewIndex = 0;\n    \n    // Configurable properties of the renderer\n    this.defer = true;\n    this.renderBounce = true;\n    this.renderEnd = true;\n\n    TrajectoryRenderer.prototype.augmentConfig = function ()\n    {\n        if ( this.viewIndex < this.config.views.length )\n        {\n            var subconfig = this.config.views[ this.viewIndex ];\n            for ( var property in subconfig )\n            {\n                this.config[ property ] = subconfig[ property ];\n            }\n        }\n    };\n\n    this.augmentConfig();\n}","prototype":{"augmentConfig":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"TrajectoryRenderer.prototype.augmentConfig = function ()\n    {\n        if ( this.viewIndex < this.config.views.length )\n        {\n            var subconfig = this.config.views[ this.viewIndex ];\n            for ( var property in subconfig )\n            {\n                this.config[ property ] = subconfig[ property ];\n            }\n        }\n    }"},"setView":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"viewIndex"}]},"Source":"TrajectoryRenderer.prototype.setView = function ( viewIndex )\n{\n    this.resetRendering();\n    this.viewIndex = viewIndex;\n    this.augmentConfig();\n    this.controller.setBackground( this.config.background );\n    this.controller.setMask( this.config.mask );\n}"},"nextView":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"TrajectoryRenderer.prototype.nextView = function ()\n{\n    var viewIndex = this.viewIndex + 1;\n    if ( viewIndex >= this.config.views.length )\n    {\n        viewIndex = 0;\n    }\n    this.setView( viewIndex );\n}"},"setSpeed":{"Documentation":{"description":"This function augments the renderers configuration with the configuration contained in\nthe current view.","tags":[]},"Source":"TrajectoryRenderer.prototype.setSpeed = function ( speed )\n{\n    this.speed = speed;\n}"},"showDescription":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"TrajectoryRenderer.prototype.showDescription = function ()\n{\n    if ( this.data.length > this.activeBall )\n    {\n        PULSE.GraphController.setInfo( this.data[ this.activeBall ].generateDescription(), true ); \n    }\n}"},"render":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"db"},{"title":"param","description":null,"type":null,"name":"data"},{"title":"param","description":null,"type":null,"name":"ctx"},{"title":"param","description":null,"type":null,"name":"immediate"}]},"Source":"TrajectoryRenderer.prototype.render = function ( db, data, ctx, immediate )\n{\n    PULSE.Tracer.info( 'TrajectoryRenderer.render called with immediate=' + immediate );\n    \n    // Ensure view is correctly set \n    this.augmentConfig();\n    this.controller.setBackground( this.config.background );\n    this.controller.setMask( this.config.mask );\n    \n    if ( this.defer && !immediate )\n    {\n        // If there is no data, return\n        if ( data === undefined || data === null || data.length === 0 )\n        {\n            PULSE.Tracer.info( 'No data, returning' );\n            return;\n        }\n        // Never render this data immediately, unless this is the first render attempt, as it\n        // will force the animation to restart.\n        else if ( this.deferredRenderCall !== undefined )\n        {\n            // We have previously set data, so save the call as deferred and return. The deferred\n            // data will be used once the current animation loop has ended.\n            PULSE.Tracer.info( 'Deferring call' );\n            \n            this.deferredRenderCall = { db:db, data:data, ctx:ctx };\n            return;\n        }\n        else\n        {\n            // Otherwise continue, but give the deferred data a null value so that we know we\n            // have now rendered\n            PULSE.Tracer.info( 'Continuing' );\n            \n            this.deferredRenderCall = null;\n        }\n    }\n    \n    // Save balls, up to the maximum\n    if ( this.config.maxBalls !== undefined )\n    {\n        this.data = data.slice( 0, this.config.maxBalls ); \n    }\n    else\n    {\n        this.data = data;\n    }\n\n    // Only use balls that have valid trajectories\n    var validData = [];\n    for ( var i = 0, j = this.data.length; i < j; i++ )\n    {\n        var row = this.data[i];\n        var traj = row.get( CricketField.TRAJECTORY );\n\n        if ( traj !== undefined && traj.trackApproved )\n        {\n            validData.push( row );\n        }\n    }\n    this.data = validData;\n        \n    // Save the context, as we need it in the timer callback\n    this.ctx = ctx.canvas;\n    \n    // Reset render/offset array\n    this.renderData = [];\n    this.activeBall = 0;\n    this.offsets = [0];\n\n    this.showDescription();\n    \n    // Iterate over balls to find start/end/offset times\n    var anim = { start:Number.MAX_VALUE, end:Number.MIN_VALUE };\n    \n    PULSE.Tracer.info( 'Rendering ' + this.data.length + ' trajectories' );\n    \n    var total = 0;\n    for ( var i = 0, j = this.data.length; i < j; i++ )\n    {\n        // Obtain trajectory\n        var row = this.data[i];\n        var traj = row.get( CricketField.TRAJECTORY );\n\n        PULSE.Tracer.info( 'Traj ' + i + ' period ' + Utils.toString( traj.period, true ) );\n        \n        if ( 'serial' === this.config.ordering )\n        {\n            // Update total\n            var length = traj.period.end - traj.period.start;\n            total += length;\n            \n            // First traj\n            if ( i === 0 )\n            {\n                anim.start = 0;\n            }\n            \n            // Last traj (can also be the first!)\n            if ( i === j-1 )\n            {\n                anim.end = total + this.config.timeMargin.end;\n            }\n            \n            this.offsets[ i+1 ] = total;\n        }\n        else\n        {\n            // Parallel processing\n            var start = traj.period.start - this.config.timeMargin.start;\n            var end = traj.period.end + this.config.timeMargin.end;\n            \n            if ( start < anim.start )\n            {\n                anim.start = start;\n            }\n            if ( end > anim.end )\n            {\n                anim.end = end;\n            }\n        }\n    }\n    \n    PULSE.Tracer.info( 'Offsets: ' + Utils.toString( this.offsets, true ) );\n    \n    // Set up timing parameters\n    this.animationPeriod = anim;\n    this.time = this.animationPeriod.start;\n    \n    PULSE.Tracer.info( 'Animation period is ' + Utils.toString( anim, true ) ); \n    \n    // Start timer, stopping any previous one\n    if ( this.timerId !== null )\n    {\n        clearInterval( this.timerId );\n    }\n    \n    var that = this;\n    this.timerId = setInterval( function() { that.increment(); }, this.config.refresh );\n}"},"unrender":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"TrajectoryRenderer.prototype.unrender = function ()\n{\n    this.deferredRenderCall = undefined;\n    if ( this.timerId !== null )\n    {\n        clearInterval( this.timerId );\n        this.timerId = null;\n    }\n}"},"resetRendering":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"TrajectoryRenderer.prototype.resetRendering = function ()\n{\n    this.time = this.animationPeriod.start;\n    this.renderData = [];\n    this.activeBall = 0;\n    this.showDescription();\n\n    if ( this.deferredRenderCall )\n    {\n        // We have a deferred render call outstanding, so make that call now\n        PULSE.Tracer.info( 'Making deferred rendering call' );\n        this.render( this.deferredRenderCall.db, this.deferredRenderCall.data, this.deferredRenderCall.ctx, true );\n        \n        // Reset the render call data\n        this.deferredRenderCall = null;\n    }\n}"},"increment":{"Documentation":{"description":"Increments the point in time the animation is currently representing.","tags":[]},"Source":"TrajectoryRenderer.prototype.increment = function ()\n{\n    this.time += ( this.config.interval * this.speed );\n    \n    if ( this.time > this.animationPeriod.end )\n    {\n        this.resetRendering();\n    }\n    \n    // Move onto next active ball if we need to\n    if ( this.time > this.offsets[ this.activeBall + 1 ] )\n    {\n        if ( this.renderEnd )\n        {\n            // Ensure we have rendered the last point for the current ball\n            var thisTraj = this.data[this.activeBall].get( CricketField.TRAJECTORY );\n            var thisRd = this.renderData[this.activeBall];\n\n            TrajectoryRenderer.addRenderData( this.config, thisRd, thisTraj, thisTraj.period.end );\n        }\n        \n        this.activeBall++;\n        this.showDescription();\n    }\n    \n    // Add render data for the active ball\n    for ( var i = 0, j = this.data.length; i < j; i++ )\n    {\n        if ( 'parallel' === this.config.ordering || i === this.activeBall )\n        {\n            // Obtain trajectory\n            var row = this.data[i];\n            var traj = row.get( CricketField.TRAJECTORY );\n            \n            // Create or obtain render data for this traj\n            var rd = this.renderData[i];\n            if ( rd === undefined )\n            {\n                rd = [];\n                rd.shadow = [];\n                rd.trail = [];\n                this.renderData[i] = rd;\n            }\n    \n            var offset = this.offsets[i] === undefined ? 0 : this.offsets[i];\n            var t1 = this.time - offset + traj.period.start;\n            TrajectoryRenderer.addRenderData( this.config, rd, traj, t1 );\n            \n            // Check to see if the next timing point is after the bounce time; if it is,\n            // add the bounce time render point now\n            if ( this.renderBounce )\n            {\n                var t2 = t1 + ( this.config.interval * this.config.speed );\n                if ( t1 < traj.bt && t2 > traj.bt )\n                {\n                    TrajectoryRenderer.addRenderData( this.config, rd, traj, traj.bt );\n                }\n            }\n        }\n    }\n    \n    this.drawTo( this.ctx, this.renderData );\n}"},"drawTo":{"Documentation":{"description":"Renders the data passed in, consisting of an array of shadow, trail and ball data","tags":[]},"Source":"TrajectoryRenderer.prototype.drawTo = function ( ctx, renderData )\n{\n    var that = this;\n    \n    ctx.save();\n    ctx.clearRect( 0, 0, this.config.width, this.config.height );\n    \n    // Render all shadows\n    ctx.strokeStyle = this.config.shadowStyle;\n    for ( var i = 0, j = renderData.length; i < j; i++ )\n    {\n        var shadowData = renderData[i].shadow;\n        ctx.beginPath();\n        ctx.lineWidth = 6;\n        if ( shadowData.length > 0 )\n        {\n            ctx.moveTo( shadowData[0].x, shadowData[0].y );\n        }\n        for ( var m = 1, n = shadowData.length; m < n; m++ )\n        {\n            ctx.lineTo( shadowData[m].x,   shadowData[m].y );\n        }\n        ctx.stroke();\n    }\n    \n    // Render all trails\n    for ( var i = 0, j = renderData.length; i < j; i++ )\n    {\n        // Set the color for the trail\n        var trailColor = this.getTrailColor( i, renderData.length );\n        ctx.strokeStyle = trailColor;\n        \n        var trailData = renderData[i].trail;\n        ctx.beginPath();\n        ctx.lineWidth = 6;\n        if ( trailData.length > 0 )\n        {\n            ctx.moveTo( trailData[0].x, trailData[0].y );\n        }\n        for ( var m = 1, n = trailData.length; m < n; m++ )\n        {\n            ctx.lineTo( trailData[m].x,   trailData[m].y );\n        }\n        \n        ctx.stroke();\n    }\n    \n    // Define render callback function\n    var callback = function () { that.drawTo( ctx, renderData ); };\n    \n    // Render all balls\n    for ( var i = 0, j = renderData.length; i < j; i++ )\n    {\n        var ball = renderData[i].ball;\n        PULSE.BallRenderer.render( ctx, ball.x, ball.y, 'red', ball.size * 2, callback );\n    }\n\n    ctx.restore();\n}","callback":{"Documentation":{"description":"Renders the data passed in, consisting of an array of shadow, trail and ball data","tags":[]},"Source":"var callback = function () { that.drawTo( ctx, renderData ); }"}},"getTrailColor":{"Documentation":{"description":"","tags":[{"title":"param","description":"the 0-based index in the list of tracks","type":null,"name":"i"},{"title":"param","description":"the number of tracks in the list","type":null,"name":"max"}]},"Source":"TrajectoryRenderer.prototype.getTrailColor = function ( i, size )\n{\n    var pretty = true;\n    var color = this.config.trailColors[i % this.config.trailColors.length];\n    \n    if ( !pretty && i < size - 1 )\n    {\n        color = 'rgba(0,0,0,0.3)';\n    }\n\n    return color;\n}"}},"addRenderData":{"Documentation":{"description":"Utility method to add render data for a given trajectory at a given point in time.","tags":[{"title":"param","description":"the render data container","type":null,"name":"rd"},{"title":"param","description":"the trajectory","type":null,"name":"traj"},{"title":"param","description":"the traj-based time","type":null,"name":"time"}]},"Source":"TrajectoryRenderer.addRenderData = function ( config, rd, traj, time )\n{\n    // Obtain ball-on-screen information\n    var bos = TrajectoryRenderer.getBallOnScreen( config, traj, time );\n\n    // Add the data to the render data container\n    rd.shadow.push( { x:bos.shadow.x, y:bos.shadow.y, size:bos.size } );\n    rd.trail.push(  { x:bos.ball.x,   y:bos.ball.y,   size:bos.size } );\n    rd.ball =       { x:bos.ball.x,   y:bos.ball.y,   size:bos.size };\n}"},"getBallOnScreen":{"Documentation":{"description":"Gets screen-based ball information for a given time. Returns an object with properties:\n\nshadow   { x, y } - on-screen location of shadow\nball     { x, y } - on-screen location of ball\nsize              - on-screen ball radius","tags":[]},"Source":"TrajectoryRenderer.getBallOnScreen = function ( config, traj, time )\n{\n    // Get ball position in real-world coordinates\n    var xyz;\n    \n    if ( time > traj.period.end )\n    {\n        xyz = traj.getPositionAtTime( traj.period.end );\n    }\n    else if ( time < traj.period.start )\n    {\n        xyz = traj.getPositionAtTime( traj.period.start );\n    }\n    else\n    {\n        xyz = traj.getPositionAtTime( time );\n    }\n    \n    // Approximate the ball size\n    var size = config.ballSize.max - ( xyz.x * ( ( config.ballSize.max - \n                                        config.ballSize.min ) /\n                                        config.releaseX ) );\n\n    // Convert to VR coordinates\n    xyz.x -= 10.06;\n\n    // Project shadow\n    var shadowScreen = config.projection.project( { x:xyz.x, y:xyz.y, z:0 } );\n    \n    // Project ball\n    var ballScreen = config.projection.project( xyz );\n    \n    // Return object\n    return { shadow:shadowScreen, ball:ballScreen, size:size }; \n}"}},"BeehiveRenderer":{"Documentation":{"description":"*****************","tags":[]},"Source":"function BeehiveRenderer ( config ) \n{\n\tthis.config = config;\n}","prototype":{"render":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"db"},{"title":"param","description":null,"type":null,"name":"data"},{"title":"param","description":null,"type":null,"name":"ctx"}]},"Source":"BeehiveRenderer.prototype.render = function ( db, data, ctx )\n{\n\tvar that = this;\n\tctx.canvas.clearRect( 0, 0, this.config.width, this.config.height );\n\t\n\t// Need to clone the array, so we can sort on type of ball\n\tvar dataArray = Utils.cloneArray( data );\n\t\n\t// Sort the array\n\tdataArray.sort( function ( a, b ) \n\t{\n\t\tvar aw = a.get( CricketField.IS_WICKET );\n\t\tvar bw = b.get( CricketField.IS_WICKET );\n\t\t\n\t\tif ( aw && !bw )\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse if ( !aw && bw )\n\t\t{\n\t\t\treturn -1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar ar = a.get( CricketField.CREDIT );\n\t\t\tvar br = b.get( CricketField.CREDIT );\n\t\t\treturn ar - br;\n\t\t}\n\t\treturn 0;\n\t} );\n\n\t// Determine what variant of graph this is: left only, right only or mix\n\tvar hasRight = false;\n\tvar hasLeft = false;\n\tfor ( var i = 0, j = dataArray.length; i < j; i++ )\n\t{\n\t\tvar row = dataArray[i];\n\t\tvar handedness = row.get( CricketField.HANDEDNESS );\n\t\t\n\t\tif ( CricketHandedness.RIGHT === handedness )\n\t\t{\n\t\t\thasRight = true;\n\t\t}\n\t\telse if ( CricketHandedness.LEFT === handedness )\n\t\t{\n\t\t\thasLeft = true;\n\t\t}\n\t\t\n\t\tif ( hasLeft && hasRight )\n\t\t{\n\t\t\t// Early exit, as we now know this is a mix graph\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\t// Set background based upon hasLeft/hasRight\n\tif ( hasLeft && hasRight )\n\t{\n\t\tthis.controller.setBackground( this.config.variants.mix.background );\n\t}\n\telse if ( hasLeft )\n\t{\n\t\tthis.controller.setBackground( this.config.variants.lh.background );\n\t}\n\telse if ( hasRight )\n\t{\n\t\tthis.controller.setBackground( this.config.variants.rh.background );\n\t}\n\t\n\t// Render all the shadows first\n    ctx.canvas.save();\n    ctx.canvas.globalCompositeOperation = 'xor';\n    ctx.canvas.scale( 1, 0.3 );\n\tctx.canvas.fillStyle = 'rgba(0,0,0,0.3)';\n\tfor ( var i = 0, j = dataArray.length; i < j; i++ )\n\t{\n\t\tvar row = dataArray[i];\n\t\tvar stumps = row.get( CricketField.STUMPS );\n\t\t\n\t\tif ( stumps !== undefined )\n\t\t{\n\t\t\tvar xyz = { x:stumps.x, y:stumps.y, z:0 };\n\t\t\txyz = db.normalise( xyz );\n\t\t\t\n\t\t\tif ( xyz.x > -999 && xyz.y > -999 )\n\t\t\t{\n\t\t\t\t// Flip data for lefties\n\t\t\t\tif ( ( CricketHandedness.LEFT === row.get( CricketField.HANDEDNESS ) ) && hasRight )\n\t\t\t\t{\n\t\t\t\t\txyz.y = -xyz.y;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar screenPos = this.config.projection.project( xyz );\n\t\t\t\tctx.canvas.beginPath();\n\t\t\t\tUtils.circle( ctx.canvas, screenPos.x, screenPos.y / 0.3, 6 );\n\t\t\t\tctx.canvas.fill();\n\t\t\t}\n\t\t}\n\t}\n\tctx.canvas.restore();\n\t\n\t// Define render callback function\n\tvar callback = function () { that.render( db, data, ctx ); };\n\t\n\t// Render all the balls\n\tfor ( var i = 0, j = dataArray.length; i < j; i++ )\n\t{\n\t\tvar row = dataArray[i];\n\t\tvar xyz = row.get( CricketField.STUMPS );\n\t\t\n\t\tif ( xyz !== undefined )\n\t\t{\n\t\t\txyz = db.normalise( xyz );\n\t\t\t\n\t\t\tif ( xyz.x > -999 && xyz.y > -999 && xyz.z > -999 )\n\t\t\t{\n\t\t\t\t// Flip data for lefties\n\t\t\t\tif ( ( CricketHandedness.LEFT === row.get( CricketField.HANDEDNESS ) ) && hasRight )\n\t\t\t\t{\n\t\t\t\t\txyz.y = -xyz.y;\n\t\t\t\t}\n\n\t\t\t\tvar runs = row.get( CricketField.CREDIT );\n\t\t\t\tvar screenPos = this.config.projection.project( xyz );\n\t\n\t\t\t\tvar colorKey;\n\t\t\t\tif ( row.get( CricketField.IS_WICKET ) )\n\t\t\t\t{\n\t\t\t\t\tcolorKey = 'w';\n\t\t\t\t}\n\t\t\t\telse if ( runs == 0 )\n\t\t\t\t{\n\t\t\t\t\tcolorKey = 'd';\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar ww = row.get( CricketField.WW );\n\t\t\t\t\tif ( ww !== undefined )\n\t\t\t\t\t{\n\t\t\t\t\t\tvar ly = ww.y;\n\t\t\t\t\t\tif ( ly > -999 )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar leg = ly > 0;\n\t\t\t\t\t\t\tif ( CricketHandedness.LEFT === row.get( CricketField.HANDEDNESS ) )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tleg = !leg;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif ( runs >= 4 )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcolorKey = leg ? 'lb' : 'ob';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse \n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcolorKey = leg ? 'l' : 'o';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tPULSE.BallRenderer.render( ctx.canvas, screenPos.x, screenPos.y, \n\t\t\t\t\t\tthis.config.colors[ colorKey ], this.config.ballSize, callback );\n\t\t\t}\n\t\t}\n\t}\n}","callback":{"Documentation":{"description":"*****************","tags":[]},"Source":"var callback = function () { that.render( db, data, ctx ); }"}}}},"BowlSpeedsRenderer":{"Documentation":{"description":"***********","tags":[]},"Source":"function BowlSpeedsRenderer ( config ) \n{\n\tthis.config = config;\n\tthis.selected = -1;\n\tthis.stickies = [];\n}","prototype":{"render":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"db"},{"title":"param","description":null,"type":null,"name":"data"},{"title":"param","description":null,"type":null,"name":"ctx"}]},"Source":"BowlSpeedsRenderer.prototype.render = function ( db, data, ctx )\n{\n\tthis.db = db;\n\tthis.data = data;\n\tthis.ctx = ctx;\n\tthis.selected = -1;\n\tthis.stickies = [];\n\t\n\t// Prepare the data\n\t// Place balls into bowler buckets\n\tthis.bowlerData = {};\n\tthis.wicketData = {};\n\tthis.maxPoints = 20;\n\t\n\tfor ( var i = 0, j = this.data.length; i < j; i++ )\n\t{\n\t\tvar row = this.data[i];\n\t\tvar bowler = this.db.lookupPlayer( row.get( CricketField.BOWLER ) );\n\t\tvar speed = row.get( CricketField.BOWL_SPEED );\n\t\t\n        \n\t\tif ( !Utils.isNullish( bowler ) && speed >= 10 )\n\t\t{\n\t\t\t// Convert speed to units currently in use\n\t        if ( PULSE.SpeedModeController.mode === PULSE.SpeedModeController.MODE_KMH )\n\t        {\n\t        \tspeed = PULSE.SpeedModeController.mpsToKmh( speed );\n\t        }\n\t        \n\t\t\t// Handle speed data for this bowler\n\t\t\tvar bd = this.bowlerData[ bowler ];\n\t\t\tif ( bd === undefined )\n\t\t\t{\n\t\t\t\tbd = [];\n\t\t\t\tthis.bowlerData[ bowler ] = bd;\n\t\t\t}\n\t\t\tbd.push( speed );\n\t\t\t\n\t\t\t// Ensure we keep track of the lengthiest series\n\t\t\tif ( bd.length > this.maxPoints )\n\t\t\t{\n\t\t\t\tthis.maxPoints = bd.length;\n\t\t\t}\n\t\t\t\n\t\t\t// Handle a wicket fall\n\t\t\tif ( row.get( CricketField.IS_WICKET ) )\n\t\t\t{\n\t\t\t\tvar wf = this.wicketData[ bowler ];\n\t\t\t\tif ( wf === undefined )\n\t\t\t\t{\n\t\t\t\t\twf = [];\n\t\t\t\t\tthis.wicketData[ bowler ] = wf;\n\t\t\t\t}\n\t\t\t\twf.push( { x:bd.length, y:speed } );\n\t\t\t}\n\t\t}\n\t}\n\n\t// First get the maximum bowler name width, so we can adjust the key/graph width\n\tthis.maxWidth = 90;\n\tfor ( var bowler in this.bowlerData )\n\t{\n\t\tvar size = Utils.stringSize( this.ctx.canvas, bowler );\n\t\tif ( size.width > this.maxWidth )\n\t\t{\n\t\t\tthis.maxWidth = size.width;\n\t\t}\n\t}\n\t\n\tthis.draw();\n}"},"draw":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"BowlSpeedsRenderer.prototype.draw = function () \n{\n\tthis.ctx.font = this.config.font;\n\tthis.ctx.canvas.clearRect( 0, 0, this.config.width, this.config.height );\n\t\n\t// Draw key shading box\n\tvar keyMarginR = this.config.keyMarginR ? this.config.keyMarginR : this.config.keyMargin;\n\t\n\tvar boxWidth = this.maxWidth + this.config.keyMargin + keyMarginR;\n\tthis.ctx.canvas.beginPath();\n\tthis.ctx.canvas.fillStyle = this.config.keyFill;\n\tthis.ctx.canvas.rect( this.config.width - boxWidth, 0, boxWidth, this.config.height );\n\tthis.ctx.canvas.fill();\n\t\n\t// And size the x-axis\n\tthis.config.xAxis.end = this.config.width - boxWidth - ( 2 * this.config.keyMargin );\n\t\n\t// Dynamically set the xAxis range\n\tthis.config.xAxis.max = this.maxPoints;\n\t\n\t// Draw the axes\n\tthis.ctx.canvas.strokeStyle = 'rgba( 255, 255, 255, 1 )';\n\tthis.config.xAxis.drawTo( this.ctx.canvas, true );\n\tthis.config.yAxis.drawTo( this.ctx.canvas, false );\n\t\n\t// Now render each bowler's stats\n\tvar y = 20;\n\tvar i = 0;\n\tvar selectedBowler;\n\tfor ( var bowler in this.bowlerData )\n\t{\n\t\tif ( i == this.selected )\n\t\t{\n\t\t\tselectedBowler = bowler;\n\t\t}\n\t\t\n\t\tvar speeds = this.bowlerData[ bowler ];\n\t\tvar falls = this.wicketData[ bowler ];\n\t\tvar stats = Utils.getStats( speeds );\n\t\t\n\t\tthis.ctx.canvas.fillStyle = this.getColor( this.config.colors[i], i, this.selected, this.stickies );\n\t\tUtils.anchoredFillText( this.ctx.canvas, bowler, this.config.width - keyMarginR, y, 'e' );\n\t\t\n\t\ty += 15;\n\t\tthis.ctx.canvas.fillStyle = this.getColor( 'rgba( 255, 255, 255, 1)', i, this.selected, this.stickies,\n\t\t\t\t\t\t\t\t\t\t\t'rgba( 180, 180, 180, 1)' );\n\t\tUtils.anchoredFillText( this.ctx.canvas, stats.mean.toFixed( 1 ) + ' / ' + \n\t\t\t\t\t\t      stats.maximum.toFixed( 1 ), this.config.width - keyMarginR, y, 'e' );\n\t\ty += 27;\n\n\t\t// If this is in the stickies array, draw the bounding box\n\t\tif ( this.selected !== -1 && Utils.isInArray( this.stickies, i ) )\n\t\t{\n\t\t\tthis.ctx.canvas.beginPath();\n\t\t\tthis.ctx.canvas.strokeStyle = 'rgba( 255, 255, 255, 0.3 )';\n\t\t\tthis.ctx.canvas.lineWidth = 1;\n\t\t\tthis.ctx.canvas.rect( this.config.width - boxWidth + ( this.config.keyMargin / 2 ), y - 52,\n\t\t\t\t\tboxWidth - keyMarginR, 37 );\n\t\t\tthis.ctx.canvas.stroke();\n\t\t}\n\t\t\n\t\t// Render the line\n\t\tthis.renderSeries( this.config.boxWhisker, this.ctx.canvas, bowler, speeds, falls, this.config.colors[i], i );\n\n\t\t// Maximum of 8 bowlers\n\t\tif ( ++i > 7 )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tthis.bowlerCount = i;\n\t\n\t// Finally render the selected series, if there is a selection\n\tif ( this.selected !== -1 )\n\t{\n\t\tthis.renderSeries( this.config.boxWhisker, this.ctx.canvas, selectedBowler, \n\t\t\t\t\t\t   this.bowlerData[ selectedBowler ], this.wicketData[ selectedBowler ], \n\t\t\t\t\t\t   this.config.colors[ this.selected ], this.selected );\n\t}\n}"},"onMouse":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"event"}]},"Source":"BowlSpeedsRenderer.prototype.onMouse = function ( event )\n{\n\t// Get XY and then infer bowler selection index\n\tvar xy = Utils.getXY( event );\n\tvar selection = -1;\n\t\n\tif ( xy !== undefined && xy.x > 490 && \n\t\t\t( !this.config.keyMarginR || xy.x < this.config.width - this.config.keyMarginR ) ) \n\t{\n\t\tselection = Math.round( ( xy.y - 27 ) / 42 );\n\t\tif ( selection >= this.bowlerCount )\n\t\t{\n\t\t\tselection = -1;\n\t\t}\n\t}\n\t\n\tif ( 'mousemove' === event.type )\n\t{\n\t\tthis.selected = selection;\n\t}\n\telse if ( 'mousedown' === event.type )\n\t{\n\t\tthis.stickies = Utils.toggleExistence( this.stickies, selection );\n\t}\n\t\t\n\tthis.draw();\n}"},"getColor":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"color"},{"title":"param","description":null,"type":null,"name":"index"},{"title":"param","description":null,"type":null,"name":"selection"},{"title":"param","description":null,"type":null,"name":"others"},{"title":"param","description":null,"type":null,"name":"alt"}]},"Source":"BowlSpeedsRenderer.prototype.getColor = function ( color, index, selection, others, alt )\n{\n\tif ( selection === -1 || selection === index || Utils.isInArray( others, index ) )\n\t{\n\t\treturn color;\n\t}\n\telse if ( alt !== undefined )\n\t{\n\t\treturn alt;\n\t}\n\telse\n\t{\n\t\treturn 'gray';\n\t}\n}"},"renderSeries":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"boxWhisker"},{"title":"param","description":null,"type":null,"name":"ctx"},{"title":"param","description":null,"type":null,"name":"bowler"},{"title":"param","description":null,"type":null,"name":"speeds"},{"title":"param","description":null,"type":null,"name":"falls"},{"title":"param","description":null,"type":null,"name":"color"},{"title":"param","description":null,"type":null,"name":"index"}]},"Source":"BowlSpeedsRenderer.prototype.renderSeries = function ( boxWhisker, ctx, bowler, speeds, falls, color, index )\n{\n\tif ( boxWhisker )\n\t{\n\t\tthis.renderSeriesBW( ctx, bowler, speeds, falls, color, index );\n\t}\n\telse\n\t{\n\t\tthis.renderSeriesLine( ctx, bowler, speeds, falls, color, index );\n\t}\n}"},"renderSeriesLine":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"ctx"},{"title":"param","description":null,"type":null,"name":"bowler"},{"title":"param","description":null,"type":null,"name":"speeds"},{"title":"param","description":null,"type":null,"name":"falls"},{"title":"param","description":null,"type":null,"name":"color"},{"title":"param","description":null,"type":null,"name":"index"}]},"Source":"BowlSpeedsRenderer.prototype.renderSeriesLine = function ( ctx, bowler, speeds, falls, color, index )\n{\n\tctx.save();\n\tctx.beginPath();\n\n\tvar markerOutline = 'black';\n\tvar markerSize = 3;\n\n\tctx.strokeStyle = this.getColor( color, index, this.selected, this.stickies );\n\t\n\tif ( this.selected === -1 )\n\t{\n\t\tctx.lineWidth = 2;\n\t}\n\telse if ( this.selected === index || Utils.isInArray( this.stickies, index ) )\n\t{\n\t\tctx.lineWidth = 3;\n\t\tmarkerSize = 4;\n\t}\n\telse\n\t{\n\t\tctx.lineWidth = 1;\n\t\tmarkerOutline = '#444';\n\t}\n\t\n\tfor ( var i = 0, j = speeds.length; i < j; i++ )\n\t{\n\t\tvar x = this.config.xAxis.project( i + 1 );\n\t\tvar y = this.config.yAxis.project( speeds[i] );\n\t\t\n\t\tif ( i === 0 )\n\t\t{\n\t\t\tctx.moveTo( x, y );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tctx.lineTo( x, y );\n\t\t}\n\t}\n\tctx.stroke();\n\t\n\tif ( falls !== undefined )\n\t{\n\t\tctx.fillStyle = ctx.strokeStyle;\n\t\tctx.strokeStyle = markerOutline;\n\t\tctx.lineWidth = 1;\n\t\t\n\t\tfor ( var i = 0, j = falls.length; i < j; i++ )\n\t\t{\n\t\t\tctx.beginPath();\n\t\t\tvar point = falls[i];\n\t\t\tvar x = this.config.xAxis.project( point.x );\n\t\t\tvar y = this.config.yAxis.project( point.y );\n\t\t\t\n\t\t\tUtils.circle( ctx, x, y, markerSize );\n\t\t\tctx.fill();\n\t\t\tctx.stroke();\n\t\t}\n\t}\n\t\n\tctx.restore();\n}"},"renderSeriesBW":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"ctx"},{"title":"param","description":null,"type":null,"name":"bowler"},{"title":"param","description":null,"type":null,"name":"speeds"},{"title":"param","description":null,"type":null,"name":"falls"},{"title":"param","description":null,"type":null,"name":"color"},{"title":"param","description":null,"type":null,"name":"index"}]},"Source":"BowlSpeedsRenderer.prototype.renderSeriesBW = function ( ctx, bowler, speeds, falls, color, index )\n{\n\tvar fns = Utils.getFiveNumberSummary( speeds );\n\tvar hw = 10;\n\t\n\tvar values = [ fns.min, fns.lq, fns.median, fns.uq, fns.max ];\n\tvar projected = [];\n\tfor ( var i = 0, ilimit = values.length; i < ilimit; i++ )\n\t{\n\t\tprojected.push( this.config.yAxis.project( values[i] ) );\n\t}\n\t\n\tvar x = this.config.xAxis.project( ( index + 1 ) * 10 );\n\n\tctx.beginPath();\n\tctx.moveTo( x - hw, projected[0] );\n\tctx.lineTo( x + hw, projected[0] );\n\tctx.moveTo( x - hw, projected[4] );\n\tctx.lineTo( x + hw, projected[4] );\n\tctx.moveTo( x, projected[0] );\n\tctx.lineTo( x, projected[4] );\n\tctx.stroke();\n\t\n\tctx.rect( x - hw, projected[3], hw * 2, projected[1] - projected[3] );\n\tctx.fillStyle = 'blue';\n\tctx.fill();\n\n\tctx.moveTo( x - hw, projected[2] );\n\tctx.lineTo( x + hw, projected[2] );\n\tctx.stroke();\n}"}}},"PartnershipsRenderer":{"Documentation":{"description":"************","tags":[]},"Source":"function PartnershipsRenderer ( config ) \n{\n\tthis.config = config;\n}","prototype":{"render":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"db"},{"title":"param","description":null,"type":null,"name":"data"},{"title":"param","description":null,"type":null,"name":"ctx"}]},"Source":"PartnershipsRenderer.prototype.render = function ( db, data, ctx )\n{\n\tctx.canvas.clearRect( 0, 0, this.config.width, this.config.height );\n\n\tvar stats = { b1name:null, b2name:null, b1runs:0, b2runs:0, pruns:0 };\n\tvar first = true;\n\tvar y = 0;\n\t\n\tfor ( var i = 0, j = data.length; i < j; i++ )\n\t{\n\t\tvar row = data[i];\n\t\t\n\t\tvar facing = db.lookupPlayer( row.get( CricketField.BATSMAN ) );\n\t\tvar nonfacing = db.lookupPlayer( row.get( CricketField.NF_BATSMAN ) );\n\t\t\n\t\tif ( Utils.isNullish( facing ) || Utils.isNullish( nonfacing ) )\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\t\n        if ( ( facing !== stats.b1name && facing !== stats.b2name ) ||\n        \t ( nonfacing !== stats.b1name && nonfacing !== stats.b2name ) )\n        {\n         \tif ( first )\n         \t{\n         \t\tfirst = false;\n         \t}\n         \telse\n         \t{\n         \t\tthis.renderPartnership( ctx.canvas, stats, y++ );\n         \t}\n         \t\n        \tif ( nonfacing === stats.b1name )\n        \t{\n        \t    stats.b1name = nonfacing;\n        \t    stats.b2name = facing;\n        \t}\n        \telse\n        \t{\n        \t\tstats.b1name = facing;\n        \t\tstats.b2name = nonfacing;\n        \t}\n        \t\n        \tstats.b1runs = 0;\n        \tstats.b2runs = 0;\n        \tstats.pruns = 0;\n        }\n        \n        var credit = +row.get( CricketField.CREDIT );\n        if ( stats.b1name === facing )\n        {\n            stats.b1runs += credit;\n        }\n        else\n        {\n        \tstats.b2runs += credit;\n        }\n        \n        stats.pruns += ( +row.get( CricketField.RUNS ) );\n    }\n\n\tthis.renderPartnership( ctx.canvas, stats, y++ );\n}"},"renderPartnership":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"ctx"},{"title":"param","description":null,"type":null,"name":"stats"},{"title":"param","description":null,"type":null,"name":"pship"}]},"Source":"PartnershipsRenderer.prototype.renderPartnership = function ( ctx, stats, pship )\n{\n\tif ( pship < 10 )\n\t{\n\t\tctx.save();\n\t\t\n\t\tvar y = this.config.ystart + ( pship * this.config.yspacing );\n\t\tvar x = this.config.width / 2;\n\t\t\n\t\t// Draw partnership\n\t\tctx.font = this.config.pshipText.font;\n\t\tctx.fillStyle = this.config.pshipText.style;\n\t\tUtils.anchoredFillText( ctx, stats.pruns, x, y, 's' );\n\t\n\t\t// Draw bars\n\t\tvar gradient = ctx.createLinearGradient( x, y-(this.config.bars.width/2), \n\t\t\t\t\t\t\t\t\t\t\t\t x, y+(this.config.bars.width/2) );\n\t\tgradient.addColorStop( 0, this.config.bars.colorStops[0] );\n\t\tgradient.addColorStop( 1, this.config.bars.colorStops[1] );\n\t\tctx.fillStyle = gradient;\n\n\t\tvar yshift = 0;\n\t\tif ( this.config.bars.yshift )\n\t\t{\n\t\t\tyshift = this.config.bars.yshift;\n\t\t}\n\t\t\n\t\tvar bl;\n\t\tif ( stats.b1runs > 0 )\n\t\t{\n\t\t\tctx.beginPath();\n\t\t\tbl = this.barLength( stats.b1runs );\n\t\t\t\n\t\t\tctx.arc( x-this.config.tabs[1]-bl, y + yshift, this.config.bars.width / 2, \n\t\t\t\t\tMath.PI * 0.5, Math.PI * 1.5, false );\n\t\t\tctx.rect( x-this.config.tabs[1], y + yshift - (this.config.bars.width/2), -bl, this.config.bars.width );\n\t\t\tctx.fill();\n\t\t}\n\t\t\n\t\tif ( stats.b2runs > 0 )\n\t\t{\n\t\t\tctx.beginPath();\n\t\t\tbl = this.barLength( stats.b2runs );\n\t\t\tctx.rect( x+this.config.tabs[1], y + yshift - (this.config.bars.width/2), bl, this.config.bars.width );\n\t\t\tctx.arc( x+this.config.tabs[1]+bl, y + yshift, this.config.bars.width / 2,\n\t\t\t\t\tMath.PI * 1.5, Math.PI * 0.5, false );\n\t\t\tctx.fill();\n\t\t}\n\t\t\n\t\t// Draw text labels\n\t\tctx.font = this.config.otherText.font;\n\t\tctx.fillStyle = this.config.otherText.style;\n\t\tUtils.anchoredFillText( ctx, stats.b1runs, x-this.config.tabs[0], y, 'se' );\n\t\tUtils.anchoredFillText( ctx, stats.b1name, x-this.config.tabs[2], y, 'se' );\n\t\t\n\t\tUtils.anchoredFillText( ctx, stats.b2runs, x+this.config.tabs[0], y, 'sw' );\n\t\tUtils.anchoredFillText( ctx, stats.b2name, x+this.config.tabs[2], y, 'sw' );\n\t\t\n\t\tctx.restore();\n\t}\n}"},"barLength":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"runs"}]},"Source":"PartnershipsRenderer.prototype.barLength = function ( runs )\n{\n\treturn Math.min( runs + this.config.bars.minLength, this.config.bars.maxLength );\n}"}}},"RunsPerOverRenderer":{"Documentation":{"description":"*************","tags":[]},"Source":"function RunsPerOverRenderer ( config ) \n{\n\tthis.config = config;\n}","prototype":{"render":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"db"},{"title":"param","description":null,"type":null,"name":"data"},{"title":"param","description":null,"type":null,"name":"ctx"}]},"Source":"RunsPerOverRenderer.prototype.render = function ( db, data, ctx )\n{\n\tthis.db = db;\n\tthis.variant = obtainVariant( this.config, this.db );\n\tthis.data = this.prepareData( data );\n\tthis.ctx = ctx;\n\t\n\tthis.tooltipData = undefined;\n\tthis.draw();\n}"},"prepareData":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"data"}]},"Source":"RunsPerOverRenderer.prototype.prepareData = function ( data )\n{\n\tthis.tooltipDataCache = {};\n\n\tvar overStats = [];\n\t\n\tvar lastOver = 0;\n\tvar stats = { r:0, w:0, dismissed:[] };\n\tfor ( var i = 0, j = data.length; i < j; i++ )\n\t{\n\t\tvar row = data[i];\n\t\t\n\t\tvar over = +row.get( CricketField.OVER );\n\t\tif ( over !== lastOver )\n\t\t{\n\t\t\t// New over\n\t\t\t// If this isn't the first over, render the previous one\n\t\t\tif ( over !== 1 )\n\t\t\t{\n\t\t\t\toverStats.push( this.prepareRecord( lastOver, stats ) );\n\t\t\t}\n\n\t\t\tlastOver = over;\n\t\t\t\n\t\t\t// Reset stats\n\t\t\tstats.r = 0;\n\t\t\tstats.w = 0;\n\t\t\tstats.dismissed = [];\n\t\t}\n\t\t\n\t\tstats.r += ( +row.get( CricketField.RUNS ) );\n\t\tif ( row.get( CricketField.IS_WICKET ) )\n\t\t{\n\t\t\tstats.w++;\n\t\t\tstats.dismissed.push( row.get( CricketField.DISMISSED ) );\n\t\t}\n\t}\n\t\n\toverStats.push( this.prepareRecord( lastOver, stats ) );\n\treturn overStats;\n}"},"prepareRecord":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"over"},{"title":"param","description":null,"type":null,"name":"stats"}]},"Source":"RunsPerOverRenderer.prototype.prepareRecord = function ( over, stats )\n{\n\tvar x = this.variant.xAxis.project( over );\n\tvar y = this.variant.yAxis.project( stats.r );\n\t\n\t// Add to tooltip cache\n\tvar ix = Math.round( x );\n\tvar iy = Math.round( y );\n\tthis.tooltipDataCache[ ix ] = { x:ix, y:iy, dismissed:stats.dismissed };\n\t\n\treturn { x:x, y:y, w:stats.w };\n}"},"draw":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"RunsPerOverRenderer.prototype.draw = function ()\n{\n\t// Clear\n\tthis.ctx.canvas.save();\n\tthis.ctx.canvas.font = this.config.font;\n\tthis.ctx.canvas.clearRect( 0, 0, this.config.width, this.config.height );\n\t\n\t// Draw axes\n\tthis.ctx.canvas.strokeStyle = 'rgba( 255, 255, 255, 1 )';\n\tthis.variant.xAxis.drawTo( this.ctx.canvas, true );\n\tthis.variant.yAxis.drawTo( this.ctx.canvas, false );\n\t\n\t// Create fill gradient\n\tvar yMax = this.variant.yAxis.project( this.variant.yAxis.max );\n\tvar yMin = this.variant.yAxis.project( this.variant.yAxis.min );\n\tvar gradient = this.ctx.canvas.createLinearGradient( 0, yMin, 0, yMax ); \n\tgradient.addColorStop( 0, this.variant.bars.colorStops[1] );\n\tgradient.addColorStop( 1, this.variant.bars.colorStops[0] );\n\tthis.ctx.canvas.fillStyle = gradient;\n\t\n\t// Iterate over bars\n\tvar y0 = this.variant.yAxis.project( 0 ) - 1;\n\tfor ( var i = 0, ilimit = this.data.length; i < ilimit; i++ )\n\t{\n\t\tvar record = this.data[i];\n\n\t\tthis.ctx.canvas.beginPath();\n\t\tthis.ctx.canvas.rect( record.x - ( this.variant.bars.width / 2 ), y0, \n\t\t\t\t  this.variant.bars.width, record.y - y0 );\n\t\tthis.ctx.canvas.fill();\n\t\t\n\t\tthis.ctx.canvas.save();\n\t\tthis.ctx.canvas.lineWidth = 1;\n\t\tfor ( var j = 0, jlimit = record.w; j < jlimit; j++ )\n\t\t{\n\t\t\tthis.ctx.canvas.strokeStyle = this.config.fow.stroke;\n\t\t\tthis.ctx.canvas.fillStyle = this.config.fow.fill;\n\t\t\tthis.ctx.canvas.beginPath();\n\t\t\tUtils.circle( this.ctx.canvas, record.x, record.y - ( j * this.variant.bars.fowsize ), this.variant.bars.fowsize / 2 );\n\t\t\tthis.ctx.canvas.fill();\n\t\t\tthis.ctx.canvas.stroke();\n\t\t}\n\t\t\n\t\tthis.ctx.canvas.restore();\n\t}\n\t\n\t// Finally render the tooltip data, if we have some and it contains something interesting\n\tif ( this.tooltipData !== undefined && this.config.tooltip && this.tooltipData.dismissed.length > 0 )\n\t{\n\t\tvar cfg = this.config.tooltip;\n\t\tvar anchorv = 'n';\n\t\tvar anchorh = 'w';\n\t\t\n\t\tif ( this.tooltipData.x > this.config.width / 2 )\n\t\t{\n\t\t\tanchorh = 'e';\n\t\t}\n\t\tif ( this.tooltipData.y > this.config.height / 2 )\n\t\t{\n\t\t\tanchorv = 's';\n\t\t}\n\t\t\n\t\tcfg.position = { x:this.tooltipData.x, y:this.tooltipData.y, anchor:anchorv + anchorh };\n\t\t\n\t\tvar tf = new PULSE.TextField( cfg );\n\t\ttf.setLines( this.tooltipData.dismissed );\n\t\ttf.render( this.ctx.canvas );\n\t}\n\t\n\tthis.ctx.canvas.restore();\n}"},"onMouse":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"event"}]},"Source":"RunsPerOverRenderer.prototype.onMouse = function ( event )\n{\n\t// Get XY and then infer over bar\n\tvar xy = Utils.getXY( event );\n\tthis.tooltipData = this.findNearbyTooltip( xy );\n\tthis.draw();\n}"},"findNearbyTooltip":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"xy"}]},"Source":"RunsPerOverRenderer.prototype.findNearbyTooltip = function ( xy )\n{\n\tif ( xy )\n\t{\n\t\tfor ( var x = xy.x - ( this.variant.bars.width / 2 ); \n\t\t          x <= xy.x + ( this.variant.bars.width / 2 ); x++ )\n\t\t{\n\t\t\tif ( this.tooltipDataCache[ x ] )\n\t\t\t{\n\t\t\t\treturn this.tooltipDataCache[ x ];\n\t\t\t}\n\t\t}\n\t}\n}"}}},"RunRateRenderer":{"Documentation":{"description":"********","tags":[]},"Source":"function RunRateRenderer ( config ) \n{\n\tthis.config = config;\n}","prototype":{"render":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"db"},{"title":"param","description":null,"type":null,"name":"data"},{"title":"param","description":null,"type":null,"name":"ctx"}]},"Source":"RunRateRenderer.prototype.render = function ( db, data, ctx )\n{\n\tthis.db = db;\n\tthis.variant = obtainVariant( this.config, this.db );\n\tthis.data = this.prepareData( data );\n\tthis.ctx = ctx;\n\t\n\tthis.tooltipData = undefined;\n\tthis.draw();\n}"},"prepareData":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"data"}]},"Source":"RunRateRenderer.prototype.prepareData = function ( data )\n{\n\tthis.tooltipDataCache = {};\n\n\tvar inningsSeries = {};\n\n\tif ( data.length > 0 )\n\t{\n\t\t// Place data into innings buckets (for performance reasons, we should look at combining\n\t\t// this bucketisation with the actual data series creation below)\n\t\tvar inningsData = {};\n\t\tfor ( var i = 0, ilimit = data.length; i < ilimit; i++ )\n\t\t{\n\t\t\tvar row = data[i];\n\t\t\tvar innings = +row.get( CricketField.INNINGS );\n\t\t\t\n\t\t\t// Obtain or create bucket\n\t\t\tvar inningsDataItem = inningsData[ innings ];\n\t\t\tif ( inningsDataItem === undefined )\n\t\t\t{\n\t\t\t\tinningsDataItem = [];\n\t\t\t\tinningsData[ innings ] = inningsDataItem;\n\t\t\t}\n\t\t\t\n\t\t\t// Add item to bucket\n\t\t\tinningsDataItem.push( row );\n\t\t}\n\t\n\t\t// Keep track of maximum number of overs (for Test cricket)\n\t\tvar maxOvers = 0;\n\n\t\t// Get the participants\n\t\tvar participants = this.db.getParticipants();\n\t\t\n\t\t// Now iterate over all all balls in each innings bucket\n\t\tfor ( var innings = 1; innings <= 4; innings++ )\n\t\t{\n\t\t\t// Get the participant name\n\t\t\tvar pIndex = this.db.getBattingTeamIndex( innings );\n\t\t\tvar pName = participants[ pIndex ].abbreviation;\n\t\t\t\n\t\t\tinningsSeries[ innings ] = [];\n\t\t\t\n\t\t\tvar inningsRecords = inningsData[ innings ];\n\t\t\tif ( inningsRecords === undefined || inningsRecords.length === 0 )\n\t\t\t{\n\t\t\t\t// Break out\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tvar stats = { runs:0, wickets:0, over:0 };\n\t\t\tvar lastOver = 0;\n\t\t\t\n\t\t\tfor ( var i = 0, j = inningsRecords.length; i < j; i++ )\n\t\t\t{\n\t\t\t\tvar row = inningsRecords[ i ];\n\t\t\t\tvar over = +row.get( CricketField.OVER );\n\t\t\t\t\n\t\t\t\tif ( over !== lastOver )\n\t\t\t\t{\n\t\t\t\t\t// New over\n\t\t\t\t\t// If this isn't the first over, add the previous one\n\t\t\t\t\tif ( over !== 1 )\n\t\t\t\t\t{\n\t\t\t\t\t\tinningsSeries[ innings ].push( this.prepareRecord( stats, pName ) );\n\t\t\t\t\t}\n\t\n\t\t\t\t\tlastOver = over;\n\t\t\t\t\t\n\t\t\t\t\t// Reset stats\n\t\t\t\t\tstats.wickets = 0;\n\t\t\t\t\tstats.over = over;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tstats.runs += ( +row.get( CricketField.RUNS ) );\n\t\t\t\tif ( row.get( CricketField.IS_WICKET ) )\n\t\t\t\t{\n\t\t\t\t\tstats.wickets++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Update max overs\n\t\t\t\tif ( over > maxOvers )\n\t\t\t\t{\n\t\t\t\t\tmaxOvers = over;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// Add final stats\n\t\t\tinningsSeries[ innings ].push( this.prepareRecord( stats, pName ) );\n\t\t}\n\t\n\t\t// Scale the xAxis if need be\n\t\tthis.variant.xAxis.max = this.variant.xAxis.configuredMax; \n\t\tif ( maxOvers > this.variant.xAxis.max )\n\t\t{\n\t\t\tthis.variant.xAxis.max = maxOvers;\n\t\t}\n\t}\n\t\n\treturn inningsSeries;\n}"},"prepareRecord":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"stats"},{"title":"param","description":null,"type":null,"name":"participant"}]},"Source":"RunRateRenderer.prototype.prepareRecord = function ( stats, participant )\n{\n\tvar yvalue = this.getYValue( stats );\n\tvar x = this.variant.xAxis.project( stats.over );\n\tvar y = this.variant.yAxis.project( yvalue );\n\t\n\t// Add to tooltip cache\n\tvar ix = Math.round( x );\n\tvar iy = Math.round( y );\n\tvar xcache = this.tooltipDataCache[ ix ];\n\tif ( !xcache )\n\t{\n\t\txcache = { x:ix, xvalue:stats.over };\n\t\tthis.tooltipDataCache[ ix ] = xcache;\n\t}\n\txcache[ iy ] = { y:iy, yvalue:yvalue, participant:participant };\n\t\n\treturn { x:x, y:y, w:stats.wickets };\n}"},"draw":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"RunRateRenderer.prototype.draw = function ()\n{\n\tthis.ctx.canvas.save();\n\tthis.ctx.canvas.font = this.config.font;\n\tthis.ctx.canvas.clearRect( 0, 0, this.config.width, this.config.height );\n\n\t// Render the tooltip\n\tthis.renderTooltip( this.ctx.canvas, this.tooltipData );\n\t\n\t// Draw the axes\n\tthis.ctx.canvas.strokeStyle = 'rgba( 255, 255, 255, 1 )';\n\tthis.variant.xAxis.drawTo( this.ctx.canvas, true );\n\tthis.variant.yAxis.drawTo( this.ctx.canvas, false );\n\n\t// Now render each series\n\tvar flexikey = new Flexikey( this.config.flexikey );\n\tvar participants = this.db.getParticipants();\n\n\tvar gt = this.db.getMatchType();\n\tvar suffix = '';\n\t\n\tfor ( var i = 1; i <= 4; i++ )\n\t{\n\t\tvar thisInningsSeries = this.data[ i ];\n\t\t\n\t\tif ( thisInningsSeries === undefined || thisInningsSeries.length < 1 )\n\t\t{\n\t\t\t// Early exit\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tvar pIndex = this.db.getBattingTeamIndex( i );\n\t\tvar color;\n\t\tif ( i <= 2 )\n\t\t{\n\t\t\tcolor = participants[ pIndex ].primaryColor;\n\t\t\tsuffix = ' 1st inns'; \n\t\t}\n\t\telse\n\t\t{\n\t\t\tcolor = participants[ pIndex ].secondaryColor;\n\t\t\tsuffix = ' 2nd inns';\n\t\t}\n\t\t\n\t\tthis.renderSeries( this.ctx.canvas, thisInningsSeries, color );\n\t\t\n\t\tvar label = participants[ pIndex ].fullName;\n\t\tif ( CricketMatchType.TEST === gt )\n\t\t{\n\t\t\tlabel += suffix;\n\t\t}\n\t\t\n\t\tflexikey.addEntry( label, color );\n\t}\n\t\n\t// Finally render the Flexikey\n\tflexikey.render( this.ctx.canvas );\n}"},"renderSeries":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"ctx"},{"title":"param","description":null,"type":null,"name":"series"},{"title":"param","description":null,"type":null,"name":"color"}]},"Source":"RunRateRenderer.prototype.renderSeries = function ( ctx, series, color )\n{\n\tctx.save();\n\t\n\tctx.lineWidth = 3;\n\tctx.strokeStyle = color;\n\tctx.fillStyle = color;\n\n\t// Render the line\n\tctx.beginPath();\n\tfor ( var i = 0, j = series.length; i < j; i++ )\n\t{\n\t\tvar item = series[i];\n\t\tif ( i === 0 )\n\t\t{\n\t\t\tctx.moveTo( item.x, item.y );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tctx.lineTo( item.x, item.y );\n\t\t}\n\t}\n\tctx.stroke();\n\t\n\t// Render the wicket falls\n\tctx.lineWidth = 1;\n\tctx.strokeStyle = this.config.fow.stroke;\n\tfor ( var i = 0, j = series.length; i < j; i++ )\n\t{\n\t\tvar item = series[i];\n\t\tif ( item.w > 0 )\n\t\t{\n\t\t\tfor ( var k = 0, l = item.w; k < l; k++ )\n\t\t\t{\n\t\t\t\tctx.beginPath();\n\t\t\t\tUtils.circle( ctx, item.x, item.y - ( k * this.config.fow.size ), this.config.fow.size / 2 );\n\t\t\t\tctx.fill();\n\t\t\t\tctx.stroke();\n\t\t\t}\n\t\t}\n\t}\n\t\n\tctx.restore();\n}"},"onMouse":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"event"}]},"Source":"RunRateRenderer.prototype.onMouse = function ( event )\n{\n\t// Get XY and then infer over bar\n\tvar xy = Utils.getXY( event );\n\tthis.tooltipData = this.findNearbyTooltip( xy );\n\tthis.draw();\n}"},"findNearbyTooltip":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"xy"}]},"Source":"RunRateRenderer.prototype.findNearbyTooltip = function ( xy )\n{\n\tif ( xy )\n\t{\n\t\tif ( xy.x <= this.variant.xAxis.end && xy.x >= this.variant.xAxis.start &&\n\t\t     xy.y >= this.variant.yAxis.end && xy.y <= this.variant.yAxis.start )\n\t\t{\n\t\t\tvar search = xy.x;\n\t\t\t\n\t\t\twhile ( search >= this.variant.xAxis.start )\n\t\t\t{\n\t\t\t\tif ( this.tooltipDataCache[ search ] )\n\t\t\t\t{\n\t\t\t\t\treturn this.tooltipDataCache[ search ];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// If there was no data for this x value, try using one to the left\n\t\t\t\t\tsearch--;\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n}"},"getYValue":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"item"}]},"Source":"RunRateRenderer.prototype.getYValue = function ( item )\n{\n\treturn item.runs / item.over;\n}"},"renderTooltip":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"ctx"},{"title":"param","description":null,"type":null,"name":"ttd"}]},"Source":"RunRateRenderer.prototype.renderTooltip = function ( ctx, ttd )\n{\n\tif ( ttd )\n\t{\n\t\tctx.save();\n\t\tctx.strokeStyle = 'rgba( 255, 255, 255, 0.6 )';\n\n\t\tvar tf = undefined;\n\t\tif ( this.config.textField )\n\t\t{\n\t\t\ttf = new PULSE.TextField( this.config.textField );\n\t\t\ttf.addLine( '<c:#bbb>Over </c>' + ttd.xvalue );\n\t\t}\n\t\t\n\t\tvar line = '';\n\t\tfor ( var ttditem in ttd )\n\t\t{\n\t\t\tif ( ttditem !== 'x' && ttditem !== 'xvalue' )\n\t\t\t{\n\t\t\t\tvar t = ttd[ttditem];\n\t\t\t\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.moveTo( this.variant.xAxis.start, t.y );\n\t\t\t\tctx.lineTo( ttd.x, t.y );\n\t\t\t\tctx.lineTo( ttd.x, this.variant.yAxis.start )\n\t\t\t\tctx.stroke();\n\t\t\t\t\n\t\t\t\tline += '<c:#bbb>' + t.participant + ' </c>' + this.format( t.yvalue ) + ', ';\n\t\t\t}\n\t\t}\n\t\t\n\t\tif ( tf )\n\t\t{\n\t\t\tif ( line.length > 2 )\n\t\t\t{\n\t\t\t\tline = line.substr( 0, line.length - 2 );\n\t\t\t}\n\t\t\ttf.addLine( line );\n\t\t\ttf.render( ctx );\n\t\t}\n\t\t\n\t\tctx.restore();\n\t}\t\t\n}"},"format":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"value"}]},"Source":"RunRateRenderer.prototype.format = function ( value )\n{\n\treturn value.toFixed( 2 ) + ' <c:#bbb>rpo</c>';\n}"}}},"WormsRenderer":{"Documentation":{"description":"*****","tags":[]},"Source":"function WormsRenderer ( config ) \n{\n\tthis.config = config;\n}","prototype":{"format":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"value"}]},"Source":"WormsRenderer.prototype.format = function ( value )\n{\n\treturn value + ' <c:#bbb>runs</c>';\n}"},"getYValue":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"item"}]},"Source":"WormsRenderer.prototype.getYValue = function ( item )\n{\n\treturn item.runs;\n}"}}},"WinLikelihoodRenderer":{"Documentation":{"description":"**************","tags":[]},"Source":"function WinLikelihoodRenderer ( config ) \n{\n\tthis.config = config;\n}","prototype":{"render":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"db"},{"title":"param","description":null,"type":null,"name":"data"},{"title":"param","description":null,"type":null,"name":"ctx"}]},"Source":"WinLikelihoodRenderer.prototype.render = function ( db, data, ctx )\n{\n\tthis.db = db;\n\tthis.data = data;\n\tthis.ctx = ctx.canvas;\n\t\n\tthis.tooltipData = undefined;\n\tthis.dismissalData = undefined;\n\tthis.tooltipDataCache = {};\n\tthis.draw();\n}"},"draw":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"WinLikelihoodRenderer.prototype.draw = function ()\n{\n\tthis.ctx.save();\n\tthis.ctx.font = this.config.font;\n\tthis.ctx.clearRect( 0, 0, this.config.width, this.config.height );\n\n\tthis.renderTextFields = true;\n\t\n\tvar currentInnings = 0;\n\tvar currentOver = 0;\n\tvar dismissals = [];\n\tvar x = 1;\n\tvar battingIndex = 0;\n\tvar series = [ [], [], [] ];\n\t\n\tvar likelihoods;\n\tvar lastLikelihoods;\n\tfor ( var i = 0, j = this.data.length; i < j; i++ )\n\t{\n\t\tvar row = this.data[ i ];\n\n\t\tlikelihoods = row.get( CricketField.WIN_LIKELIHOODS );\n\t\tif ( likelihoods === undefined )\n\t\t{\n\t\t\t// No likelihoods for this record, so simply copy the last one\n\t\t\tlikelihoods = lastLikelihoods;\n\t\t}\n\n\t\tif ( likelihoods === undefined )\n\t\t{\n\t\t\t// No likelihoods yet, so break\n\t\t\tcontinue;\n\t\t}\n\n\t\tvar over = row.get( CricketField.OVER ); \n\t\tif ( over !== currentOver )\n\t\t{\n\t\t\tif ( currentOver != 0 )\t// Allow coercion\n\t\t\t{\n\t\t\t\tthis.addData( series, x, likelihoods, battingIndex, dismissals );\n\t\t\t}\n\t\t\t\n\t\t\tdismissals = [];\n\t\t\tcurrentOver = over;\n\t\t\tx++;\n\t\t}\n\t\t\n\t\tvar innings = row.get( CricketField.INNINGS );\n\t\tif ( innings !== currentInnings )\n\t\t{\n\t\t\tcurrentInnings = innings;\n\t\t\tbattingIndex = this.db.getBattingTeamIndex( innings );\n\t\t}\n\t\t\n\t\tif ( row.get( CricketField.IS_WICKET ) )\n\t\t{\n\t\t\tdismissals.push( row.get( CricketField.DISMISSED ) );\n\t\t}\n\t\t\n\t\tlastLikelihoods = likelihoods;\n\t}\n\t\n\tif ( likelihoods !== undefined )\n\t{\n\t\tthis.addData( series, x, likelihoods, battingIndex, dismissals );\n\t}\n\t\n\t// Scale the x-axis if necessary\n\tthis.config.xAxis.max = this.config.xAxis.configuredMax;\n\tif ( x > this.config.xAxis.max )\n\t{\n\t\tthis.config.xAxis.max = x;\n\t}\n\n\t// Also scale back the y-axis if there will be 3 items in the key\n\tthis.config.yAxis.end = this.config.yAxis.configuredEnd;\n\tvar testMatch = ( CricketMatchType.TEST === this.db.getMatchType() );\n\tif ( testMatch )\n\t{\n\t\t// Shift y-axis down to allow for larger key\n\t\tthis.config.yAxis.end += 30;\n\t}\n\t\n\t// Draw the axes\n\tthis.ctx.strokeStyle = 'rgba( 255, 255, 255, 1 )';\n\tthis.config.xAxis.drawTo( this.ctx, true );\n\tthis.config.yAxis.drawTo( this.ctx, false );\n\n\t// Create flexikey\n\tvar flexikey = new Flexikey( this.config.flexikey );\n\n\t// Render the draw series first, if we need to\n\tif ( testMatch )\n\t{\n\t\tthis.renderSeries( this.ctx, series[1], this.config.drawColor, 'Draw' );\n\t}\n\t\n\t// Now draw the team series\n\tvar participants = this.db.getParticipants();\n\tfor ( var team = 0; team < 2; team++ )\n\t{\n\t\tvar color = participants[ team ].primaryColor;\n\t\tthis.renderSeries( this.ctx, series[ 2 * team ], color, participants[ team ].fullName );\n\t\tflexikey.addEntry( participants[ team ].fullName, color );\n\n\t\t// Add the draw item to the key now\n\t\tif ( team === 0 && testMatch )\n\t\t{\n\t\t\tflexikey.addEntry( 'Draw', this.config.drawColor );\n\t\t}\n\t}\n\t\n\t// Render the Flexikey\n\tflexikey.render( this.ctx );\n\t\n\t// Finally render the tooltip data\n\tif ( this.tooltipData !== undefined )\n\t{\n\t\tthis.ctx.save();\n\t\tthis.ctx.strokeStyle = this.config.tooltips.background;\n\t\t\n\t\tthis.ctx.beginPath();\n\t\tthis.ctx.lineWidth = 2;\n\t\tthis.ctx.moveTo( this.tooltipData.x, this.config.yAxis.start - 1 );\n\t\tthis.ctx.lineTo( this.tooltipData.x, this.config.yAxis.end );\n\t\tthis.ctx.stroke();\n\n\t\tthis.ctx.font = this.config.tooltips.font;\n\n\t\tfor ( var labelName in this.tooltipData.labels )\n\t\t{\n\t\t\tvar label = this.tooltipData.labels[ labelName ];\n\t\t\t\n\t\t\t// If this label overlaps with another one that has a higher value, then simply\n\t\t\t// skip the rendering of this label\n\t\t\t// 1. Find all other labels within spitting distance of this one\n\t\t\tvar others = [];\n\t\t\tfor ( var labelCheck in this.tooltipData.labels )\n\t\t\t{\n\t\t\t\tif ( labelCheck === labelName )\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tvar other = this.tooltipData.labels[ labelCheck ];\n\t\t\t\tif ( Math.abs( other.y - label.y ) <= this.config.tooltips.height )\n\t\t\t\t{\n\t\t\t\t\tothers.push( other );\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 2. Find out if there is one bigger (i.e. lower y value)\n\t\t\tvar skip = false;\n\t\t\tfor ( var i = 0, j = others.length; i < j && !skip; i++ )\n\t\t\t{\n\t\t\t\tif ( others[i].y < label.y )\n\t\t\t\t{\n\t\t\t\t\tskip = true;\n\t\t\t\t}\n\t\t\t\telse if ( others[i].y === label.y )\n\t\t\t\t{\n\t\t\t\t\t// They are the same, so choose the one alphabetically first\n\t\t\t\t\tskip = others[i].string < label.string;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If there were dismissals associated with this value, or one very close to it,\n\t\t\t// then display this information in the top-left corner\n\t\t\tif ( this.dismissalData !== undefined && this.renderTextFields )\n\t\t\t{\n\t\t\t\tthis.renderTextFields = false;\n\t\t\t\tvar tf = new PULSE.TextField( this.config.dismissalTextField );\n\t\t\t\t\n\t\t\t\tvar d = '';\n\t\t\t\tfor ( dd = 0, ee = this.dismissalData.length; dd < ee; dd++ )\n\t\t\t\t{\n\t\t\t\t\tif ( dd !== 0 )\n\t\t\t\t\t{\n\t\t\t\t\t\tif ( dd === ee - 1 )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\td += ' and ';\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\td += ', ';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\td += this.dismissalData[dd];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ttf.addLine( d + ' dismissed' );\n\t\t\t\ttf.render( this.ctx );\n\t\t\t}\n\t\t\t\n\t\t\tif ( !skip )\n\t\t\t{\n\t\t\t\tvar width = Utils.stringSize( this.ctx, label.string ).width + ( 2 * this.config.tooltips.border );\n\t\t\t\tvar anchor = 'w';\n\t\t\t\tvar border = this.config.tooltips.border;\n\t\t\t\tvar offset = 1;\n\t\n\t\t\t\tthis.ctx.beginPath();\n\t\t\t\tthis.ctx.fillStyle = this.config.tooltips.background;\n\t\t\t\t\n\t\t\t\tif ( this.tooltipData.x + width > this.config.xAxis.end )\n\t\t\t\t{\n\t\t\t\t\twidth *= -1;\n\t\t\t\t\tborder *= -1;\n\t\t\t\t\toffset *= -1;\n\t\t\t\t\tanchor = 'e';\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthis.ctx.rect( this.tooltipData.x + offset, label.y - this.config.tooltips.height / 2, \n\t\t\t\t\t\twidth, this.config.tooltips.height );\n\t\t\t\tthis.ctx.fill();\n\t\t\t\n\t\t\t\tthis.ctx.fillStyle = this.config.tooltips.foreground;\n\t\t\t\tUtils.anchoredFillText( this.ctx, label.string, this.tooltipData.x + border, label.y - 2, anchor );\n\t\t\t}\n\t\t}\n\t\tthis.ctx.restore();\n\t}\n\t\n\tthis.ctx.restore();\n}"},"renderSeries":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"ctx"},{"title":"param","description":null,"type":null,"name":"series"},{"title":"param","description":null,"type":null,"name":"color"},{"title":"param","description":null,"type":null,"name":"label"}]},"Source":"WinLikelihoodRenderer.prototype.renderSeries = function ( ctx, series, color, label )\n{\n\tctx.save();\n\t\n\tctx.lineWidth = 3;\n\tctx.strokeStyle = color;\n\tctx.fillStyle = color;\n\n\t// Render the line\n\tctx.beginPath();\n\tfor ( var i = 0, j = series.length; i < j; i++ )\n\t{\n\t\tvar item = series[i];\n\t\tvar x = this.config.xAxis.project( item.x );\n\t\tvar y = this.config.yAxis.project( item.y );\n\t\t\n\t\tif ( i === 0 )\n\t\t{\n\t\t\tctx.moveTo( x, y );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tctx.lineTo( x, y );\n\t\t}\n\t\t\n\t\t// Retrieve or create the tooltip cache\n\t\tvar index = Math.round( x );\n\t\tvar cacheRecord = this.tooltipDataCache[ index ];\n\t\tif ( !cacheRecord )\n\t\t{\n\t\t\tcacheRecord = { x:x, labels:{} };\n\t\t\tthis.tooltipDataCache[ index ] = cacheRecord;\n\t\t}\n\t\t\n\t\t// Add a label into the record\n\t\tvar rec = { string:label + ': ' + Math.round( item.y ) + '%', y:y };\n\t\tif ( item.dismissals !== undefined )\n\t\t{\n\t\t\trec.z = item.dismissals.length;\n\t\t\tcacheRecord.dismissals = item.dismissals;\n\t\t}\n\t\tcacheRecord.labels[ label ] = rec;\n\t}\n\tctx.stroke();\n\t\n\t// Render the wicket falls\n\tctx.lineWidth = 1;\n\tctx.strokeStyle = this.config.fow.stroke;\n\tfor ( var i = 0, j = series.length; i < j; i++ )\n\t{\n\t\tvar item = series[i];\n\t\tif ( item.z > 0 )\n\t\t{\n\t\t\tvar x = this.config.xAxis.project( item.x );\n\t\t\tvar y = this.config.yAxis.project( item.y );\n\n\t\t\tfor ( var k = 0, l = item.z; k < l; k++ )\n\t\t\t{\n\t\t\t\tctx.beginPath();\n\t\t\t\tUtils.circle( ctx, x, y - ( k * this.config.fow.size ), this.config.fow.size / 2 );\n\t\t\t\tctx.fill();\n\t\t\t\tctx.stroke();\n\t\t\t}\n\t\t}\n\t}\n\t\n\tctx.restore();\n}"},"addData":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"series"},{"title":"param","description":null,"type":null,"name":"x"},{"title":"param","description":null,"type":null,"name":"likelihoods"},{"title":"param","description":null,"type":null,"name":"battingIndex"},{"title":"param","description":null,"type":null,"name":"dismissals"}]},"Source":"WinLikelihoodRenderer.prototype.addData = function ( series, x, likelihoods, battingIndex, dismissals )\n{\n\t// Add the 3 values to the 3 series\n\tfor ( var k = 0; k < 3; k++ )\n\t{\n\t\t// Remember to normalise y value to 0-100 from 0-1000\n\t\tvar item = { x:x, y:likelihoods[k]/10, z:0 };\n\t\tif ( dismissals.length > 0 && k === battingIndex * 2 )\n\t\t{\n\t\t\titem.z = dismissals.length;\n\t\t\titem.dismissals = dismissals;\n\t\t}\n\t\t\n\t\tseries[k].push( item );\n\t}\n}"},"onMouse":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"event"}]},"Source":"WinLikelihoodRenderer.prototype.onMouse = function ( event )\n{\n\tvar xy = Utils.getXY( event );\n\t\n\tif ( xy !== undefined && xy.y >= this.config.yAxis.end && xy.y <= this.config.yAxis.start &&\n\t\t\txy.x >= this.config.xAxis.start && xy.x <= this.config.xAxis.end )\n\t{\n\t\tthis.tooltipData = this.tooltipDataCache[ xy.x ];\n\t\t\n\t\tvar search = xy.x;\n\t\twhile ( this.tooltipData === undefined && search >= this.config.xAxis.start )\n\t\t{\n\t\t\tsearch--;\n\t\t\t// If there was no data for this x value, try using one to the left\n\t\t\tthis.tooltipData = this.tooltipDataCache[ search ];\n\t\t}\n\t\t\n\t\t// Also search for dismissals close by, so the mouse doesn't have to be exactly on it\n\t\tif ( this.tooltipData === undefined || this.tooltipData.dismissals === undefined )\n\t\t{\n\t\t\tthis.dismissalData = undefined;\n\t\t\tfor ( var offset = 1; offset <= 3; offset++ )\n\t\t\t{\n\t\t\t\tvar neighbour = this.tooltipDataCache[ xy.x - offset ];\n\t\t\t\tif ( neighbour !== undefined && neighbour.dismissals !== undefined )\n\t\t\t\t{\n\t\t\t\t\tthis.dismissalData = neighbour.dismissals;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tneighbour = this.tooltipDataCache[ xy.x + offset ];\n\t\t\t\tif ( neighbour !== undefined && neighbour.dismissals !== undefined )\n\t\t\t\t{\n\t\t\t\t\tthis.dismissalData = neighbour.dismissals;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.dismissalData = this.tooltipData.dismissals;\n\t\t}\n\t}\n\telse\n\t{\n\t\tthis.tooltipData = undefined;\n\t}\n\t\n\tthis.draw();\n}"}}},"udsData":{"Documentation":{"description":"JSONP callback function for UDS data handling.","tags":[]},"Source":"function udsData( json )\n{\n\tvar bowlerSpeeds = {};\n\tvar highestInnings = 0;\n\tvar lastKeys = {};\n\t\n\tvar countingBallDelta = 0;\n\t\n\tvar data = {};\n\t\n\tfor ( var i = 0, j = json[0].data.length; i < j; i++ )\n\t{\n\t\tvar obj = json[0].data[i];\n\t\tfor ( var key in obj )\n\t\t{\n\t\t\tvar rec = new PULSE.UdsHawkeyeRecord( key, obj[ key ] );\n\t\t\tdata[ key ] = rec;\n\t\t\t\n\t\t\tvar ballNum = +rec.get( CricketField.BALL ); \n\t\t\tif ( ballNum === 1 )\n\t\t\t{\n\t\t\t\t// First ball, so reset the countingBallDelta\n\t\t\t\tcountingBallDelta = 0;\n\t\t\t}\n\t\t\t\n\t\t\t// Set the counting ball\n\t\t\trec.countingBall = ballNum - countingBallDelta;\n\t\t\t\n\t\t\t// Update delta\n\t\t\tif ( !rec.get( CricketField.IS_COUNTING ) )\n\t\t\t{\n\t\t\t\tcountingBallDelta++;\n\t\t\t}\n\t\t\t\n\t\t\t// We also need to record the first valid bowl speed for each bowler, so we\n\t\t\t// can tell whether they are a spin or seam bowler; it might be better to store\n\t\t\t// the average rather that the first one?!\n\t\t\tvar bowler = rec.get( CricketField.BOWLER );\n\t\t\tif ( !Utils.isNullish( bowler ) && bowlerSpeeds[bowler] === undefined )\n\t\t\t{\n\t\t\t\tvar speed = rec.get( CricketField.BOWL_SPEED );\n\t\t\t\tif ( !Utils.isNullish( speed ) )\n\t\t\t\t{\n\t\t\t\t\tvar s = +speed;\n\t\t\t\t\tif ( s > 30 )\n\t\t\t\t\t{\n\t\t\t\t\t\tbowlerSpeeds[bowler] = s < 70 ? CricketBowlerSpeed.SPIN : \n\t\t\t\t\t\t\t\t\t\t\t\t\t\tCricketBowlerSpeed.SEAM;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvar innings = rec.get( CricketField.INNINGS );\n\t\t\tif ( innings > highestInnings )\n\t\t\t{\n\t\t\t\thighestInnings = innings;\n\t\t\t}\n\t\t\t\n\t\t\tlastKeys.all = key;\n\t\t\tif ( rec.hasTrajData() )\n\t\t\t{\n\t\t\t\tlastKeys.traj = key;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// Now go back through the data applying the bowlerSpeed property. We should look at a\n\t// better way of doing this - maybe storing the lookup in the metadata\n\tfor ( var key in data )\n\t{\n\t\tvar rec = data[ key ];\n\t\tvar bowler = rec.get( CricketField.BOWLER );\n\t\tif ( !Utils.isNullish( bowler ) )\n\t\t{\n\t\t\trec.bowlerSpeed = bowlerSpeeds[bowler];\n\t\t}\n\t}\n\t\t\n\t// Update prototype to return this data\n\tPULSE.UdsHawkeyeDatabase.prototype.getData = function() { return data; };\n\tPULSE.UdsHawkeyeDatabase.prototype.getMetadata = function() { return json[0].meta; };\n\tPULSE.UdsHawkeyeDatabase.prototype.getHighestInnings = function() { return highestInnings; };\n\tPULSE.UdsHawkeyeDatabase.prototype.getLastKeys = function() { return lastKeys; };\n\t\n\t// Inform listeners of the update\n\tPULSE.UdsHawkeyeDatabase.getInstance().informListener();\n}"},"udsMetadata":{"Documentation":{"description":"JSONP callback function for UDS metadata handling.","tags":[]},"Source":"function udsMetadata( json )\n{\n\tvar lastUpdated = json[0].meta[ 'last_updated' ];\n\t\n\tif ( lastUpdated !== undefined && PULSE.UdsHawkeyeDatabase.lastUpdated !== lastUpdated )\n\t{\n\t\tPULSE.Tracer.info( 'LastUpdated has changed, reloading UDS data' );\n\t\tPULSE.UdsHawkeyeDatabase.lastUpdated = lastUpdated;\n\t\tPULSE.UdsHawkeyeDatabase.updateCallback();\n\t}\n\t\n\t//stop gap solution for getting team names into client\n\tif(typeof _ !== \"undefined\" && _.isEmpty(PULSE.UdsHawkeyeDatabase.prototype.getMetadata())){\n\t\tPULSE.UdsHawkeyeDatabase.prototype.getMetadata = function() { return json[0].meta; };\n\t\tPULSE.UdsHawkeyeDatabase.getInstance().informListener();\n\t}\n}"},"Axis":{"Documentation":{"description":"title - the axis title\nmin - minimum value on the axis\nmax - maximum value on the axis\nstart - start screen coordinate of the axis\nend - end screen coordinate of the axis\nfixed - the fixed screen coordinate for the axis\nnumLabels - the approximate number of labels to display\nlabels - overridden labels, optional \noverdraw - amount of pixels to overdraw, optional\nshift - amount to shift projected values in pixels, optional","tags":[]},"Source":"function Axis( title, min, max, start, end, fixed, numLabels, labels, overdraw, shift, titleShift )\n{\n\tthis.title = title;\n\tthis.min = min;\n\tthis.max = max;\n\tthis.configuredMax = max;\n\tthis.start = start;\n\tthis.end = end;\n\tthis.configuredEnd = end;\n\tthis.fixed = fixed;\n\tthis.numLabels = numLabels;\n\tthis.labels = labels;\n\tthis.overdraw \t= overdraw   === undefined ? 0 : overdraw;\n\tthis.shift \t\t= shift \t === undefined ? 0 : shift;\n\tthis.titleShift = titleShift === undefined ? 0 : titleShift;\n}","prototype":{"project":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"Axis.prototype.project"},{"title":"param","description":null,"type":null,"name":"value"}]},"Source":"Axis.prototype.project = function ( value )\n{\n\t// Clamp the value to within the range\n\tvar clamped = value;\n\tif ( clamped < this.min )\n\t{\n\t\tclamped = this.min;\n\t}\n\tif ( clamped > this.max )\n\t{\n\t\tclamped = this.max;\n\t}\n\t\n\treturn this.shift + this.start + \n\t\t( ( ( clamped - this.min ) / ( this.max - this.min ) ) * ( this.end - this.start ) );\n}"},"drawTo":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"ctx"},{"title":"param","description":null,"type":null,"name":"isX"}]},"Source":"Axis.prototype.drawTo = function ( ctx, isX )\n{\n\tctx.save();\n\tctx.strokeStyle = 'rgba(255,255,255,1)';\n\tctx.fillStyle = 'rgba(255,255,255,1)';\n\tctx.lineCap = 'square';\n\tctx.lineWidth = 2;\n\n\tctx.beginPath();\n\tif ( isX )\n\t{\n\t\tctx.moveTo( this.start, this.fixed );\n\t\tctx.lineTo( this.end + this.overdraw, this.fixed );\n\t}\n\telse\n\t{\n\t\tctx.moveTo( this.fixed, this.start );\n\t\tctx.lineTo( this.fixed, this.end + this.overdraw );\n\t}\n\tctx.stroke();\n\t\n\t// Draw tick labels\n\tvar spacing = Math.round( ( this.max - this.min ) / this.numLabels );\n\t\n\t// Round spacing to the nearest 10, if we can\n\tvar newSpacing = 10 * ( Math.round( spacing / 10 ) );\n\tif ( newSpacing > 0 )\n\t{\n\t\tspacing = newSpacing;\n\t}\n\t\n\tfor ( var val = this.min; val <= this.max; val += spacing )\n\t{\n\t\tvar pos = this.project( val );\n\t\t\n\t\tvar label = val;\n\t\tif ( this.labels !== undefined && this.labels[ val ] !== undefined )\n\t\t{\n\t\t\tlabel = this.labels[ val ];\n\t\t}\n\t\t\n\t\tif ( isX )\n\t\t{\n\t\t\tUtils.anchoredFillText( ctx, label, pos, this.fixed + 4, 'n' );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tUtils.anchoredFillText( ctx, label, this.fixed - 4, pos, 'e' );\n\t\t}\n\t}\n\t\t\n\t// Draw axis title\n\tvar pos = this.project( ( this.min + this.max ) / 2 );\n\tif ( isX )\n\t{\n\t\tUtils.anchoredFillText( ctx, this.title, pos, this.fixed + 25 + this.titleShift, 'n' );\n\t}\n\telse\n\t{\n\t\tvar x = this.fixed - 37 - this.titleShift;\n\t\tvar y = pos;\n\t\t\n\t\tctx.save();\n\t\tctx.rotate( Math.PI / -2 );\n\t\tctx.translate( -y - x, -y + x );\n\t\tUtils.anchoredFillText( ctx, this.title, x, y, 's' );\n\t\tctx.restore();\n\t}\n\t\n\tctx.restore();\n}"}}},"Flexikey":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"Flexikey"},{"title":"param","description":null,"type":null,"name":"config"}]},"Source":"function Flexikey( config )\n{\n\tthis.entries = [];\n\tthis.config = config;\n}","prototype":{"addEntry":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"label"},{"title":"param","description":null,"type":null,"name":"color"}]},"Source":"Flexikey.prototype.addEntry = function ( label, color )\n{\n\tthis.entries.push( { label:label, color:color } );\n}"},"render":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"ctx"}]},"Source":"Flexikey.prototype.render = function ( ctx )\n{\n\tctx.save();\n\n\t// Calculate the size of the flexikey\n\tvar height = this.config.margin.top;\n\tvar width = this.config.margin.left;\n\n\tvar maxWidth = 0;\n\tvar sheight = 0;\n\tfor ( var i = 0, j = this.entries.length; i < j; i++ )\n\t{\n\t\tvar entry = this.entries[i];\n\t\tvar ss = Utils.stringSize( ctx, entry.label );\n\n\t\theight += ss.height + this.config.spacing;\n\t\tsheight = ss.height;\n\n\t\tif ( ss.width > maxWidth )\n\t\t{\n\t\t\tmaxWidth = ss.width;\n\t\t}\n\t}\n\n\theight += this.config.margin.bottom - this.config.spacing;\n\twidth += this.config.swatch.size + this.config.swatch.spacing + maxWidth + this.config.margin.right;\n\n\tvar origin = Utils.adjustForAnchor( this.config.position.x, this.config.position.y,\n\t\t\t  { width:width, height:height }, this.config.position.anchor );\n\n\t// Draw the background\n\tctx.save();\n\tctx.beginPath();\n\tctx.fillStyle = this.config.background;\n\tctx.rect( origin.x, origin.y, width, height );\n\tctx.fill();\n\tctx.restore();\n\n\tvar x0 = origin.x + this.config.margin.left + ( this.config.swatch.size / 2 );\n\tvar x1 = x0 + ( this.config.swatch.size / 2 ) + this.config.swatch.spacing;\n\n\t// Draw each key entry\n\tvar y = origin.y + this.config.margin.top + ( sheight / 2 );\n\n\tctx.font = this.config.font;\n\tfor ( var i = 0, j = this.entries.length; i < j; i++ )\n\t{\n\t\tvar entry = this.entries[i];\n\n\t\tctx.beginPath();\n\t\tctx.fillStyle = entry.color;\n\t\tUtils.circle( ctx, x0, y, this.config.swatch.size / 2 );\n\t\tctx.fill();\n\t\tctx.fillStyle = this.config.textColour || 'white';\n\t\tUtils.anchoredFillText( ctx, entry.label, x1, y, 'w' );\n\n\t\ty += sheight + this.config.spacing;\n\t}\n\n\tctx.restore();\n}"}}},"Graph":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"Graph"},{"title":"param","description":null,"type":null,"name":"background"},{"title":"param","description":null,"type":null,"name":"mask"},{"title":"param","description":null,"type":null,"name":"renderer"}]},"Source":"function Graph( background, mask, renderer )\n{\n\t// Save configuration\n\tthis.bgLoaded = false;\n\tthis.maskLoaded = false;\n\tthis.renderer = renderer;\n\t\n\t// Load images asynchronously\n\tvar that = this;\n\tthis.bg = new Image();\n\tthis.bg.onload = function () { that.bgLoaded = true;  };\n\t\n\tif ( background )\n\t{\n\t\tthis.bg.src = PULSE.config.IMAGE_URL_PREFIX + background;\n\t}\n\t\n\tthis.mask = new Image();\n\tthis.mask.onload = function () { that.maskLoaded = true;  };\n\t\n\tif ( mask )\n\t{\n\t\tthis.mask.src = PULSE.config.IMAGE_URL_PREFIX + mask;\n\t}\n}","prototype":{"render":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"data"},{"title":"param","description":null,"type":null,"name":"ctx"}]},"Source":"Graph.prototype.render = function ( data, ctx )\n{\n\tthis.renderer.render( data, ctx );\n}"}}},"this":{"bg":{"onload":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"this.bg.onload = function () { that.bgLoaded = true;  }"}},"mask":{"onload":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"this.mask.onload = function () { that.maskLoaded = true;  }"}},"root":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"this.root\t\t= function(){ return root; }"}},"GraphPanel":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"GraphPanel"},{"title":"param","description":null,"type":null,"name":"elementId"}]},"Source":"function GraphPanel( elementId )\n{\n\tthis.canvas = document.getElementById( elementId );\n    this.ctx = this.canvas.getContext( '2d' );\n}","prototype":{"getContext":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"GraphPanel.prototype.getContext = function()\n{\n\treturn this.ctx;\n}"},"setCanvasElementSize":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"width"},{"title":"param","description":null,"type":null,"name":"height"}]},"Source":"GraphPanel.prototype.setCanvasElementSize = function( width, height )\n{\n\tthis.canvas.setAttribute( 'width', width );\n\tthis.canvas.setAttribute( 'height', height );\n}"}}},"NonLinearAxis":{"Documentation":{"description":"title - the axis title\nmin - minimum value on the axis\nmax - maximum value on the axis\nstart - start screen coordinate of the axis\nend - end screen coordinate of the axis\nfixed - the fixed screen coordinate for the axis\nnumLabels - the approximate number of labels to display\nspec - the non-linear specification\nlabels - overridden labels, optional","tags":[]},"Source":"function NonLinearAxis( title, min, max, start, end, fixed, numLabels, spec, labels )\n{\n\tthis.title = title;\n\tthis.min = min;\n\tthis.max = max;\n\tthis.start = start;\n\tthis.end = end;\n\tthis.fixed = fixed;\n\tthis.numLabels = numLabels;\n\tthis.spec = spec;\n\tthis.labels = labels;\n\t\n\tthis.overdraw = 0;\n\tthis.shift = 0;\n\tthis.titleShift = 0;\n}","prototype":{"project":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"NonLinearAxis.prototype.project"},{"title":"param","description":null,"type":null,"name":"value"}]},"Source":"NonLinearAxis.prototype.project = function ( value )\n{\n\t// Clamp the value to within the range\n\tvar clamped = value;\n\tif ( clamped < this.min )\n\t{\n\t\tclamped = this.min;\n\t}\n\tif ( clamped > this.max )\n\t{\n\t\tclamped = this.max;\n\t}\n\t\n\t// Now apply the non-linear spec\n\tvar proportion;\n\tfor ( var i = 1, j = this.spec.length; i < j; i++ )\n\t{\n\t\tvar limit = this.spec[i][0];\n\t\tvar fraction = this.spec[i][1];\n\t\t\n\t\tif ( clamped <= limit )\n\t\t{\n\t\t\t// Add the fraction from the previous limit\n\t\t\tproportion = this.spec[i-1][1];\n\t\t\t\n\t\t\t// Add the proportional size in this limit\n\t\t\tvar dx = this.spec[i][0] - this.spec[i-1][0];\n\t\t\tvar xx = clamped - this.spec[i-1][0];\n\t\t\tvar dy = this.spec[i][1] - this.spec[i-1][1];\n\t\t\t\n\t\t\tproportion += ( xx / dx ) * dy; \n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn this.start + ( proportion * ( this.end - this.start ) );\n}"}}},"OldProjection":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"OldProjection"},{"title":"param","description":null,"type":null,"name":"xyz"},{"title":"param","description":null,"type":null,"name":"rpy"},{"title":"param","description":null,"type":null,"name":"ar"},{"title":"param","description":null,"type":null,"name":"fl"},{"title":"param","description":null,"type":null,"name":"center"}]},"Source":"function OldProjection( xyz, rpy, ar, fl, center ) \n{\n\tthis.xyz \t= xyz;\n\tthis.rpy \t= rpy;\n\tthis.ar  \t= ar;\n\tthis.fl  \t= fl;\n\tthis.center = center;\n\tthis.LUT \t= [ [ 0, 1, 2 ], [ 1, 0, 2 ], [2, 0, 1] ];\n}","prototype":{"distanceSquared":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"world"}]},"Source":"OldProjection.prototype.distanceSquared = function ( world )\n{\n    var dx = world.x - this.xyz.x;\n    var dy = world.y - this.xyz.y;\n    var dz = world.z - this.xyz.z;\n    var dsquared = dx*dx + dy*dy + dz*dz;\n    return dsquared;\n}"},"project":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"world"}]},"Source":"OldProjection.prototype.project = function ( world )\n{\n\tif ( this.rot === undefined )\n\t{\n\t\tthis.rot = this.makeRotation();\n\t}\n\t\n\tvar newWorld = [ world.x - this.xyz.x, world.y - this.xyz.y, world.z - this.xyz.z ];\n\tvar cam = this.matrixVectorMultiply( this.rot, newWorld );\n\t\n\tif ( cam[2] < 1e-9 )\n\t{\n\t\tcam[2] = -1e-9;\n\t}\n\n    var x = this.center.x + ( ( cam[0] / cam[2] ) * this.fl );\n    var y = this.center.y + ( ( cam[1] / cam[2] ) * this.fl * this.ar );\n    return { x:x, y:y, dsquared:this.distanceSquared( world ) };\n}"},"makeRotation":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"OldProjection.prototype.makeRotation = function()\n{\n    var mRoll  = this.axisRotation( 2, this.rpy.r );\n    var mPitch = this.axisRotation( 0, this.rpy.p );\n    var mYaw   = this.axisRotation( 2, this.rpy.y );\n\n    var m = this.matrixMatrixMultiply( mRoll, mPitch );\n    m = this.matrixMatrixMultiply( m, mYaw );\n\n    return m;\n}"},"axisRotation":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"axis"},{"title":"param","description":null,"type":null,"name":"angle"}]},"Source":"OldProjection.prototype.axisRotation = function( axis, angle )\n{\n    var i0 = this.LUT[axis][0];\n    var i1 = this.LUT[axis][1];\n    var i2 = this.LUT[axis][2];\n\n    var rot = [ [0,0,0], [0,0,0], [0,0,0] ]; \n    rot[i0][i0] = 1.0;\n    rot[i1][i1] = Math.cos( angle );\n    rot[i2][i2] = Math.cos( angle );\n    rot[i1][i2] = Math.sin( angle );\n    rot[i2][i1] = -rot[i1][i2];\n\n    return rot;\n}"},"matrixMatrixMultiply":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"a"},{"title":"param","description":null,"type":null,"name":"b"}]},"Source":"OldProjection.prototype.matrixMatrixMultiply = function( a, b )\n{\n\treturn [\n\t        [ a[0][0]*b[0][0] + a[0][1]*b[1][0] + a[0][2]*b[2][0], a[0][0]*b[0][1] + a[0][1]*b[1][1] + a[0][2]*b[2][1], a[0][0]*b[0][2] + a[0][1]*b[1][2] + a[0][2]*b[2][2] ],\n\t        [ a[1][0]*b[0][0] + a[1][1]*b[1][0] + a[1][2]*b[2][0], a[1][0]*b[0][1] + a[1][1]*b[1][1] + a[1][2]*b[2][1],\ta[1][0]*b[0][2] + a[1][1]*b[1][2] + a[1][2]*b[2][2] ],\n            [ a[2][0]*b[0][0] + a[2][1]*b[1][0] + a[2][2]*b[2][0], a[2][0]*b[0][1] + a[2][1]*b[1][1] + a[2][2]*b[2][1],\ta[2][0]*b[0][2] + a[2][1]*b[1][2] + a[2][2]*b[2][2] ]\n\t       ];\n}"},"matrixVectorMultiply":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"a"},{"title":"param","description":null,"type":null,"name":"b"}]},"Source":"OldProjection.prototype.matrixVectorMultiply = function( a, b )\n{\n\treturn [ a[0][0]*b[0] + a[0][1]*b[1] + a[0][2]*b[2],\n\t         a[1][0]*b[0] + a[1][1]*b[1] + a[1][2]*b[2],\n\t         a[2][0]*b[0] + a[2][1]*b[1] + a[2][2]*b[2] ];\n}"}}},"Participant":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"Participant"},{"title":"param","description":null,"type":null,"name":"team"}]},"Source":"function Participant( team )\n{\n\tif ( team )\n\t{\t\t\t\n\t\tthis.fullName = team.fullName;\n\t\tthis.shortName = team.shortName;\n\t\tthis.abbreviation = team.abbreviation;\n\t\tthis.primaryColor = '#' + team.primaryColor;\n\t\tthis.secondaryColor = '#' + team.secondaryColor;\n\t}\n}"},"Projection":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"Projection"},{"title":"param","description":null,"type":null,"name":"xyz"},{"title":"param","description":null,"type":null,"name":"rpy"},{"title":"param","description":null,"type":null,"name":"ar"},{"title":"param","description":null,"type":null,"name":"fl"},{"title":"param","description":null,"type":null,"name":"center"}]},"Source":"function Projection( xyz, rpy, ar, fl, center ) \n{\n\tthis.xyz \t= xyz;\n\tthis.rpy \t= rpy;\n\tthis.ar  \t= ar;\n\tthis.fl  \t= fl;\n\tthis.center = center;\n\tthis.LUT \t= [ [ 0, 1, 2 ], [ 1, 0, 2 ], [2, 0, 1] ];\n\t\n    this.near = 0.01;\n    this.far = 1000;\n    this.fov = Math.PI / 6;\n    this.aspect = center.y / center.x;\n}","prototype":{"distanceSquared":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"world"}]},"Source":"Projection.prototype.distanceSquared = function ( world )\n{\n    var dx = world.x - this.xyz.x;\n    var dy = world.y - this.xyz.y;\n    var dz = world.z - this.xyz.z;\n    var dsquared = dx*dx + dy*dy + dz*dz;\n    return dsquared;\n}"},"project":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"world"}]},"Source":"Projection.prototype.project = function ( world )\n{\n\tif ( this.rot === undefined )\n\t{\n\t\tthis.rot = this.makeRotation();\n\t}\n\t\n\tif ( this.projectionMatrix == undefined )\n\t{\n\t    this.projectionMatrix = this.makeProjection();\n\t}\n\t\n\tvar newWorld = [ world.x - this.xyz.x, world.y - this.xyz.y, world.z - this.xyz.z ];\n\tvar cam = this.matrixVectorMultiply( this.rot, newWorld );\n\t\n\t// Extend to a homogeneous coordinate\n    cam[3] = 1;\n    // Project into image space\n    var projected = this.matrixVectorMultiply4( this.projectionMatrix, cam );\n    \n    return { x : projected[0], y : projected[1], z : projected[2], w : projected[3] };\n}"},"clipLine":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"point1"},{"title":"param","description":null,"type":null,"name":"point2"}]},"Source":"Projection.prototype.clipLine = function( point1, point2 )\n{\n\tvar res = [];\n\t\n\tres = this.clipLineAgainstPlane( [ point1, point2 ], this.clipLineW );\n\tres = this.clipLineAgainstPlane( res, this.clipLineY );\n\tres = this.clipLineAgainstPlane( res, this.clipLineNegY );\n\tres = this.clipLineAgainstPlane( res, this.clipLineX );\n\tres = this.clipLineAgainstPlane( res, this.clipLineNegX );\n\t\n\treturn res;\n}"},"clipLineAgainstPlane":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"points"},{"title":"param","description":null,"type":null,"name":"planeCheckFunction"}]},"Source":"Projection.prototype.clipLineAgainstPlane = function( points, planeCheckFunction )\n{\n    var temp1 = points[0];\n    var temp2 = points[1];\n    \n    if ( temp1 && temp2 )\n    {\n    \treturn planeCheckFunction( temp1, temp2, this );\n    }\n    \n    return[];\n}"},"clipLineW":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"point1"},{"title":"param","description":null,"type":null,"name":"point2"},{"title":"param","description":null,"type":null,"name":"projectionObj"}]},"Source":"Projection.prototype.clipLineW = function( point1, point2, projectionObj )\n{\n\t// Clip against the w=0 plane\n\t\n    if ( !projectionObj.isInW( point1 ) && !projectionObj.isInW( point2 ) )\n    {\n        return [];\n    }\n    else if ( !projectionObj.isInW( point1 ) )\n    {\n        var scale = point1.w / ( point1.w - point2.w );\n        point1 = projectionObj.intersectVector4( point1, point2, scale );\n    }\n    else if ( !projectionObj.isInW( point2 ) )\n    {\n        var scale = point2.w / ( point2.w - point1.w );\n        point2 = projectionObj.intersectVector4( point2, point1, scale );\n    }\n    \n    return[ point1, point2 ];\n}"},"clipLineX":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"point1"},{"title":"param","description":null,"type":null,"name":"point2"},{"title":"param","description":null,"type":null,"name":"projectionObj"}]},"Source":"Projection.prototype.clipLineX = function( point1, point2, projectionObj )\n{\n    // Now clip against w=x plane\n    if ( !projectionObj.isInX( point1 ) && !projectionObj.isInX( point2 ) )\n    {\n        return [];\n    }\n    else if ( !projectionObj.isInX( point1 ) )\n    {\n        var scale = ( point1.w - point1.x ) / ( ( point1.w - point1.x ) - ( point2.w - point2.x ) );\n        point1 = projectionObj.intersectVector4( point1, point2, scale );\n    }\n    else if ( !projectionObj.isInX( point2 ) )\n    {\n        var scale = ( point2.w - point2.x ) / ( ( point2.w - point2.x ) - ( point1.w - point1.x ) );\n        point2 = projectionObj.intersectVector4( point2, point1, scale );\n    }\n    \n    return[ point1, point2 ];\n}"},"clipLineNegX":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"point1"},{"title":"param","description":null,"type":null,"name":"point2"},{"title":"param","description":null,"type":null,"name":"projectionObj"}]},"Source":"Projection.prototype.clipLineNegX = function( point1, point2, projectionObj )\n{\n    // Now clip against w=-x plane\n    if ( !projectionObj.isInNegX( point1 ) && !projectionObj.isInNegX( point2 ) )\n    {\n        return [];\n    }\n    else if ( !projectionObj.isInNegX( point1 ) )\n    {\n        var scale = ( point1.w + point1.x ) / ( ( point1.w + point1.x ) - ( point2.w + point2.x ) );\n        point1 = projectionObj.intersectVector4( point1, point2, scale );\n    }\n    else if ( !projectionObj.isInNegX( point2 ) )\n    {\n        var scale = ( point2.w + point2.x ) / ( ( point2.w + point2.x ) - ( point1.w + point1.x ) );\n        point2 = projectionObj.intersectVector4( point2, point1, scale );\n    }\n    \n    return[ point1, point2 ];\n}"},"clipLineY":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"point1"},{"title":"param","description":null,"type":null,"name":"point2"},{"title":"param","description":null,"type":null,"name":"projectionObj"}]},"Source":"Projection.prototype.clipLineY = function( point1, point2, projectionObj )\n{\n\t// Clip against w=y plane\n    if ( !projectionObj.isInY( point1 ) && !projectionObj.isInY( point2 ) )\n    {\n        return [];\n    }\n    else if ( !projectionObj.isInY( point1 ) )\n    {\n        var scale = ( point1.w - point1.y ) / ( ( point1.w - point1.y ) - ( point2.w - point2.y ) );\n        point1 = projectionObj.intersectVector4( point1, point2, scale );\n    }\n    else if ( !projectionObj.isInY( point2 ) )\n    {\n        var scale = ( point2.w - point2.y ) / ( ( point2.w - point2.y ) - ( point1.w - point1.y ) );\n        point2 = projectionObj.intersectVector4( point2, point1, scale );\n    }\n    \n    return[ point1, point2 ];\n}"},"clipLineNegY":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"point1"},{"title":"param","description":null,"type":null,"name":"point2"},{"title":"param","description":null,"type":null,"name":"projectionObj"}]},"Source":"Projection.prototype.clipLineNegY = function( point1, point2, projectionObj )\n{\n    // Clip against w=-y plane\n    if ( !projectionObj.isInNegY( point1 ) && !projectionObj.isInNegY( point2 ) )\n    {\n        return [];\n    }\n    else if ( !projectionObj.isInNegY( point1 ) )\n    {\n        var scale = ( point1.w + point1.y ) / ( ( point1.w + point1.y ) - ( point2.w + point2.y ) );\n        point1 = projectionObj.intersectVector4( point1, point2, scale );\n    }\n    else if ( !projectionObj.isInNegY( point2 ) )\n    {\n        var scale = ( point2.w + point2.y ) / ( ( point2.w + point2.y ) - ( point1.w + point1.y ) );\n        point2 = projectionObj.intersectVector4( point2, point1, scale );\n    }\n    \n    return[ point1, point2 ];\n}"},"isInW":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"point"}]},"Source":"Projection.prototype.isInW = function( point )\n{\n\tvar res = false;\n\tif ( !( point.w < 0 ) )\n\t{\n\t\tres = true;\n\t}\n\treturn res;\n}"},"isInX":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"point"}]},"Source":"Projection.prototype.isInX = function( point )\n{\t\n\tvar res = false;\n\tif ( !( point.x - point.w > 0 ) )\n\t{\n\t\tres = true;\n\t}\t\n\treturn res;\n}"},"isInNegX":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"point"}]},"Source":"Projection.prototype.isInNegX = function( point )\n{\t\t\n\tvar res = false;\n\tif ( !( point.x + point.w < 0 ) )\n\t{\n\t\tres = true;\n\t}\n\treturn res;\t\t\n}"},"isInY":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"point"}]},"Source":"Projection.prototype.isInY = function( point )\n{\n\tvar res = false;\n\tif ( !( point.y - point.w > 0 ) )\n\t{\n\t\tres = true;\n\t}\n\treturn res;\n}"},"isInNegY":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"point"}]},"Source":"Projection.prototype.isInNegY = function( point )\n{\t\n\tvar res = false;\n\tif ( !( point.y + point.w < 0 ) )\n\t{\n\t\tres = true;\n\t}\n\treturn res;\n}"},"clipTriangles":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"triangles"}]},"Source":"Projection.prototype.clipTriangles = function( triangles )\n{\n\tvar res = [];\n\tres = this.clipTrianglesAgainstPlane( triangles, this.isInW, this.clipLineW );\n\n\tres = this.clipTrianglesAgainstPlane( res, this.isInY, this.clipLineY );\n\tres = this.clipTrianglesAgainstPlane( res, this.isInNegY, this.clipLineNegY );\n\t\n\tres = this.clipTrianglesAgainstPlane( res, this.isInX, this.clipLineX );\n\tres = this.clipTrianglesAgainstPlane( res, this.isInNegX, this.clipLineNegX );\n\t\n\treturn res;\n}"},"clipTrianglesAgainstPlane":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"trgs"},{"title":"param","description":null,"type":null,"name":"pointPlaneCheckFunction"},{"title":"param","description":null,"type":null,"name":"lineClipFunction"}]},"Source":"Projection.prototype.clipTrianglesAgainstPlane = function( trgs, pointPlaneCheckFunction, lineClipFunction )\n{\n\tvar clippedTrgs = [];\n\t\n\tfor( var i = 0, limit = trgs.length; i < limit; i++ )\n\t{\n\t\tvar trg = trgs[i];\n\t\t\n\t\tvar inside = [];\n\t\tvar outside = [];\n\t\t\n\t\tfor ( var j = 0, limit2 = trg.length; j < limit2; j++ )\n\t\t{\n\t\t\tvar p = trg[j];\n\t\t\tif ( pointPlaneCheckFunction( p ) )\n\t\t\t{\n\t\t\t\tinside.push( p );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\toutside.push( p );\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar count = inside.length;\t\t\n\t\t\n\t\tif ( count === 3 ) // All points are in, leave as it is\n\t\t{\n\t\t\tclippedTrgs.push( trg );\n\t\t}\n\t\telse if ( count === 1 )\n\t\t{\t\t\t\t\n\t\t\tvar pIn = inside[0];\n\t\t\tvar pOut = outside[0];\n\t\t\tvar pOutTwo = outside[ 1 ];\n\t\t\t\n\t\t\t// Clip, 1st point in, 1st point out\n\t\t\t// Clip, 1st point in, 2nd point out\n\t\t\tvar clOne = this.clipLineAgainstPlane( [pIn, pOut], lineClipFunction );\n\t\t\tvar clTwo = this.clipLineAgainstPlane( [pIn, pOutTwo], lineClipFunction );\n\t\t\t\n\t\t\t// Add the new triangle\n\t\t\tif ( clOne.length === 2 && clTwo.length === 2 )\n\t\t\t{\n\t\t\t\tclippedTrgs.push( [ pIn, clOne[1], clTwo[1] ] )\t\n\t\t\t}\t\t\t\t\t\t\t\t\n\t\t}\n\t\telse if ( count === 2 )\n\t\t{\n\t\t\tvar pInOne = inside[0];\n\t\t\tvar pInTwo = inside[1];\n\t\t\tvar pOut = outside[0];\n\t\t\t\n\t\t\t// Clip 1st, onlyOut\n\t\t\t// Clip 2nd, onlyOut\n\t\t\tvar clOne = this.clipLineAgainstPlane( [pInOne, pOut], lineClipFunction );\n\t\t\tvar clTwo = this.clipLineAgainstPlane( [pInTwo, pOut], lineClipFunction );\n\t\t\t\n\t\t\tif ( clOne.length === 2 && clTwo.length === 2 )\n\t\t\t{\n\t\t\t\t// Triangles\n\t\t\t\tvar trgOne = [ pInOne, pInTwo, clTwo[1] ];\n\t\t\t\tvar trgTwo = [ pInOne, clOne[1], clTwo[1] ];\n\t\t\t\t\n\t\t\t\tclippedTrgs.push( trgOne );\n\t\t\t\tclippedTrgs.push( trgTwo );\n\t\t\t}\t\n\t\t}\n\t\t// Implied else === 0, no points were in, don't add anything\n\t}\n\t\n\treturn clippedTrgs;\n}"},"intersectVector4":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"vector1"},{"title":"param","description":null,"type":null,"name":"vector2"},{"title":"param","description":null,"type":null,"name":"scale"}]},"Source":"Projection.prototype.intersectVector4 = function( vector1, vector2, scale )\n{\n    return { x : vector1.x + scale * ( vector2.x - vector1.x ),\n             y : vector1.y + scale * ( vector2.y - vector1.y ),\n             z : vector1.z + scale * ( vector2.z - vector1.z ),\n             w : vector1.w + scale * ( vector2.w - vector1.w ) };\n}"},"makeProjection":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"Projection.prototype.makeProjection = function()\n{\n    var halfFov = this.fov / 2;\n    var h = Math.cos( halfFov ) / Math.sin( halfFov );\n    var w = this.aspect * h;\n    var q = this.far / ( this.far - this.near );\n    \n    return [ [ w, 0, 0, 0 ],\n             [ 0, h, 0, 0 ],\n             [ 0, 0, q, -q * this.near ],\n             [ 0, 0, 1.0, 0 ] ];\n}"},"makeRotation":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"Projection.prototype.makeRotation = function()\n{\n    var mRoll  = this.axisRotation( 2, this.rpy.r );\n    var mPitch = this.axisRotation( 0, this.rpy.p );\n    var mYaw   = this.axisRotation( 2, this.rpy.y );\n\n    var m = this.matrixMatrixMultiply( mRoll, mPitch );\n    m = this.matrixMatrixMultiply( m, mYaw );\n\n    return m;\n}"},"axisRotation":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"axis"},{"title":"param","description":null,"type":null,"name":"angle"}]},"Source":"Projection.prototype.axisRotation = function( axis, angle )\n{\n    var i0 = this.LUT[axis][0];\n    var i1 = this.LUT[axis][1];\n    var i2 = this.LUT[axis][2];\n\n    var rot = [ [0,0,0], [0,0,0], [0,0,0] ]; \n    rot[i0][i0] = 1.0;\n    rot[i1][i1] = Math.cos( angle );\n    rot[i2][i2] = Math.cos( angle );\n    rot[i1][i2] = Math.sin( angle );\n    rot[i2][i1] = -rot[i1][i2];\n\n    return rot;\n}"},"matrixMatrixMultiply":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"a"},{"title":"param","description":null,"type":null,"name":"b"}]},"Source":"Projection.prototype.matrixMatrixMultiply = function( a, b )\n{\n\treturn [\n\t        [ a[0][0]*b[0][0] + a[0][1]*b[1][0] + a[0][2]*b[2][0], a[0][0]*b[0][1] + a[0][1]*b[1][1] + a[0][2]*b[2][1], a[0][0]*b[0][2] + a[0][1]*b[1][2] + a[0][2]*b[2][2] ],\n\t        [ a[1][0]*b[0][0] + a[1][1]*b[1][0] + a[1][2]*b[2][0], a[1][0]*b[0][1] + a[1][1]*b[1][1] + a[1][2]*b[2][1],\ta[1][0]*b[0][2] + a[1][1]*b[1][2] + a[1][2]*b[2][2] ],\n            [ a[2][0]*b[0][0] + a[2][1]*b[1][0] + a[2][2]*b[2][0], a[2][0]*b[0][1] + a[2][1]*b[1][1] + a[2][2]*b[2][1],\ta[2][0]*b[0][2] + a[2][1]*b[1][2] + a[2][2]*b[2][2] ]\n\t       ];\n}"},"matrixVectorMultiply":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"a"},{"title":"param","description":null,"type":null,"name":"b"}]},"Source":"Projection.prototype.matrixVectorMultiply = function( a, b )\n{\n\treturn [ a[0][0]*b[0] + a[0][1]*b[1] + a[0][2]*b[2],\n\t         a[1][0]*b[0] + a[1][1]*b[1] + a[1][2]*b[2],\n\t         a[2][0]*b[0] + a[2][1]*b[1] + a[2][2]*b[2] ];\n}"},"matrixVectorMultiply4":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"a"},{"title":"param","description":null,"type":null,"name":"b"}]},"Source":"Projection.prototype.matrixVectorMultiply4 = function( a, b )\n{\n    return [ a[0][0]*b[0] + a[0][1]*b[1] + a[0][2]*b[2] + a[0][3]*b[3],\n             a[1][0]*b[0] + a[1][1]*b[1] + a[1][2]*b[2] + a[1][3]*b[3],\n             a[2][0]*b[0] + a[2][1]*b[1] + a[2][2]*b[2] + a[2][3]*b[3],\n             a[3][0]*b[0] + a[3][1]*b[1] + a[3][2]*b[2] + a[3][3]*b[3] ];\n}"},"updateCenterAspectRatio":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"width"},{"title":"param","description":null,"type":null,"name":"height"}]},"Source":"Projection.prototype.updateCenterAspectRatio = function( width, height )\n{\n\tthis.center.x = width / 2;\n\tthis.center.y = height / 2; \n\tthis.aspect = this.center.y / this.center.x;\n}"},"updateProjectionOnResize":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"width"},{"title":"param","description":null,"type":null,"name":"height"}]},"Source":"Projection.prototype.updateProjectionOnResize = function( width, height )\n{\n\tthis.updateCenterAspectRatio( width, height );\n\tthis.projectionMatrix = this.makeProjection();\n}"},"toScreenCoords":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"imageSpace"}]},"Source":"Projection.prototype.toScreenCoords = function( imageSpace )\n{\n    return { x : this.center.x * ( imageSpace.x + 1 ), y : this.center.y * ( imageSpace.y + 1 ) };\n}"},"normaliseToImageCube":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"point4"}]},"Source":"Projection.prototype.normaliseToImageCube = function( point4 )\n{\n\tvar p = point4;\n    return { x : p.x / p.w, y : p.y / p.w, z : p.z / p.w, w : p.w };\t\n}"},"projectPoints":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"points"}]},"Source":"Projection.prototype.projectPoints = function( points )\n{\n\tvar projPoints = [];\n\tfor ( var i = 0, limit = points.length; i < limit; i++ )\n\t{\n\t\tprojPoints.push( this.project( points[i] ) );\n\t}\n\treturn projPoints;\n}"},"normalisePoints":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"points"}]},"Source":"Projection.prototype.normalisePoints = function( points )\n{\n\tvar normPoints = [];\n\tfor ( var i = 0, limit = points.length; i < limit; i++ )\n\t{\n\t\tnormPoints.push( this.normaliseToImageCube( points[i] ) );\n\t}\n\treturn normPoints;\t\t\n}"},"toScreenCoordsPoints":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"points"}]},"Source":"Projection.prototype.toScreenCoordsPoints = function( points )\n{\n\tvar screenPoints = [];\n\tfor ( var i = 0, limit = points.length; i < limit; i++ )\n\t{\n\t\tscreenPoints.push( this.toScreenCoords( points[i] ) );\n\t}\n\treturn screenPoints;\t\n}"},"normaliseAndToScreen":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"point"}]},"Source":"Projection.prototype.normaliseAndToScreen = function( point )\n{\n\tif ( point )\n\t{\n\t\treturn this.toScreenCoords( this.normaliseToImageCube( point ) );\t\t\n\t}\n}"}}},"window":{"callback":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"jsonpData"}]},"Source":"window[callback] = function ( jsonpData )\n\t{\n\t\tif ( jsonpData )\n\t\t{\n\t\t\tvar payload = jsonpData;\n\t\t\t\n\t\t\t// Serialise the payload\n\t\t\tvar serialised = $.toJSON( payload );\n\t\t    if ( that.lastdata[id] !== serialised )\n\t\t    {\n\t\t    \t// Save the new data\n\t\t    \tthat.lastdata[id] = serialised;\n\t\t\t\t\n\t\t\t\t// Pass the data to all of the targets...\n\t\t\t\tfor ( var t = 0, tlimit = currentTargets.length; t < tlimit; t++ )\n\t\t\t\t{\n\t\t\t\t\t// ...if they are valid\n\t\t\t\t\tvar target = currentTargets[t];\n\t\t\t\t\tif ( target && target.onData )\n\t\t\t\t\t{\n\t\t\t\t\t\ttarget.onData( payload, id );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t    }\n\t\t}\n\t}"},"isDateValid":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"date"}]},"Source":"window.isDateValid = function( date )\n{\n    if( Object.prototype.toString.call( date ) === \"[object Date]\" )\n    {\n        // it is a date\n        if( isNaN( date.getTime() ) )\n        {\n            return false;\n        }\n        else\n        {\n            return true;\n        }\n    }\n    else\n    {\n        return false;\n    }\n}"},"requestAnimFrame":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"window.requestAnimFrame = (function() {\n  return window.requestAnimationFrame ||\n         window.webkitRequestAnimationFrame ||\n         window.mozRequestAnimationFrame ||\n         window.oRequestAnimationFrame ||\n         window.msRequestAnimationFrame ||\n         function(/* function FrameRequestCallback */ callback, /* DOMElement Element */ element) {\n           window.setTimeout(callback, 1000/60);\n         };\n}"}},"detectWakeFromSleep":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"detectWakeFromSleep"}]},"Source":"function detectWakeFromSleep()\n    {\n        var now = +new Date;\n        if( (now - _lastTick) > 240000 )\n        {\n            if( window.navigator.onLine === false )\n            {\n                return false; //don't refresh if they are not online\n            }\n\n            window.location.href = window.location.href;\n        }\n\n        _lastTick = now;\n        return true;\n    }"},"resizeend":{"Documentation":{"description":"Detects when the user has stopped resizing the window","tags":[{"title":"param","description":"Callback function to be called on end of resize","type":{"type":"NameExpression","name":"Function"},"name":"callback"}]},"Source":"function resizeend()\n    {\n        if( new Date() - rtime < delta )\n        {\n            setTimeout( resizeend, delta );\n        }\n        else\n        {\n            timeout = false;\n            if( callback )\n            {\n                callback();\n            }\n        }\n    }"},"String":{"prototype":{"startsWith":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"str"}]},"Source":"String.prototype.startsWith = function(str)\n    {return (this.match(\"^\"+str)==str)}"},"endsWith":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"str"}]},"Source":"String.prototype.endsWith = function(str)\n    {return (this.match(str+\"$\")==str)}"}}},"$":{"fn":{"imgLoader":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"$.fn.imgLoader"},{"title":"param","description":null,"type":null,"name":"desiredImg"},{"title":"param","description":null,"type":null,"name":"backupImg"}]},"Source":"$.fn.imgLoader = function( desiredImg, backupImg/*, height, width */ )\r\n\t{\r\n\t\tvar that = this,\r\n\t\t\theight = this.height(),\r\n\t\t\twidth = this.width();\r\n\t\t\r\n\t\t//empty the containing element\r\n\t\tthis.empty();\r\n\t\t\r\n\t\t//create the preloader \r\n\t\tvar $loadOverlay = \r\n\t\t$( '<div>' ).addClass( 'loadOverlay' )\r\n\t\t.hide()\r\n\t\t.append(\r\n\t\t\t$( '<div>' ).addClass( 'loadOverlayContent' )\r\n\t\t\t.append(\r\n\t\t\t\t$( '<div>' ).addClass( 'loadAnimate' )\r\n\t\t\t)\r\n\t\t);\r\n\t\t\r\n\t\t//create the img element \r\n\t\tvar $img = $( '<img>' );\r\n\t\t\r\n\t\t//append overlay\r\n\t\t$loadOverlay.appendTo( this );\r\n\r\n\t\t//append image\r\n\t\t//potentially append once fade in is complete\r\n\t\t$img.appendTo( that );\r\n\t\t\r\n\t\t//fadeIn\r\n\t\t$loadOverlay.fadeIn( 'slow', function()\r\n\t\t{ \r\n\t\t\t\r\n\t\t\t$img\r\n\t\t\t.attr( 'src', desiredImg )\r\n\t\t\t.each(function() {\r\n\t\t\t\tif( this.complete )\r\n\t\t\t\t{\r\n\t\t\t\t\t//if the image was cached, fadeOut straight away\r\n\t\t\t\t\t$loadOverlay.fadeOut();\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\t$(this).load( function()\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t//if the image was not cached, when the image loads, fadeOut\r\n\t\t\t\t\t\t$(this).data( 'loadAttempted', true );\r\n\t\t\t\t\t\t$loadOverlay.fadeOut();\r\n\t\t\t\t\t} )\r\n\t\t\t\t}\r\n\t\t\t} )\r\n\t\t\t.error( function() { if(!$(this).data('loadAttempted')){ $(this).attr( 'src', backupImg ); $loadOverlay.fadeOut(); $(this).data( 'loadAttempted', true ) } } );\r\n\t\t} );\r\n\t\t\r\n\t\t\r\n\t}"}}},"xmlToJson":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"xmlToJson"},{"title":"param","description":null,"type":null,"name":"xml"},{"title":"param","description":null,"type":null,"name":"tab"}]},"Source":"function xmlToJson(xml,tab) {\r\n   tab = !tab ? '' : tab;\r\n   var X = {\r\n      toObj: function(xml) {\r\n         var o = {};\r\n         if (xml.nodeType==1) {   // element node ..\r\n            if (xml.attributes.length)   // element with attributes  ..\r\n               for (var i=0; i<xml.attributes.length; i++)\r\n                  o[\"@\"+xml.attributes[i].nodeName] = (xml.attributes[i].nodeValue||\"\").toString();\r\n            if (xml.firstChild) { // element has child nodes ..\r\n               var textChild=0, cdataChild=0, hasElementChild=false;\r\n               for (var n=xml.firstChild; n; n=n.nextSibling) {\r\n                  if (n.nodeType==1) hasElementChild = true;\r\n                  else if (n.nodeType==3 && n.nodeValue.match(/[^ \\f\\n\\r\\t\\v]/)) textChild++; // non-whitespace text\r\n                  else if (n.nodeType==4) cdataChild++; // cdata section node\r\n               }\r\n               if (hasElementChild) {\r\n                  if (textChild < 2 && cdataChild < 2) { // structured element with evtl. a single text or/and cdata node ..\r\n                     X.removeWhite(xml);\r\n                     for (var n=xml.firstChild; n; n=n.nextSibling) {\r\n                        if (n.nodeType == 3)  // text node\r\n                           o[\"#text\"] = X.escape(n.nodeValue);\r\n                        else if (n.nodeType == 4)  // cdata node\r\n                           o[\"#cdata\"] = X.escape(n.nodeValue);\r\n                        else if (o[n.nodeName]) {  // multiple occurence of element ..\r\n                           if (o[n.nodeName] instanceof Array)\r\n                              o[n.nodeName][o[n.nodeName].length] = X.toObj(n);\r\n                           else\r\n                              o[n.nodeName] = [o[n.nodeName], X.toObj(n)];\r\n                        }\r\n                        else  // first occurence of element..\r\n                           o[n.nodeName] = X.toObj(n);\r\n                     }\r\n                  }\r\n                  else { // mixed content\r\n                     if (!xml.attributes.length)\r\n                        o = X.escape(X.innerXml(xml));\r\n                     else\r\n                        o[\"#text\"] = X.escape(X.innerXml(xml));\r\n                  }\r\n               }\r\n               else if (textChild) { // pure text\r\n                  if (!xml.attributes.length)\r\n                     o = X.escape(X.innerXml(xml));\r\n                  else\r\n                     o[\"#text\"] = X.escape(X.innerXml(xml));\r\n               }\r\n               else if (cdataChild) { // cdata\r\n                  if (cdataChild > 1)\r\n                     o = X.escape(X.innerXml(xml));\r\n                  else\r\n                     for (var n=xml.firstChild; n; n=n.nextSibling)\r\n                        o[\"#cdata\"] = X.escape(n.nodeValue);\r\n               }\r\n            }\r\n            if (!xml.attributes.length && !xml.firstChild) o = null;\r\n         }\r\n         else if (xml.nodeType==9) { // document.node\r\n            o = X.toObj(xml.documentElement);\r\n         }\r\n         else\r\n            alert(\"unhandled node type: \" + xml.nodeType);\r\n         return o;\r\n      },\r\n      toJson: function(o, name, ind) {\r\n         var json = name ? (\"\\\"\"+name+\"\\\"\") : \"\";\r\n         if (o instanceof Array) {\r\n            for (var i=0,n=o.length; i<n; i++)\r\n               o[i] = X.toJson(o[i], \"\", ind+\"\\t\");\r\n            json += (name?\":[\":\"[\") + (o.length > 1 ? (\"\\n\"+ind+\"\\t\"+o.join(\",\\n\"+ind+\"\\t\")+\"\\n\"+ind) : o.join(\"\")) + \"]\";\r\n         }\r\n         else if (o == null)\r\n            json += (name&&\":\") + \"null\";\r\n         else if (typeof(o) == \"object\") {\r\n            var arr = [];\r\n            for (var m in o)\r\n               arr[arr.length] = X.toJson(o[m], m, ind+\"\\t\");\r\n            json += (name?\":{\":\"{\") + (arr.length > 1 ? (\"\\n\"+ind+\"\\t\"+arr.join(\",\\n\"+ind+\"\\t\")+\"\\n\"+ind) : arr.join(\"\")) + \"}\";\r\n         }\r\n         else if (typeof(o) == \"string\")\r\n            json += (name&&\":\") + \"\\\"\" + o.toString() + \"\\\"\";\r\n         else\r\n            json += (name&&\":\") + o.toString();\r\n         return json;\r\n      },\r\n      innerXml: function(node) {\r\n         var s = \"\"\r\n         if (\"innerHTML\" in node)\r\n            s = node.innerHTML;\r\n         else {\r\n            var asXml = function(n) {\r\n               var s = \"\";\r\n               if (n.nodeType == 1) {\r\n                  s += \"<\" + n.nodeName;\r\n                  for (var i=0; i<n.attributes.length;i++)\r\n                     s += \" \" + n.attributes[i].nodeName + \"=\\\"\" + (n.attributes[i].nodeValue||\"\").toString() + \"\\\"\";\r\n                  if (n.firstChild) {\r\n                     s += \">\";\r\n                     for (var c=n.firstChild; c; c=c.nextSibling)\r\n                        s += asXml(c);\r\n                     s += \"</\"+n.nodeName+\">\";\r\n                  }\r\n                  else\r\n                     s += \"/>\";\r\n               }\r\n               else if (n.nodeType == 3)\r\n                  s += n.nodeValue;\r\n               else if (n.nodeType == 4)\r\n                  s += \"<![CDATA[\" + n.nodeValue + \"]]>\";\r\n               return s;\r\n            };\r\n            for (var c=node.firstChild; c; c=c.nextSibling)\r\n               s += asXml(c);\r\n         }\r\n         return s;\r\n      },\r\n      escape: function(txt) {\r\n         return txt.replace(/[\\\\]/g, \"\\\\\\\\\")\r\n                   .replace(/[\\\"]/g, '\\\\\"')\r\n                   .replace(/[\\n]/g, '\\\\n')\r\n                   .replace(/[\\r]/g, '\\\\r');\r\n      },\r\n      removeWhite: function(e) {\r\n         e.normalize();\r\n         for (var n = e.firstChild; n; ) {\r\n            if (n.nodeType == 3) {  // text node\r\n               if (!n.nodeValue.match(/[^ \\f\\n\\r\\t\\v]/)) { // pure whitespace text node\r\n                  var nxt = n.nextSibling;\r\n                  e.removeChild(n);\r\n                  n = nxt;\r\n               }\r\n               else\r\n                  n = n.nextSibling;\r\n            }\r\n            else if (n.nodeType == 1) {  // element node\r\n               X.removeWhite(n);\r\n               n = n.nextSibling;\r\n            }\r\n            else                      // any other node\r\n               n = n.nextSibling;\r\n         }\r\n         return e;\r\n      }\r\n   };\r\n   if (xml.nodeType == 9) // document node\r\n      xml = xml.documentElement;\r\n   var json = X.toJson(X.toObj(X.removeWhite(xml)), xml.nodeName, \"\\t\");\r\n   return \"{\\n\" + tab + (tab ? json.replace(/\\t/g, tab) : json.replace(/\\t|\\n/g, \"\")) + \"\\n}\";\r\n}"},"asXml":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"n"}]},"Source":"var asXml = function(n) {\r\n               var s = \"\";\r\n               if (n.nodeType == 1) {\r\n                  s += \"<\" + n.nodeName;\r\n                  for (var i=0; i<n.attributes.length;i++)\r\n                     s += \" \" + n.attributes[i].nodeName + \"=\\\"\" + (n.attributes[i].nodeValue||\"\").toString() + \"\\\"\";\r\n                  if (n.firstChild) {\r\n                     s += \">\";\r\n                     for (var c=n.firstChild; c; c=c.nextSibling)\r\n                        s += asXml(c);\r\n                     s += \"</\"+n.nodeName+\">\";\r\n                  }\r\n                  else\r\n                     s += \"/>\";\r\n               }\r\n               else if (n.nodeType == 3)\r\n                  s += n.nodeValue;\r\n               else if (n.nodeType == 4)\r\n                  s += \"<![CDATA[\" + n.nodeValue + \"]]>\";\r\n               return s;\r\n            }"},"onPollCallback":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"pollData"}]},"Source":"var onPollCallback = function( pollData )\n{\t\n\tvar thisInstance = PULSE.CLIENT.PollController.getInstance();\n\t\n\tif ( pollData && pollData[0] )\n\t{\n\t\tvar payload = pollData[0];\n\t\t\n\t\t// Serialise the payload\n\t\tvar serialised = $.toJSON( payload );\n\t\t\n\t    if ( thisInstance.lastData !== serialised )\n\t    {\n\t    \t// Save the new data\n\t    \tthisInstance.lastData = serialised;\n\t    \tthisInstance.pollModel.modelChanged( pollData[0] );\n\t    }\n\t}\n}"},"div":{"onselectstart":{"Documentation":{"description":"Constructor.","tags":[{"title":"param","description":"the ID of the div that the canvas should go in","type":null,"name":"divId"},{"title":"param","description":"configuration parameters for the canvas","type":null,"name":"config"}]},"Source":"div.onselectstart = function() { return false; }"},"onmousedown":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"constructor","description":null,"type":null,"name":"div.onmousedown"},{"title":"param","description":null,"type":null,"name":"e"}]},"Source":"div.onmousedown = function( e ) { \n    \tthat.anchor = PULSE.Utils.getXY( e );\n    }"},"onmouseup":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"div.onmouseup = function() { that.anchor = undefined; }"},"onmousemove":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"e"}]},"Source":"div.onmousemove = function ( e ) {\n    \tif ( that.anchor )\n    \t{\n\t    \tvar pos = PULSE.Utils.getXY( e );\n\t    \tvar diff = { x: that.anchor.x - pos.x, y: that.anchor.y - pos.y };\n\t    \t\n        \t$(div).css( 'left', diff.x + 'px' );\n        \t$(div).css( 'top', diff.x + 'px' );\n\t    \t\n\t    \tthat.anchor = pos;\n    \t}\n    }"}},"that":{"filter":{"getAllTeams":{"idIsInTeams":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"id"}]},"Source":"var idIsInTeams = function( id )\n\t\t\t{\n\t\t\t\tfor ( var i = 0; i < teams.length; i++ ) \n\t\t\t\t{\n\t\t\t\t\tvar team = teams[i];\n\t\t\t\t\tif( team.id() === id )return true;\n\t\t\t\t}\n\t\t\t}"}},"getAllVenues":{"Documentation":{"description":"This Function Needs Documentation","tags":[]},"Source":"that.filter.getAllVenues = function ()\n\t\t{\n\t\t\tvar venues \t= [],\n\t\t\t\tschedule= that.schedule();\n\n\t\t\tvar idIsInVenues = function( id )\n\t\t\t{\n\t\t\t\tfor ( var i = 0; i < venues.length; i++ ) \n\t\t\t\t{\n\t\t\t\t\tvar venue = venues[i];\n\t\t\t\t\tif( venue.id() === id )return true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor ( var i = 0; i < schedule.length; i++ ) \n\t\t\t{\n\t\t\t\tvar venue = schedule[i].venue;\n\t\t\t\t\n\t\t\t\tif ( venue )\n\t\t\t\t{\n\t\t\t\t\tif ( !idIsInVenues( venue.id() ) )\n\t\t\t\t\t{\n\t\t\t\t\t\tvenues.push( venue );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// Sort venues ( by city ) array alphabetically \n\t\t\tvenues.sort( function(a, b) \n\t\t\t{\n\t\t        var cityA = a.city().toLowerCase(), cityB = b.city().toLowerCase();\n\t\t        if ( cityA < cityB ) //sort city ascending\n\t\t        {\n\t\t        \treturn -1;\n\t\t        }\n\t\t        if ( cityA > cityB )\n\t\t        {\n\t\t            return 1;\n\t\t        }        \n\t\t        return 0; //default return value (no sorting)\n\t\t    });\n\t\t\t\n\t\t\treturn venues;\n\t\t}","idIsInVenues":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"id"}]},"Source":"var idIsInVenues = function( id )\n\t\t\t{\n\t\t\t\tfor ( var i = 0; i < venues.length; i++ ) \n\t\t\t\t{\n\t\t\t\t\tvar venue = venues[i];\n\t\t\t\t\tif( venue.id() === id )return true;\n\t\t\t\t}\n\t\t\t}"}},"teamById":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"id"}]},"Source":"that.filter.teamById = function ( id )\n\t\t{\n\t\t\tvar schedule = that.schedule();\n\t\t\t\n\t\t\tfor ( var i = 0; i < schedule.length; i++ ) \n\t\t\t{\n\t\t\t\tvar team1 = schedule[i].team1;\n\t\t\t\tvar team2 = schedule[i].team2;\n\t\t\t\t\n\t\t\t\tif ( team1.team.id() === id )\n\t\t\t\t{\n\t\t\t\t\treturn team1.team;\n\t\t\t\t}\n\n\t\t\t\tif ( team2.team.id() === id )\n\t\t\t\t{\n\t\t\t\t\treturn team2.team;\n\t\t\t\t}\n\t\t\t}\n\t\t}"},"venueById":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"id"}]},"Source":"that.filter.venueById = function ( id )\n\t\t{\n\t\t\tvar schedule = that.schedule();\n\t\t\t\n\t\t\tfor ( var i = 0; i < schedule.length; i++ ) \n\t\t\t{\n\t\t\t\tvar venue = schedule[i].venue;\n\t\t\t\t\n\t\t\t\tif ( venue.id() === id )\n\t\t\t\t{\n\t\t\t\t\treturn venue;\n\t\t\t\t}\n\t\t\t}\n\t\t}"},"toggleTeams":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"d"},{"title":"param","description":null,"type":null,"name":"e"}]},"Source":"that.filter.toggleTeams = function( d, e )\n\t\t{\n\t\t\tthat.filter.teamsFilterOpen( !that.filter.teamsFilterOpen() );\n\t\t\t\n\t\t\tif( that.filter.venueFilterOpen() )\n\t\t\t{\n\t\t\t\tthat.filter.venueFilterOpen( false );\n\t\t\t}\n\t\t}"},"toggleVenue":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"d"},{"title":"param","description":null,"type":null,"name":"e"}]},"Source":"that.filter.toggleVenue = function( d, e )\n\t\t{\n\t\t\tthat.filter.venueFilterOpen( !that.filter.venueFilterOpen() );\n\n\t\t\tif( that.filter.teamsFilterOpen() )\n\t\t\t{\n\t\t\t\tthat.filter.teamsFilterOpen( false );\n\t\t\t}\n\t\t}"},"filterTeams":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"d"},{"title":"param","description":null,"type":null,"name":"e"}]},"Source":"that.filter.filterTeams = function( d, e )\n\t\t{\n\t\t\tthat.filter.teamId( d.id() );\n\t\t\t\n\t\t\tthat.filter.toggleTeams();\n\t\t}"},"filterVenues":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"d"},{"title":"param","description":null,"type":null,"name":"e"}]},"Source":"that.filter.filterVenues = function( d, e )\n\t\t{\n\t\t\tthat.filter.venueId( d.id() );\n\t\t\t\n\t\t\tthat.filter.toggleVenue();\n\t\t}"}},"openMatchCentre":{"Documentation":{"description":"This Function Needs Documentation","tags":[{"title":"param","description":null,"type":null,"name":"d"},{"title":"param","description":null,"type":null,"name":"e"}]},"Source":"that.openMatchCentre = function( d, e )\n\t{\n\t\tvar name \t\t\t= d.matchId.name(),\n\t\t\tmatchNumber \t= PULSE.CLIENT.IPLT20.Common.getMatchNumber( name ),\n\t\t\tmatchCentreLink = that.matchCentreLink(),\n\t\t\tmatchUrl \t\t= matchCentreLink + matchNumber;\n\t\t\n\t\twindow.open( matchUrl, 'IPLT20', \n\t\t\t'height=672,width=980,menubar=no,resizable=no,scrollbars=no,status=no,toolbar=no,location=no' ); \n\t}"}}}